---
title: 关于使用 NextJs 的一些经验
date: '2023-11-23'
---

## 关于 use client

[你也可以用 `import 'client-only'](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns)

https://stackoverflow.com/questions/74992326/does-use-client-in-next-js-13-root-layout-make-whole-routes-client-component
https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns#supported-pattern-passing-server-components-to-client-components-as-props
layout.js 里面是可以使用 use client, 不会导致子组件全部变成 client

## RSC

注意: RSC 不是 ssr 的升级(他们是两种不同的概念)

https://nextjs.org/docs/app/building-your-application/rendering/server-components
There are a couple of benefits to doing the rendering work on the server, including:

1. Data Fetching: Server Components allow you to move data fetching to the server, closer to your data source. This can improve performance by reducing time it takes to fetch data needed for rendering, and the amount of requests the client needs to make.

2. Security

3. Caching:

4. Bundle Sizes

React renders Server Components into a special data format(可序列的数据化的数据, 用于 server=> 向 client 的数据传递) called the React Server Component Payload (RSC Payload), which includes references to Client Components(占位符).
(rsc payload 和 client component 进行 hydration(水合), 渲染 html, 使其具备交互能力)
The React Server Components Payload is used to reconcile the Client and Server Component trees, and update the DOM.(维护 dom tree)

Since Client Components are rendered after Server Components, you cannot import a Server Component into a Client Component module (since it would require a new request back to the server). Instead, you can pass a Server Component as props to a Client Component. See the unsupported pattern and supported pattern sections below.
(之所以不能嵌入就是因为最小边界时文件不是组件), props 可以保证完全区分组件类型, 使用占位符代替, 注意这里的数据必须时可序列化的, 对象/函数是不能作为 props 传递的

```tsx
// clientcomponent.tsx
'use client';

import ServerComponent from './ServerComponent';

export default function ClientComponent({
  server,
}: {
  server: React.ReactElement;
}) {
  return (
    <div>
      <div>ClientComponent</div>
      <div>server content is : {server}</div>
      {/* <div>{children}</div> */}
    </div>
  );
}

// servercomponent.tsx
'use server';

export default async function ServerComponent() {
  //   const a = { a: 1 }; // wrong
  //   const aa = [{b: 2}] // wrong
  const a = ['hi', 2]; // binggo
  console.log('Hello from Server Component');
  return <>Hello from Server Component {a}</>;
}


// page.tsx
<ClientComponent server={<ServerComponent />} />
// 这种传props 的用法不多, 更多的是 client component nesed to server component


// 为了减少客户端的js bundle size, 尽量保持client component move to client, 但是 那种props  传递的server component 的用法对此没有影响, 因为客户端渲染的时候会跳过client, 要避免的主要是直接在父级直接使用client, 导致嵌入的组件全部变成了client, 尽量将client 抽离出去
```

自从 React18 的文档更新以后, 引起了不小的讨论, react 不再一味的像以前推荐 CRA, 而是建议使用基于 React 的框架进行学习 React, 而且这一推荐放在了很重要的开头位置(NextJs 和 React 的合作很密切)

有人认为新手学习 React 就使用框架会不会太重, 也有人觉得新手就应该使用框架, 因为 React 只能算一个 Ui 库, 不足以真正满足开发需求, 如果不使用框架, 什么都要自己进行配置, 打不到最佳实践

<Icon icon="skill-icons:nextjs-light" /> NextJs 13 让 RSC 有重新出现在人们眼前, React
已经一年没有发版, React 实在进行底层库的转变(越来越像一个库)

## NextJs Cache

next 缓存总是会导致一些奇怪的 bug, 本地开发需要 rm .next, vercel 需要重新部署

比如手动加上 postcss.config.js 后, 需要清空缓存, 因为 tailwindcss 缺少这个文件是不能正常工作的, 之前的 cache 是不会自动更新这部分的, 需要清空缓存, 从来没了解过缓存是根据什么机制更新的, 从之前的电脑有问题第一想到的是重启, 现在我第一时间选择 `rm .next`, 然后清空浏览器缓存

## Tailwind

<Icon icon="skill-icons:tailwindcss-dark" /> Tailwind 在 NextJs 里面似乎很受支持(:rocket:),
直接在 CNA 里面内置了选项支持

ps: 今天才知道 tailwindcss 原来还有个 tailwindcss@insider 的 package(text-balance 只有这里能用, 我说那个 pr 明明合进仓库了, 为什么用不了, 翻了 issue 才知道)

## RSC

使用 rsc 的过程中, 总是回想, 这个代码是在那里运行, server or client, 还是都可以, 我应该选择那一个?(有人调侃道, 前端在十几年的时间里跑了一圈)

## vecel analysics

可以用来监视站点的浏览情况(不过 Hobby 版只能设置一个站点, 并且有 2500 次的上限)

## Bright

代码块高亮无需配置(解析代码是通过 fetch 对应的 json 文件得到的, 所以代码快类型越多, 加载越慢), 虽然是 rsc, 但是由于使用 next/mdx, 没有使用 ssg, 所以加载代码高亮仍然比较满, 因为需要等待服务端渲染完成, 服务段生成后, 再次访问速度就很快了

## Next Link

next 默认配置好了路由缓存, 所以不要担心瀑布问题

## Vercel/kv

vercel 的 kv 可以看作 redis, `key-value` 存储数据, 比如用来存储评论, 点赞数目, 站点浏览量, 或者用来存储 chatgpt 的对话;

## Code Highlight

code-hike 仅仅支持客户端渲染, 默认代码字体比较小, bright(code-hike 写的)无需配置, 支持 rsc; 速度上没有很明显的差异

## components test

## 代码分割

- 代码分割的好处是减少了首次访问某个页面的加载时间, 仅仅加载当前网页需要的资源

## Vercel

- vercel hobby 仅能创建 50 个项目

## RSC

rsc 好处没明显感受到, 反而是每次都要处理 s 与 c 的关系, 写组件的速度明显慢了不少, rsc 在一定程度上促进了 Tailwindcss, css-in-js 不适用于 rsc

## React

react 当前的生态有点类似与 archlinux, neovim, 很容易产生 break change, 灵活的同时, 也带来了一定的成本

## Next.js Bug

- 嵌套路由概率性不刷新(概率很小, 复现不了)
- 基于路由/组件的代码拆分
- 内存问题(如果 dev 环境下, 如果多次刷新, 就会有 memory 问题, 写#游戏的时候复现)

## shadcn-ui

- 感觉更像是 snippets 或者说 template(现在很多的库都开始基于 tailwindcss 进行二次开发封装)

## NextUI

- 需要包一层 use client, 下面的所有组件都是客户端组件了?
- 有点像 shadcn-ui, 只不过改成包了, 为了支持 rsc, 分离每一个组件为一个包, 配合 frmaer-motion, 效果不错, 使用起来有点别扭

## storybook

- 调试组件???
- 如果使用 framer-motion, 就需要把组件拆出来, 比如 `<Transition>{children}</Transition>`

* 每次修改 next.config.js, 都需要重启
* 最近 nextjs 更新后, blurdata 的效果更差了

* 如果 mp3 文件没有放在 public 目录下, 而是放在 src 或者其他目录下, 则需要在 next.config.js 文件中自定义 webpack 配置

```mp3.config.js
  webpack: (
    config,
    { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack },
  ) => {
    config.module.rules.push({
      test: /\.mp3$/,
      type: 'asset/resource',
      generator: {
        filename: 'static/chunks/[path][name].[hash][ext]',
      },
    });
    // Important: return the modified config
    return config;
  },
```
