[{"title":"200-304","text":"HTTP 状态码中的\"200\"和\"304\"分别表示不同的含义。\r\n\r\n\"200 OK\"表示请求成功，服务器已成功处理请求并返回所请求的资源。这是一种正常的响应状态码，表示服务器已经成功地处理了请求。\r\n\r\n\"304 Not Modified\"表示在条件 GET 请求中，资源未发生变化，客户端可以使用缓存的版本。这通常是在使用缓存的情况下使用的状态码，用于减少不必要的数据传输。服务器告诉客户端它可以继续使用之前缓存的版本，而不需要从服务器重新下载。\r\n\r\n总结起来，\"200 OK\"表示请求成功并返回资源，而\"304 Not Modified\"表示资源未修改，可以继续使用缓存的版本。","type":"text/markdown","created":"20230816142531444","creator":"oeyoews","modified":"20230816142544987","modifier":"oeyoews","tags":"JavaScript"},{"title":"2023-02-28","text":"> 无论人生上了哪一层台阶 ，阶下有人在仰望你，阶上亦有人在俯视你；你抬头自卑，低头自得，唯有平视，才能看到真实的自已。 @杨绛语录","type":"text/markdown","created":"20230227161122306","creator":"oeyoews","modified":"20230227161235064","modifier":"oeyoews","tags":"Journal"},{"title":"2023-04-16","text":"初级赚钱方式靠信息差，\r\n高级赚钱方式靠认知差，\r\n顶级赚钱方式靠资源差","type":"text/markdown","created":"20230416015612098","creator":"oeyoews","modified":"20230416015615482","modifier":"oeyoews","tags":"Journal"},{"title":"2023-04-20","text":"多端同步的便捷和本地存储的安全，就是鱼与熊掌不可兼得。","type":"text/markdown","created":"20230420125325715","creator":"oeyoews","modified":"20230420125327693","modifier":"oeyoews","tags":"Journal"},{"title":"2023-04-23","text":"> 延迟满足\r\n> 用书籍增加三倍人生体验时长\r\n> 不以成喜，不以败悲\r\n\r\n“止观止心，无妄无碍”是禅宗的一种修行方法，也是佛教徒在生活中追求内心平静和解脱的方式。\r\n\r\n其中，“止”指的是停止杂念、烦恼等不必要的思考和行为，如止诸恶、止杀戮、止谤言等。这样可以使内心得到安定和净化，有利于后续的修行。\r\n\r\n“观”则指观察事物的真相和本质，排除偏见和执着。通过观想自己和世界的真实性质，认识自己的本性和命运，从而达到身心合一、彻底了解自己和世界的目的。\r\n\r\n“无妄”则表示去除「妄念」、「妄想」和「妄语」等，即清空心灵中荒谬无稽的幻想和自我，让自己的内心变得更加安宁、平静。\r\n\r\n“无碍”则是指避免心态上的障碍和物质层面的附着，为达到自由和解脱而努力。\r\n\r\n总之，这个修行方法要求个人通过内省、检视和拯救自己，消除恶念与烦恼，培养慈悲之心，领悟事物的真实本质，从而找到内心的平静和解放。\r\n\r\n> 客观事物发展规律不以人的主观意志，然而掌握事物的发展规律，却可以从必然王国到自由王国\r\n\r\n这句话的意思是，客观事物的发展规律是客观存在的，不受人的主观意志的影响。但是，如果我们能够掌握这些规律并对它们进行改变和运用，我们就可以从必然王国（受客观规律支配的领域）进入自由王国（自由创造或创新的领域）。\r\n\r\n在许多领域中，我们都可以看到这一点。例如，在科学技术领域，我们通过研究和掌握客观规律，开发出了许多有用的工具和技术，使我们的生产和生活更加便利和高效。同样，在社会和经济领域中，通过深入了解客观规律，我们可以制定出更好的政策和管理方法，以促进社会和经济的稳定和发展。\r\n\r\n尽管客观规律的存在使我们受到限制，但如果我们学会理解和运用这些规律，我们就可以发挥自己的主动性和创造性，实现更高的自由度，并不断推动事物的进步和发展。因此，掌握客观规律是实现自由和创造的关键之一。","type":"text/markdown","created":"20230423154439909","creator":"oeyoews","modified":"20230423161636440","modifier":"oeyoews","tags":"Journal"},{"title":"2023-04-25","text":"傲慢与偏见 导演角度\n<https://space.bilibili.com/43109229/channel/collectiondetail?sid=1234748>","type":"text/markdown","created":"20230425150144450","creator":"oeyoews","modified":"20231017134333146","modifier":"Lenovo","tags":"Journal"},{"title":"2023-05-06","text":":::abstract\n拥有能让自己快乐的能力,有一件让自己兴奋一点的事情\n:::","type":"text/markdown","created":"20230506145136333","creator":"oeyoews","modified":"20231017041623342","modifier":"Lenovo","publish":"public","tags":"Journal"},{"title":"2023-05-17","text":"* 所有的 dom-tom-image 都会有跨域的问题\r\n\r\n\r\n井蛙不可以语于海者，拘于虚也；//空间局限\r\n\r\n夏虫不可以语于冰者，笃于时也；//时间局限\r\n\r\n曲士不可以语于道者，束于教也。//认识局限\r\n\r\n> https://coolshell.cn/articles/20276.html\r\n\r\n遵循个规范而已，把“正常”叫“优雅”，可见标准有多低。这么低的标准也只能“为了吃饭而生存了”\r\n最后友情提示一下：在手机上学习并不是最好的学习方式，也不要在我的专栏上进行学习，把我的专栏当成一个你的助手，当成一个向导，当成一个跳板，真正的学习还是要在线下，专心的，系统地、有讨论地、不断实践地学习，这点希望大家切记！\r\n\r\n","type":"text/markdown","created":"20230517011051753","creator":"oeyoews","modified":"20230726045248265","modifier":"oeyoews","tags":"Journal"},{"title":"2023-05-29","text":"> [ref](https://www.youtube.com/watch?v=fkMEF69m4mE)\r\n\r\n* 随手可得的快乐\r\n* 在很多地方过度消耗多巴胺\r\n* 多巴胺饱和\r\n\r\n* 内容切换: 从一个房间走到另外一个房间, 或者徒步走到田野丛林里面 or anywhere, 但是在抖音这样的 app 上, 30 分钟内你可以获得 10000 次内容切换\r\n\r\n[[视频信息流鸦片]]","type":"text/markdown","created":"20230529005706785","creator":"oeyoews","modified":"20230726045248267","modifier":"oeyoews","tags":"Journal"},{"title":"2023-05-30","text":"> [ref](https://www.bilibili.com/video/BV1Lk4y177S8/?spm_id_from=trigger_reload&vd_source=d6afd7eedd9f9c940321c63f0a1539e3)\r\n\r\n世面(世界的哪一面呢, 又是谁的世界呢): 坦然的接受这个世界上千奇百怪的人和事\r\n\r\n> 认知半径限制了自己不知道该干什么, ","type":"text/markdown","created":"20230530094754336","creator":"oeyoews","modified":"20230726045248268","modifier":"oeyoews","tags":"Journal"},{"title":"2023-06-13","text":"不是所有的事情,问题都要解决的, 人总是需要选择的嘛","type":"text/markdown","created":"20230613114651579","creator":"oeyoews","modified":"20231017135745911","modifier":"Lenovo","tags":"Journal"},{"title":"2023-06-18","text":"写代码还是竖屏舒服","type":"text/markdown","created":"20230618091921356","creator":"oeyoews","modified":"20231009095312782","modifier":"Lenovo","tags":"Journal"},{"title":"2023-11-05 10:57:31","text":"nextjs 的 app route 如何没有发现根目录的 layout.tsx, 会自动生成","type":"text/markdown","created":"20231105025802000","creator":"Lenovo","modified":"20231106085655997","modifier":"Lenovo","tags":"nextjs Journal"},{"title":"2023/09/13","text":"不要在 tw 网站上使用语言翻译类的浏览器插件 !!!\r\n不要在 tw 网站上使用语言翻译类的浏览器插件 !!!\r\n不要在 tw 网站上使用语言翻译类的浏览器插件 !!!","type":"text/markdown","created":"20230913014844572","modified":"20230913015034979","tags":"Journal"},{"title":"2023/10/03","text":"简述彻底不行了\r\n\r\n1. 文章的推荐列表完全固定（内容完全是低俗内容）， 简述网站似乎不再维护，能薅一点是一点\r\n2. 手机上打开过一段时间会自动定向到 baidu 搜索界面\r\n\r\n知乎(现在需要验证了,离谱）， 掘金， 这种平台几乎都区别不大\r\n\r\n--- \r\n\r\nfirefox chrome 都是支持画中画的， 只不过都要手动才能开启(chrome 似乎不起作用)","type":"text/markdown","created":"20231003034637704","creator":"oeyoews","modified":"20231003112125789","modifier":"oeyoews","tags":"Journal"},{"title":"2023/10/13","text":"echart 对 theme 支持不友好, 暂时使用 dark/light(tailwindcss) 动态切换\n\n* 复杂的话就封装一下嘛, 让它看起来很简单,notion 之所以认为简单, 是因为你能用他们封装好的功能, 非常局限\n\n:::note\n果然涉及到 dark/light 的适配都很麻烦\n:::\n\n> ppchart.com 有一些额外的 echcart 代码\n* https://www.makeapie.cn/echarts","type":"text/markdown","created":"20231013035712219","creator":"Lenovo","modified":"20231013080134027","modifier":"Lenovo","tags":"Journal"},{"title":"2023/10/15","text":"window 不能识别到安装的 vscode\n\n> 之前是通过软件助手下载的, 只需要手动从官网安装,覆盖安装即可\n\n> cody 似乎也不错\n\n> git commit 搜索 tig + linux \n\nios 的通知真行, 我微信都聊完天了, 锁屏后又重新通知\n","type":"text/markdown","created":"20231014230830157","creator":"Lenovo","modified":"20231015040435910","modifier":"Lenovo","tags":"Journal"},{"title":"2023/10/16","text":"github 的 wiki 不支持全文搜索\n\ntw 的 .md .md.meta 要在同一个目录下","type":"text/markdown","created":"20231016095520390","creator":"Lenovo","modified":"20231016115008013","modifier":"Lenovo","tags":"Journal"},{"title":"2023/10/17","text":"用惯了命令行, 使用 GitHub Desktop 虽然操作很简单直观, 但是很多操作支持的很有限, 甚至不支持, 粒度不够细, 如果想要复杂操作,还是得 <$iconify icon=\"logos:git\" /> + <$iconify icon=\"logos:terminal\" />","type":"text/markdown","created":"20231017115557891","creator":"Lenovo","modified":"20231017115925370","modifier":"Lenovo","tags":"Journal"},{"title":"2023/10/19","text":"* 进步/进化\n\n其实 github 就自带双链(issue 区), 所以 github 才是最好的笔记软件\n\nTiddlyDesktop 其实 bug 有很多, 很严重的也有\n\n:::tip\n* google 有个创建快捷工具的方式, 即使网站不支持 pwa 也可以快速打开了\n* pwa 模式下, 删除条目不会退出全屏了.\n* 加上了 lint-md, 不管你的文件是否规范, 构建出来的网页一定是符合文件规范的, 终于不用手动加空格了\n* 在 tw 里面如果完成了 todo 事项, 相比于标记为 done, 我更喜欢直接删除这个事项(在没有任何记录价值的情况下)\n* 看到一个 fork 了 600 多个仓库的 github 用户, 全年 commit 几乎为零, 这是把 GitHub 当作网盘来用了吗? 这比 star 收藏为书签还要安全啊. 太狠了, 不怕看不过来, 就怕没有 fork 到自己那里去\n* 今天才发现, 浏览器字体设置的是小, 对一些响应式网站来说区别很大\n:::\n","type":"text/markdown","created":"20231019110745780","creator":"Lenovo","modified":"20231019122653458","modifier":"Lenovo","tags":"Journal"},{"title":"2023/10/24","text":"一个使用在线笔记产品的人，显然并不在乎是否能随时离线访问笔记，那挂几个小时自然也不是什么大问题。\n\n我很担心现在习惯用的：语雀，幕布，各种小而美，以后会不会各种小而没","type":"text/markdown","created":"20231024054224330","creator":"Lenovo","modified":"20231024054553971","modifier":"Lenovo","tags":"Journal"},{"title":"2023/10/25","text":"你帮过的人，不会帮你，除非是已经有意识的利益交换。帮过你的人，才总会帮你。人情是人情，钱是钱。不要混为一谈。\n\n* 如果你想要隐藏图片加载失败的样子， 可以加一个 `alt=\"\"`\n\n* windows 的四指切换桌面，改成三指舒服多了\n\n* 使用 es6 和使用 es6 项目差别挺大的\n\n* github issue 双向链接 bug, 只要出现在评论区， 即使这个评论删除， 被引用的仓库一直都可以看到， 只要这个 issue 还存在","type":"text/markdown","created":"20231024223609260","creator":"Lenovo","modified":"20231025133539637","modifier":"Lenovo","tags":"Journal"},{"title":"2023/10/27","text":"如何证明自己是 vim 用户, 我有一键 jk \n\n* 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决\n\n* 现在愈发感觉写代码屏幕太小, 不够用了","type":"text/markdown","created":"20231027051518645","creator":"Lenovo","modified":"20231027142553600","modifier":"Lenovo","tags":"Journal"},{"title":"2023/10/29","text":"插件更新时, 对应的插件依赖也会自动更新","type":"text/markdown","created":"20231029030751941","creator":"Lenovo","modified":"20231029031311523","modifier":"Lenovo","tags":"Journal"},{"title":"2023/11/03","text":"每个新项目都不要放过了解新技术的机会\n\n一定要有自己的事情, 即使再小","type":"text/markdown","created":"20231103132648217","creator":"Lenovo","modified":"20231103132728608","modifier":"Lenovo","tags":"Journal"},{"title":"2023/11/04","text":"做项目尤其不要进入自嗨模式，整天捣鼓 css ，界面够看就行。开发点实用的功能，给用户提供价值才是王道，否则我认为都是在浪费时间。除非你开展副业不是为了赚钱，而只是收到几句：博主你的网站做的真好看，你真棒","type":"text/markdown","created":"20231104034144560","creator":"Lenovo","modified":"20231104034147243","modifier":"Lenovo","tags":"Journal"},{"title":"2023/11/06","text":"果然写 nextjs, 大多数时间都在处理 rsc 问题(我没写过 pages, 直接学的 app router), 前期没有经验, 处理起来就很慢. 还是要学学别人怎么写的\n\n> 一般的处理方法, 都是将 client 的部分单独抽离出来写成一个组件, 然后嵌入 server, nextjs 允许 server nest client, 但是翻过来不可以, 但是现在似乎有 server action 了","type":"text/markdown","created":"20231106115740640","creator":"Lenovo","modified":"20231106120241156","modifier":"Lenovo","tags":"Journal"},{"title":"2023/11/07","text":"原来 在提交的时候加上 issue, 会直接自动关闭 issue, 看来相关的 github 小技巧还要再看看文档了\n\n* vercel 在上次 assign domain 问题后, 现在的 assign domain 都需要 queue 好久(还是 netlify 吧)\n\n\"omitted\" 的意思是被省略或被忽略的，通常用于描述某个事物中缺失的部分或者被遗漏的内容。在上下文中，“'force-cache' is the default, and can be omitted” 可以理解为 \"'force-cache' 是默认值，可以省略不写\"，也就是说，如果没有特殊需求，可以不指定'force-cache'这个选项，因为它已经是默认行为了。\n\n* ob 1.5 好像也要使用 cm6","type":"text/markdown","created":"20231106231405586","creator":"Lenovo","modified":"20231107021126780","modifier":"Lenovo","tags":"Journal"},{"title":"5.3.1-get-icontext","text":"```js\r\nconst getIcon = $tw.wiki.makeTranscludeWidget(\r\n    \"$:/core/images/download-button\",\r\n    {\r\n      document: $tw.fakeDocument,\r\n      parseAsInline: true,\r\n    }\r\n  );\r\n  var container = $tw.fakeDocument.createElement(\"div\");\r\n  getIcon.render(container, null);\r\n```","type":"text/markdown","created":"20230906145106063","creator":"oeyoews","modified":"20230906145122384","modifier":"oeyoews","tags":"TiddlyWiki"},{"title":"A_word_about_Bun_💬___Yarn","text":"I'm sure many of you are curious about our position regarding [Bun](https://bun.sh/), the product from Oven, the company behind Bun (we're going in cycles). It's so fast, is there any merits to using Yarn?我相信你们中的许多人都对我们对 Bun 的立场感到好奇，Bun 是 Oven 的产品，Bun 背后的公司（我们正在循环中）。这么快，用纱线有什么好处吗？\n\nFirst, we feel useful to point out that this sentence isn't particularly new. We heard the same (often from the same people) asking why use Yarn when npm/pnpm/whateverpm have all its features or outspeed it. Answering that is a little tough, because the premise is wrong: other package managers don't have its features[1](#fn-1-a24c5d)[,2](#fn-,2-a24c5d), and the speed differences are at best marginal. They are a good fight, but we believe Yarn ultimately has a unique position that no other package managers emulates today.首先，我们觉得有必要指出这句话并不是特别新。我们听到同样的人（通常来自同一个人）问为什么在 npm/pnpm/whateverpm 具有其所有功能或超过它时使用 Yarn。回答这个问题有点困难，因为前提是错误的：其他包管理器没有它的功能 [1](#fn-1-a24c5d) [,2](#fn-,2-a24c5d) ，速度差异充其量是微不足道的。这是一场精彩的战斗，但我们相信 Yarn 最终拥有今天其他包管理器无法模仿的独特地位。\n\nBun is an interesting case, though. It's definitely much faster[3](#fn-3-a24c5d). Can Yarn compete? We believe so.不过，Bun 是一个有趣的案例。它肯定快 [3](#fn-3-a24c5d) 得多.纱线能竞争吗？我们相信是这样。\n\nFirst, remember today's iteration of Yarn was developped over the course of two years by a team already experienced in package managers. Those tools are fickle beasts, and many edge cases loom around[4](#fn-4-a24c5d). Bun may be fast, but is it correct? That's something the community will have to figure out over time.首先，请记住，今天的 Yarn 迭代是由一个在包管理器方面已经经验丰富的团队在两年的时间里开发的。这些工具是善变的野兽，许多边缘情况若隐若现 [4](#fn-4-a24c5d) 。包子可能很快，但它是正确的吗？随着时间的推移，这是社区必须弄清楚的事情。\n\nBut stability isn't everything: the feature set is an important facet of what makes a tool appealing. The developer experience (which includes the user interface) is another. The governance yet another. Yarn stills fits its niche: a complete tool that empowers its users, advocates for good practices, isn't afraid to explore uncharted territories, and is protected from perverse corporate incentives.但稳定性并不是一切：功能集是使工具具有吸引力的一个重要方面。开发人员体验（包括用户界面）是另一个。治理又是另一个。Yarn 蒸馏器适合其利基市场：一个完整的工具，可以赋予用户权力，倡导良好实践，不怕探索未知领域，并免受不正当的企业激励。\n\nWith that said, I believe there's a couple of things we can learn from Bun. Yarn was always intended to be distributed as a unique JS file for extreme portability across Node.js supported architectures. With [Corepack](https://nodejs.org/api/corepack.html) now being the preferred install strategy, does it still matter? Should we experiment with native modules for future releases, that Corepack would transparently fetch as needed? Bun proved untapped performances could be exploited.话虽如此，我相信我们可以从 Bun 身上学到几件事。Yarn 一直打算作为唯一的 JS 文件分发，以便在 Node 支持的架构.js 具有极高的可移植性。随着 Corepack 现在是首选的安装策略，它仍然重要吗？我们是否应该在未来版本中尝试本机模块，以便 Corepack 根据需要透明地获取？Bun 证明了未开发的表演可以被利用。\n\nOf course it's not just a matter of being native - Oven's work follows [interesting code patterns](https://twitter.com/jarredsumner/status/1708650105828692054), and I'm curious how much of an impact they have on the resulting speed (at the cost of increased complexity, and making contributions harder).当然，这不仅仅是原生的问题 - Oven 的工作遵循有趣的代码模式，我很好奇它们对最终的速度有多大影响（代价是复杂性增加，并且使贡献更加困难）。\n\nI always fought against the idea that one package manager was enough for every single project out there, Yarn included. Our users are engineers: they have different requirements, different priorities, and different sensibilities. I found Yarn the appropriate tool for my projects, but I'm sure Zoltan is perfectly happy with pnpm and Microsoft with npm.我总是反对这样一种观点，即一个包管理器就足以满足每个项目的需求，包括 Yarn。我们的用户是工程师：他们有不同的要求、不同的优先级和不同的敏感性。我发现 Yarn 是适合我的项目的工具，但我确信 Zoltan 对 pnpm 非常满意，对 npm Microsoft 非常满意。\n\nWill Bun reach some of your hearts? More than likely. Will it be a replacement? I can't imagine that.包子会打动你的一些心吗？很有可能。会是替代品吗？我无法想象。\n","type":"text/markdown","created":"20231024060818780","creator":"太微搜藏","modified":"20231024060818780","modifier":"太微搜藏","tags":"剪藏","url":"https://yarnpkg.com/blog/bun"},{"title":"about-firefox","text":"IMO, firefox always have some wired question or bugs","type":"text/markdown","created":"20231001124707525","creator":"oeyoews","modified":"20231001124740565","modifier":"oeyoews","tags":"thoughts"},{"title":"about-gpt","text":"* 准确性会提高，但永远不会完美\r\n* 事情将会改变，但不会像人们所说的那样可怕。\r\n* 所有内容都是基于我的真实信念。你可以自己决定这些信念是否有偏见。\r\n* 增强，而不是替代\r\n* 在过去的 10 年里，很多复杂性已经从服务器转移到客户端。Monolithic Express 应用程序已经转变为无服务器功能的集合，而我们的前端已经从超链接数字文档发展为成熟的桌面质量应用程序。\r\n\r\n> <https://www.joshwcomeau.com/blog/the-end-of-frontend-development/>","type":"text/markdown","created":"20230409081221856","creator":"oeyoews","modified":"20230409081927512","modifier":"oeyoews","tags":""},{"title":"about-logo-design","text":"在设计 logo 时，以下是一些建议：\n\nLogo 设计需要具有亲近感和可爱感，而不是压迫感，是因为亲近感和可爱感可以更好地吸引人们的注意力和情感共鸣，从而增加品牌的吸引力和认可度。\n\n首先，亲近感和可爱感可以引发人们的积极情感，让人们感到愉悦、放松和愉快。这种积极情感与品牌相关联，使人们更容易对品牌产生好感和信任。相反，如果设计给人一种压迫感，会让人们感到不舒服和厌烦，从而降低对品牌的兴趣和信任。\n\n其次，亲近感和可爱感可以更好地与目标受众建立情感连接。大多数人对可爱和亲近的事物都有一种天生的喜好和亲近感，因为它们与童年、幸福和温暖等积极的记忆和情感联系在一起。通过利用这种情感连接，品牌可以更好地吸引目标受众的注意力，并激发他们的共鸣和情感参与。\n\n最后，亲近感和可爱感可以帮助品牌在市场竞争中脱颖而出。在当今竞争激烈的商业环境中，品牌需要通过各种方式来吸引人们的注意力和记忆力。一个充满亲近感和可爱感的 logo 设计可以在众多品牌中脱颖而出，让人们更容易记住和识别，从而增加品牌的曝光度和影响力。\n\n综上所述，亲近感和可爱感在 logo 设计中的重要性在于它们可以激发人们的积极情感、建立情感连接并增加品牌的吸引力和记忆度。这些因素都有助于提高品牌的认可度和市场竞争力。\n\n<hr>\n\n1. 简洁明了：一个好的 logo 应该是简洁明了的，能够一眼就能够理解和记住。避免使用过多的元素或复杂的设计，保持简单的形状和清晰的线条。\n\n2. 独特性：确保你的 logo 与竞争对手有所区别，要有独特性和独创性。避免使用过于普通或常见的图案和颜色，以免过于平庸和容易混淆。\n\n3. 可识别性：logo 设计应该具有高度的可识别性，能够在不同的大小和比例下仍然清晰可辨。避免使用过于细小的细节或字体，以确保 logo 在各种尺寸和媒介上都能够清晰可见。\n\n4. 色彩选择：选择适合品牌形象和目标受众的色彩。色彩对于 logo 的表达和情感共鸣非常重要，因此要选择能够与品牌价值观和风格相符的色彩。\n\n5. 字体选择：选择适合品牌风格和定位的字体。字体能够传达出不同的情感和氛围，因此要选择与品牌形象相符的字体，避免使用过于普通或难以辨识的字体。\n\n6. 可应用性：确保你的 logo 能够适应不同的应用场景和媒介，如网站、印刷品、广告等。在设计时考虑 logo 在不同背景和尺寸上的可用性，以确保它在各种情况下都能够保持清晰和可辨识。\n\n7. 反馈和测试：在设计完成后，寻求他人的反馈和意见。将设计展示给目标受众或专业设计师，听取他们的建议和意见，以进一步改进和优化你的 logo 设计。\n\n总之，一个好的 logo 应该是简洁、独特、可识别的，能够与品牌形象相符，并能适应不同的应用场景。通过仔细考虑设计元素和与他人的反馈，你可以创建一个能够有效传达品牌价值并引起人们兴趣的 logo。","type":"text/markdown","created":"20231012113836392","creator":"Lenovo","modified":"20231012113946925","modifier":"Lenovo","tags":"thoughts"},{"title":"about-relink","text":"tw 的 relink 会修改你不想要修改的文件，这个插件让我感到文件不受控制，并且我很少使用嵌入，并不需要这个插件","type":"text/markdown","created":"20231009130306917","creator":"Lenovo","modified":"20231009130315608","modifier":"Lenovo","tags":"markdown"},{"title":"about-unsplash-random","text":"* <https://www.reddit.com/r/unsplash/comments/s13x4h/what_happened_to_sourceunsplashcom/>\r\n\r\n* <https://unsplash.com/documentation#get-a-random-photo>\r\n\r\n<img src=\"https://source.unsplash.com/44x44/daily\">","type":"text/markdown","created":"20230409033111167","creator":"oeyoews","modified":"20230409035005203","modifier":"oeyoews","tags":""},{"title":"Abstruse_Goose___A_Walk_on_Mars","text":"{{||headerTemplate}}","type":"text/markdown","created":"20231030122554562","creator":"太微搜藏","modified":"20231030122637796","modifier":"Lenovo","tags":"剪藏","url":"https://abstrusegoose.com/446"},{"title":"act-test-your-actions","text":"> https://github.com/nektos/act","type":"text/markdown","created":"20230906085009350","creator":"oeyoews","modified":"20230918062350382","modifier":"oeyoews","tags":""},{"title":"add-animation-for-layout","text":"> maybe can add animation on switch different layout, such as from landing layout to home page layout","type":"text/markdown","created":"20230221114705784","creator":"oeyoews","modified":"20230331140107150","modifier":"oeyoews","publish":"public","tags":""},{"title":"add-copyright-footer","text":"知识产权保护：版权符号表示网站的内容、设计和代码受法律保护。它是对潜在侵权者的警告，如果其版权受到侵犯，网站所有者将采取法律行动。\r\n\r\n所有权：版权符号表明网站所有者是其网站内容的合法所有者。它有助于建立他们对知识产权的所有权和控制权。\r\n\r\n专业性：在网站页脚添加版权符号给人一种专业的印象。这表明网站所有者认真对待他们的内容和知识产权，并致力于保护它。\r\n\r\n法律要求：在某些国家/地区，向网站添加版权符号是一项法律要求。否则可能会导致法律后果。\r\n\r\n威慑力：版权符号对潜在的侵权者起到威慑作用。这表明网站所有者了解他们的权利并准备采取行动保护他们。","type":"text/markdown","created":"20230401114631890","creator":"oeyoews","modified":"20230401114642638","modifier":"oeyoews","tags":""},{"title":"add-transition-mode","text":"切换主题时晃眼的问题通常是由于主题颜色变化过程中没有进行过渡处理导致的。要解决这个问题，可以通过添加 CSS 过渡效果来实现平滑的主题切换。\r\n\r\n具体来说，在切换主题时，可以使用 JavaScript 动态向页面头部插入一个新的样式表，并在这个样式表中定义主题颜色的过渡效果。以下是一种可能的实现方式：\r\n\r\n```javascript\r\n(function () {\r\n  /*jslint node: true, browser: true */\r\n  /*global $tw: false */\r\n  'use strict';\r\n\r\n  const toggleTheme = () => {\r\n    // 切换主题的代码\r\n    const isDarkMode = true; // 假设当前为暗色模式\r\n\r\n    // 创建一个新的 <link> 元素，并设置其属性\r\n    const link = document.createElement('link');\r\n    link.setAttribute('rel', 'stylesheet');\r\n    link.setAttribute('href', isDarkMode ? '/themes/dark.css' : '/themes/light.css');\r\n\r\n    // 向页面头部插入这个新的 <link> 元素\r\n    const head = document.head || document.getElementsByTagName('head')[0];\r\n    head.appendChild(link);\r\n\r\n    // 定义主题颜色的过渡效果\r\n    const style = document.createElement('style');\r\n    style.type = 'text/css';\r\n    style.textContent = `\r\n      body {\r\n        transition: background-color 0.5s ease;\r\n      }\r\n    `;\r\n    head.appendChild(style);\r\n\r\n    // 等待过渡效果生效后删除这个样式表\r\n    setTimeout(() => head.removeChild(style), 500);\r\n  };\r\n\r\n  exports.toggleTheme = toggleTheme;\r\n})();\r\n```\r\n\r\n在此实现中，定义了一个名为 toggleTheme 的函数。当这个函数被调用时，将切换页面的主题颜色，并向页面头部插入一个新的样式表。在这个样式表中定义了一条过渡效果的 CSS 规则，使页面背景颜色的变化过程变得平滑。最后，通过定时器等待过渡效果生效后删除这个样式表。\r\n\r\n当用户切换主题时，只需要调用 toggleTheme 函数即可。同时，也可以将该函数添加到主题切换按钮的点击事件处理程序中，以便自动触发主题颜色的平滑过渡效果。","type":"text/markdown","created":"20230501034556843","creator":"oeyoews","modified":"20230501034704071","modifier":"oeyoews","tags":"Tips"},{"title":"addEventlistener-on-tw","text":"window.addEventListener ==> $tw.wiki.addEventListener\r\n\r\n`$tw.wiki.addEventListener` 和 `window.addEventListener` 都是 JavaScript 中添加事件监听器的方法，但它们的使用方式和作用域略有不同。\r\n\r\n首先，`$tw.wiki.addEventListener` 是 TiddlyWiki 5 中特有的方法，用于在 wiki 中注册事件监听器，并对事件进行处理。这个方法可以被应用程序或插件调用，以便它们能够根据需要拦截和处理 wiki 中发生的一些事件，例如修改、保存、删除等。它的具体用法类似于标准的 `addEventListener` 方法，但参数不完全相同。\r\n\r\n而 `window.addEventListener` 则是浏览器中常用的方法，用于向窗口对象（即 `window` 对象）注册事件监听器。通过在 window 上注册事件监听器，您可以捕捉浏览器的各种事件，如页面加载、鼠标点击、滚动等。这个方法被广泛用于创建交互式 Web 应用程序和网站。\r\n\r\n总之，`$tw.wiki.addEventListener` 和 `window.addEventListener` 的主要区别在于它们所作用的范围不同：前者针对的是 TiddlyWiki 5 实例中的事件，后者则是针对整个浏览器窗口的事件。\r\n\r\n`$tw.wiki.addEventListener` 和 `window.addEventListener` 的参数也有所不同。\r\n\r\n`$tw.wiki.addEventListener` 方法的语法如下：\r\n\r\n```javascript\r\n$tw.wiki.addEventListener(type, listener, useCapture);\r\n```\r\n\r\n其中：\r\n\r\n- `type`：必需。要注册的事件类型，例如 `\"change\"`、`\"keydown\"` 等。\r\n- `listener`：必需。要调用的函数或处理程序。这个函数会在事件被触发时执行，并且会接收一个事件对象作为唯一的参数。\r\n- `useCapture`：可选。布尔值，表示是否使用捕获模式。默认值为 `false`。\r\n\r\n而 `window.addEventListener` 方法的语法如下：\r\n\r\n```javascript\r\nwindow.addEventListener(type, listener [, options]);\r\n```\r\n\r\n其中：\r\n\r\n- `type`：必需。要注册的事件类型，例如 `\"load\"`、`\"click\"` 等。\r\n- `listener`：必需。要调用的函数或处理程序。这个函数会在事件被触发时执行，并且会接收一个事件对象作为唯一的参数。\r\n- `options`：可选。一个对象，包含以下属性：\r\n  - `capture`：布尔值，表示是否使用捕获模式。默认为 `false`。\r\n  - `once`：布尔值，表示是否只执行一次。默认为 `false`。\r\n  - `passive`：布尔值，表示是否禁止使用事件监听器中的 `preventDefault()` 方法。默认为 `false`。\r\n\r\n因此，可以看出 `$tw.wiki.addEventListener` 和 `window.addEventListener` 的参数用法有一些微妙的差别。两者均需要指定事件类型和事件处理程序，但 `window.addEventListener` 还可以传递选项参数。此外，`$tw.wiki.addEventListener` 的作用域是 TiddlyWiki 5 实例，而 `window.addEventListener` 的作用域是整个浏览器窗口。","type":"text/markdown","created":"20230521120243070","creator":"oeyoews","modified":"20230726045248434","modifier":"oeyoews"},{"title":"addTiddler-injs","text":"```js\r\n$tw.wiki.addTiddler(\r\n            new $tw.Tiddler({\r\n              title: \"$:/temp/oeyoews/notify\",\r\n              text: `Copied to clipboard: ${perflink}`,\r\n            })\r\n          );\r\n\t\t\t\t\r\n\r\n// or\r\n$tw.wiki.addTiddler({\r\n              title: \"$:/temp/oeyoews/notify\",\r\n              text: `Copied to clipboard: ${perflink}`,\r\n            });\r\n```","type":"text/markdown","created":"20230908050711522","creator":"oeyoews","modified":"20230908050754483","modifier":"oeyoews","tags":"Plugins"},{"title":"again-halo-again","text":"halo 使用 docker 的方式需要下载 mysql 8.0(大约 500M), 需要 java, 800M 内存, 还有 sh\r\n(都使用 docker 了, 但是依然依赖 java,)","type":"text/markdown","created":"20230913155959309","modified":"20230913160114531","tags":""},{"title":"ai-software","text":"* chatgpt\n* bard\n* claude\n\n* poe \n","type":"text/markdown","created":"20231011114609281","creator":"Lenovo","modified":"20231011114643365","modifier":"Lenovo","tags":"ai"},{"title":"AIGC","text":"AI Generated Content (AIGC，人工智能自动生成内容)，是继专业生产内容（PGC, Professional-generated Content）、用户生产内容（UGC, User-generated Content）之后的新型内容创作方式，可以在创意、表现力、迭代、传播、个性化等方面，充分发挥技术优势，打造新的数字内容生成与交互形态。随着科技的发展，AI 写作、AI 配乐、AI 视频生成、 AI 语音合成、以及近段时间火遍全网的 AI 绘画，都为创作领域带来一波热议, 只要简单输入几个关键词几秒钟之内一幅画作就能诞生。","type":"text/markdown","created":"20230316091404523","creator":"oeyoews","modified":"20230726045248439","modifier":"oeyoews"},{"title":"ajax-fetch-axios","text":"_Ajax、Fetch 和 Axios_ 都是用于在 Web 应用程序中进行异步数据请求和处理的技术。虽然它们都可以实现类似的功能，但它们之间也有很多区别。以下是这些技术的一些主要区别：\r\n\r\n- Ajax 是一个基于原生 XMLHttpRequest 对象的技术，用于发起 HTTP 请求并处理响应。它需要手动编写较多的代码来设置请求和处理响应，并且通常需要依赖回调函数来处理异步操作。\r\n- Fetch 是一个基于 Promise 的 API，用于通过 Fetch API 发起 HTTP 请求并处理响应。相比于原生的 Ajax 技术，Fetch API 更简洁、更易于使用，并且支持流式响应、跨站资源共享（CORS）等特性。\r\n- Axios 是一个开源的基于 Promise 的 HTTP 客户端库，可用于发送 HTTP 请求并处理响应。与 Fetch 不同，Axios 具有内置的请求取消、错误处理、拦截器、基于浏览器和 Node.js 环境的支持等特性。同时，Axios 也提供了对 Promise 和 async/await 的支持。\r\n\r\n**综上所述，Ajax 以及 Fetch 是 JavaScript 原生提供的异步请求技术，而 Axios 则是一个由第三方库封装的异步请求工具。在选择使用哪种技术时，需要根据实际需求和开发经验进行权衡和选择。**\r\n\r\n以下是使用 Ajax 发送 GET 请求并处理响应的示例代码：\r\n\r\n```javascript\r\n// 创建一个新的 XMLHttpRequest 对象\r\nconst xhr = new XMLHttpRequest();\r\n\r\n// 设置请求 URL 和方法\r\nxhr.open('GET', 'path/to/data.json');\r\n\r\n// 处理响应数据\r\nxhr.onload = function() {\r\n  if (xhr.status === 200) {\r\n    const data = JSON.parse(xhr.responseText);\r\n    console.log(data);\r\n  } else {\r\n    console.error('Request failed. Status code:', xhr.status);\r\n  }\r\n};\r\n\r\n// 发送请求\r\nxhr.send();\r\n```\r\n\r\n在上面的示例中，我们首先创建了一个新的 XMLHttpRequest 对象，并通过 `.open()` 方法设置请求的 URL 和方法。然后，我们使用 `.onload` 事件处理程序处理响应数据，并将其解析为 JSON 格式。最后，使用 `.send()` 方法发送请求。\r\n\r\n以下是使用 Fetch 发送 GET 请求并处理响应的示例代码：\r\n\r\n```javascript\r\nfetch('path/to/data.json')\r\n  .then(response => response.json())\r\n  .then(data => console.log(data))\r\n  .catch(error => console.error('Request failed:', error));\r\n```\r\n\r\n在上面的示例中，我们使用 `fetch()` 函数发送 GET 请求，并在 Promise 链中处理响应数据。如果请求成功，则将响应解析为 JSON 格式并打印到控制台上；如果请求失败，则捕获错误并打印到控制台上。\r\n\r\n以下是使用 Axios 发送 GET 请求并处理响应的示例代码：\r\n\r\n```javascript\r\naxios.get('path/to/data.json')\r\n  .then(response => console.log(response.data))\r\n  .catch(error => console.error('Request failed:', error));\r\n```\r\n\r\n在上面的示例中，我们使用 `axios.get()` 方法发送 GET 请求，并在 Promise 链中处理响应数据。如果请求成功，则将响应解析为 JSON 格式并打印到控制台上；如果请求失败，则捕获错误并打印到控制台上。\r\n\r\n需要注意的是，以上示例仅演示了如何使用 Ajax、Fetch 和 Axios 发送 GET 请求并处理响应。实际开发中，您可能需要使用其他 HTTP 方法（例如 POST、PUT 或 DELETE）来与服务器进行交互，并针对具体业务需求进行相关设置和处理。","type":"text/markdown","created":"20230517123356253","creator":"oeyoews","modified":"20230726045248439","modifier":"oeyoews","tags":"JavaScript"},{"title":"antd","text":"Ant Design 是一个基于 Ant Design 设计语言的 UI 库，提供了一套丰富的 React 组件和样式，可以帮助你快速构建美观、可重复使用的用户界面。\r\n\r\nAnt Design 设计语言是由蚂蚁金服推出的一套设计规范，旨在帮助开发者在多种场景下创建一致性的用户体验。Ant Design UI 库则是根据这个设计语言进行开发的，提供了一些常用组件，如按钮、表单、布局、列表和模态框等。这些组件都具有良好的可访问性，并支持响应式设计，适合用于开发 Web 和移动设备应用程序。\r\n\r\n除了基础组件外，Ant Design 还提供了一些高级组件和工具，如数据表格、图标、颜色选择器和国际化支持等。这些组件不仅易于使用，而且支持主题样式和自定义属性，使得开发者可以轻松地创建符合其品牌形象的 UI 组件。\r\n\r\nAnt Design 遵循 MIT 许可证，是一个完全开源的项目，并拥有活跃的社区支持。它已经成为 React 生态系统中最受欢迎的 UI 库之一，并在许多企业和组织中得到广泛的应用。","type":"text/markdown","created":"20230503090953036","creator":"oeyoews","modified":"20230503091006005","modifier":"oeyoews","tags":"React"},{"title":"Apache服务器","text":"Apache 服务器（全名为 Apache HTTP Server）是一个开源的、跨平台的 Web 服务器软件，是目前全球使用最广泛的 Web 服务器之一。它由 Apache 软件基金会开发和维护。\r\n\r\nApache 服务器的主要功能是提供对 Web 内容的传输。当用户在浏览器中输入一个网址时，浏览器会发送 HTTP 请求到服务器，然后服务器使用 Apache 软件来处理这些请求。Apache 可以将存储在服务器上的网页文件发送回用户的浏览器，从而显示出网页内容。\r\n\r\n除了传输静态网页文件，Apache 还支持动态内容生成。它可以与各种编程语言（如 PHP、Python、Perl 等）以及数据库系统（如 MySQL）集成，使得网站能够动态地生成内容，例如用户注册、登录、交互式表单等。\r\n\r\nApache 的可扩展性和灵活性使其成为许多网站和 Web 应用程序的首选服务器软件。它支持各种模块和插件，可以实现各种功能，如安全认证、SSL 加密、虚拟主机（多个网站共享一个服务器）、负载均衡等。\r\n\r\n总之，Apache 服务器是一款强大的 Web 服务器软件，它在互联网上扮演着极其重要的角色，为用户提供了访问和交互网络内容的基础设施。","type":"text/markdown","created":"20230828070733670","creator":"oeyoews","modified":"20230828070740697","modifier":"oeyoews","tags":""},{"title":"API","text":"NPM Package API，通常是指该库公开的应用程序接口（Application Programming Interface）。API 是库、框架或软件提供给开发者使用的一组方法、函数、类、对象等集合，用于进行特定的操作或访问特定的功能。\r\n\r\n一个库的 API 定义了开发者可以使用的公共接口，这些接口描述了可以调用的方法、函数或类的签名、参数、返回值以及可能的异常处理等信息。通过使用库的 API，开发者可以利用库提供的功能来构建应用程序、解决问题或实现特定的功能需求。\r\n\r\n通常，npm 库的 API 文档会提供详细的说明，包括库中可用的类、函数、方法、属性等的用法、参数、返回值以及示例代码。开发者可以参考 API 文档来了解库的功能和如何正确使用它们。\r\n\r\nAPI 文档对于开发者非常重要，它们提供了对库的理解和正确使用的指导，帮助开发者快速上手和开发出高质量的应用程序。一般来说，API 文档可以在库的官方网站、GitHub 页面、npm 文档等地方找到。","type":"text/markdown","created":"20230618153233486","creator":"oeyoews","modified":"20230726045248442","modifier":"oeyoews"},{"title":"appdata","text":"Appdata 目录默认情况下不显示, 需要开启显示隐藏的项目","type":"text/markdown","created":"20231009144717583","creator":"Lenovo","modified":"20231009144754355","modifier":"Lenovo","tags":"windows"},{"title":"append-appendchild","text":"在 JavaScript 中，`append` 和 `appendChild` 是用于向 DOM（文档对象模型）中添加新元素或节点的两个常用方法，它们有一些区别和不同的用途。\r\n\r\n1. `appendChild` 方法：\r\n   - `appendChild` 是 Node 对象的方法，用于将一个节点对象作为子节点插入到目标节点的最后一个子节点位置。\r\n   - 使用 `appendChild` 方法时，需要创建一个节点对象，然后将其添加到目标节点中。\r\n   - 示例代码：\r\n     ```javascript\r\n     const parent = document.getElementById('parent'); // 获取父节点\r\n     const child = document.createElement('div'); // 创建一个子节点（div）\r\n     parent.appendChild(child); // 将子节点添加到父节点中\r\n     ```\r\n\r\n2. `append` 方法：\r\n   - `append` 是 Element 对象的方法，用于在目标元素的末尾插入一组指定的节点对象或 DOM 字符串。\r\n   - 使用 `append` 方法时，可以直接传入一个或多个节点对象、DOM 字符串或其他可以转换为节点的对象。\r\n   - 示例代码：\r\n     ```javascript\r\n     const parent = document.getElementById('parent'); // 获取父节点\r\n     const child1 = document.createElement('div'); // 创建子节点1（div）\r\n     const child2 = document.createElement('span'); // 创建子节点2（span）\r\n     parent.append(child1, child2); // 将多个子节点添加到父节点中\r\n     ```\r\n\r\n对比：\r\n- `appendChild` 只能将一个节点对象作为子节点添加到目标节点中，需要先创建节点对象后再使用。\r\n- `append` 可以将一个或多个节点对象或 DOM 字符串添加到目标元素中，更加灵活方便，且支持链式操作。\r\n- 注意：`append` 是较新的方法，可能在一些旧版本的浏览器中不被支持，而 `appendChild` 是较旧的方法，具有更广泛的兼容性。\r\n\r\n根据具体的需求和浏览器兼容性要求，您可以选择适合的方法来向 DOM 中添加新的内容。","type":"text/markdown","created":"20230928021738777","creator":"oeyoews","modified":"20230928021808852","modifier":"oeyoews","tags":"JavaScript"},{"title":"apple-event","text":"https://codepen.io/jh3y/pen/gOZWKeM","type":"text/markdown","created":"20230913060222849","modified":"20230913060233313","tags":""},{"title":"arguments","text":"箭头函数确实不支持 `arguments` 对象。在传统的函数定义中，`arguments` 对象是一个类数组对象，包含了函数被调用时传递的所有参数。但是，在箭头函数中，没有自己的 `arguments` 对象。\r\n\r\n箭头函数的参数列表是固定的，无法通过 `arguments` 对象访问传递给函数的参数。相反，箭头函数可以通过使用剩余参数语法（`...args`）来接收任意数量的参数，并将它们作为数组访问。\r\n\r\n下面是一个示例，展示了箭头函数和传统函数在处理参数上的区别：\r\n\r\n```javascript\r\n// 传统函数\r\nfunction traditionalFunction() {\r\n  console.log(arguments); // 输出函数的参数列表\r\n}\r\n\r\ntraditionalFunction(1, 2, 3); // 输出 [1, 2, 3]\r\n\r\n// 箭头函数\r\nconst arrowFunction = (...args) => {\r\n  console.log(args); // 输出函数的参数列表作为数组\r\n};\r\n\r\narrowFunction(1, 2, 3); // 输出 [1, 2, 3]\r\n```\r\n\r\n所以，如果你需要在函数中使用 `arguments` 对象来访问参数列表，应该使用传统的函数定义而不是箭头函数。","type":"text/markdown","created":"20230625041340951","creator":"oeyoews","modified":"20230726045248442","modifier":"oeyoews"},{"title":"array-from","text":"`Array.from()` 是一个用于将类数组对象或可迭代对象（如字符串、Set、Map 等）转换为数组的方法。以下是如何使用 `Array.from()` 进行转换的示例：\n\n```javascript\n// 将字符串转换为数组\nconst str = \"Hello, World!\";\nconst arr = Array.from(str);\nconsole.log(arr); // 输出: ['H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', '!']\n\n// 将Set转换为数组\nconst mySet = new Set([1, 2, 3, 4, 5]);\nconst arrFromSet = Array.from(mySet);\nconsole.log(arrFromSet); // 输出: [1, 2, 3, 4, 5]\n\n// 将Map 转换为数组\nconst myMap = new Map([['a', 1], ['b', 2], ['c', 3]]);\nconst arrFromMap = Array.from(myMap);\nconsole.log(arrFromMap); // 输出: [['a', 1], ['b', 2], ['c', 3]]\n```\n\n你可以看到，`Array.from()` 能够将不同类型的可迭代对象转换为数组，并且你还可以提供一个可选的映射函数，用于对数组的每个元素进行转换。例如：\n\n```javascript\n// 使用映射函数将数字加倍\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = Array.from(numbers, x => x * 2);\nconsole.log(doubled); // 输出: [2, 4, 6, 8, 10]\n```\n\n这种方式可以在将类数组对象或其他可迭代对象转换为数组时非常方便。","type":"text/markdown","created":"20231020135810686","creator":"Lenovo","modified":"20231020135902249","modifier":"Lenovo","tags":"JavaScript"},{"title":"arrow-function","text":"箭头函数（Arrow Function）是 ES6 提出的一种新的函数语法，它可以更简洁地定义函数，并且不会改变 this 的指向。\r\n\r\n箭头函数的参数有以下几种形式：\r\n\r\n1. 无参数：如果函数没有参数，那么可以在括号中省略参数部分，如下所示：\r\n\r\n   ```javascript\r\n   const sayHello = () => {\r\n     console.log('Hello');\r\n   };\r\n   \r\n   sayHello(); // 输出 \"Hello\"\r\n   ```\r\n\r\n2. 单个参数：如果函数只有一个参数，则可以省略参数括号。例如：\r\n\r\n   ```javascript\r\n   const double = x => {\r\n     return x * 2;\r\n   };\r\n   \r\n   console.log(double(5)); // 输出 10\r\n   ```\r\n\r\n3. 多个参数：如果函数有多个参数，则需要使用圆括号将这些参数括起来。例如：\r\n\r\n   ```javascript\r\n   const add = (x, y) => {\r\n     return x + y;\r\n   };\r\n   \r\n   console.log(add(2, 3)); // 输出 5\r\n   ```\r\n\r\n注意事项：\r\n\r\n- 如果只有一个参数，也可以选择加上括号，如 `(x)` 或者 `(y)`，但是不允许只有右侧的括号，如 `x)`。\r\n- 如果没有参数或者有多个参数，就必须使用圆括号。\r\n- 如果函数体只有一条语句，可以省略花括号和 return 语句，例如：\r\n\r\n  ```javascript\r\n  const add = (x, y) => x + y;\r\n  \r\n  console.log(add(2, 3)); // 输出 5\r\n  ```\r\n\r\n- 如果函数体中包含多条语句，就必须使用花括号和 return 语句。","type":"text/markdown","created":"20230506060228915","creator":"oeyoews","modified":"20230506060244599","modifier":"oeyoews","tags":"JavaScript"},{"title":"arrow-function-brackets","text":"在箭头函数中使用大括号 `{}` 的有无会影响函数的行为。\r\n\r\n如果箭头函数体内只有一条语句，你可以选择省略大括号 `{}`。这种情况下，该语句的结果将自动成为箭头函数的返回值。例如：\r\n\r\n```javascript\r\nconst add = (a, b) => a + b;\r\nconsole.log(add(1, 2)); // 输出: 3\r\n```\r\n\r\n上述示例中，箭头函数 `add` 的函数体只有一条语句 `a + b`，因此可以省略大括号 `{}`。这样，函数会直接返回表达式 `a + b` 的结果。在调用 `add(1, 2)` 时，输出结果为 `3`。\r\n\r\n但是，如果箭头函数体内有多个语句，则需要使用大括号 `{}` 将这些语句包裹起来，并使用 `return` 关键字显式地返回一个值。例如：\r\n\r\n```javascript\r\nconst multiply = (a, b) => {\r\n  const result = a * b;\r\n  return result;\r\n};\r\nconsole.log(multiply(2, 3)); // 输出: 6\r\n```\r\n\r\n上述示例中，箭头函数 `multiply` 的函数体有两条语句：定义变量 `result` 和返回 `result`。这时就需要使用大括号 `{}` 将这两条语句包裹起来，并使用 `return` 关键字明确地返回 `result` 的值。在调用 `multiply(2, 3)` 时，输出结果为 `6`。\r\n\r\n因此，是否在箭头函数体内使用大括号 `{}` 取决于函数体中的语句数量和你是否需要显式地返回一个值。","type":"text/markdown","created":"20230724135425766","creator":"oeyoews","modified":"20230726045248443","modifier":"oeyoews","tags":"JavaScript"},{"title":"Article","text":"<$echarts $tiddler=\"addon/tagpie.js\" filter=\"[publish[article]]\"/>","type":"text/markdown","created":"20230501173226499","creator":"oeyoews","icon":"articles.png","modified":"20231011070615567","modifier":"Lenovo","page-icon":"fluent-emoji-flat:open-book","tags":""},{"title":"atom-css","text":"* Tailwindcss\r\n* Windicss\r\n* Unocss","type":"text/markdown","created":"20230316091909360","creator":"oeyoews","modified":"20230316091934909","modifier":"oeyoews","tags":""},{"title":"axios-http","text":"是的，axios 可以代替 fetch 进行网络请求。虽然 fetch 在现代浏览器中已经成为了原生 API，但是它的兼容性还不够完善，而且只能基于 Promise 来处理请求结果，使用起来相对比较麻烦。\r\n\r\naxios 是一个基于 Promise 的 HTTP 客户端库，提供了丰富的 API 和配置选项，可以使得请求的配置、管理和拦截变得更加方便和灵活。axios 支持多种类型的请求（如 GET、POST、PUT、DELETE 等），支持自定义头部、请求参数、请求体等配置，同时也支持请求的取消、错误处理和超时设置等特性。\r\n\r\n以下是使用 axios 发送 GET 请求的示例代码：\r\n\r\n```javascript\r\nimport axios from 'axios';\r\n\r\naxios.get('https://api.github.com/users/octocat')\r\n  .then(response => console.log(response.data))\r\n  .catch(error => console.error(error));\r\n```\r\n\r\n上面的代码通过 axios 发送了一个 GET 请求，并在请求成功后打印出响应数据。注意，在 axios 中，响应数据被封装在 response 对象的 data 属性中，我们需要通过 response.data 来获取响应数据。\r\n\r\n由于 axios 具有更加丰富的功能和更好的可扩展性，因此在实际开发中，我们通常会优先选择 axios 来进行网络请求。","type":"text/markdown","created":"20230503024601635","creator":"oeyoews","modified":"20230503024612621","modifier":"oeyoews","tags":"JavaScript"},{"title":"axios-test","text":"<https://jsonplaceholder.typicode.com/guide/>","type":"text/markdown","created":"20230503073409463","creator":"oeyoews","modified":"20230503073428878","modifier":"oeyoews","tags":""},{"title":"badge-imageio","text":"\\define badge(label:\"label\", message:\"message\")\r\n  <div class=\"inline-block bg-gray-400 px-2 py-1 text-xs font-semibold text-gray-900 m-0 mb-1 capitalize\">$label$</div>\r\n  <div class=\"inline-block bg-green-500 px-2 py-1 text-xs font-semibold text-white mb-1 mr-1 capitalize\">$message$</div>\r\n\\end\r\n\r\n<div class=\"flex items-center flex-wrap\">\r\n<<badge one two>>\r\n<<badge thr sec>>\r\n</div>","type":"text/markdown","created":"20230503070944322","creator":"oeyoews","modified":"20230503072902662","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"bind-01","text":"`call` 和 `apply` 方法只是在函数调用时临时绑定 `this` 值，并不会对函数本身产生永久的影响。如果我们需要永久地将一个函数绑定到一个对象上，可以使用 `bind` 方法。\r\n\r\n`bind` 方法返回一个新的函数，这个函数的 `this` 值被永久绑定到指定的对象上。当调用这个新函数时，它会在绑定的对象上下文中执行，而不是在全局上下文中执行。下面是一个简单的例子：\r\n\r\n```javascript\r\nconst obj = {\r\n  name: 'Alice',\r\n  sayName() {\r\n    console.log(this.name);\r\n  },\r\n};\r\n\r\nconst boundSayName = obj.sayName.bind(obj);\r\nboundSayName(); // 输出：Alice\r\n```\r\n\r\n在这个例子中，我们定义了一个对象 `obj`，它有一个 `sayName` 方法，用于输出对象的 `name` 属性。然后，我们使用 `bind` 方法将 `sayName` 方法绑定到 `obj` 对象上，并将返回的新函数保存在变量 `boundSayName` 中。最后，我们调用 `boundSayName` 函数，它会在 `obj` 对象的上下文中执行，输出 `Alice`。\r\n\r\n需要注意的是，`bind` 方法返回的是一个新函数，它和原函数是不同的函数实例。如果对原函数的修改不会影响到绑定后的新函数。此外，一旦使用 `bind` 绑定了函数和对象，就无法再使用 `call` 或 `apply` 方法来改变绑定的对象。","type":"text/markdown","created":"20230607042346710","creator":"oeyoews","modified":"20230726045248444","modifier":"oeyoews","tags":"JavaScript"},{"title":"blog-template","text":"<https://tailwindui.com/components/marketing/sections/blog-sections>","type":"text/markdown","created":"20230430084748727","creator":"oeyoews","modified":"20230430084803630","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"blur-focus-visibilitychange","text":"`visibilitychange` 事件与 `onblur` 和 `onfocus` 事件有不同的用途和触发条件：\r\n\r\n1. `visibilitychange` 事件：\r\n   - `visibilitychange` 事件是 HTML5 的一个事件，用于检测浏览器标签页或窗口的可见性状态。\r\n   - 当用户切换到其他标签页、最小化浏览器窗口或隐藏浏览器窗口时，会触发 `visibilitychange` 事件。\r\n   - 通过监听 `visibilitychange` 事件，你可以在浏览器标签页或窗口变得不可见时执行特定的操作，如暂停音频或视频播放，节省资源。\r\n\r\n2. `onblur` 和 `onfocus` 事件：\r\n   - `onblur` 和 `onfocus` 事件是针对特定的 DOM 元素（通常是表单元素或可获得焦点的元素）而言的。\r\n   - `onblur` 事件在元素失去焦点时触发，而 `onfocus` 事件在元素获得焦点时触发。\r\n   - 这些事件通常用于处理用户与页面上的特定元素的交互，例如验证表单输入或在输入框获取焦点时显示帮助文本。\r\n\r\n总结：\r\n- `visibilitychange` 事件用于监测整个浏览器窗口或标签页的可见性状态，用于全局的操作。\r\n- `onblur` 和 `onfocus` 事件用于处理特定 DOM 元素的焦点变化，通常用于改善用户交互体验和验证输入。","type":"text/markdown","created":"20230926061940157","creator":"oeyoews","modified":"20230926061958843","modifier":"oeyoews","tags":"JavaScript"},{"title":"blur-preview","text":"https://blurred.dev/","type":"text/markdown","created":"20230725050158222","creator":"oeyoews","modified":"20230726045248446","modifier":"oeyoews"},{"title":"boardmix","text":"boardmix.cn","type":"text/markdown","created":"20230423041203286","creator":"oeyoews","modified":"20230423041221846","modifier":"oeyoews","tags":"App"},{"title":"border-outline","text":"\"Border\" 和 \"outline\" 都是与图形和元素的外观样式相关的术语，它们在网页设计和 CSS 中经常使用。\n\n1. **边框 (Border)**:\n   - 边框是元素周围的线条或边界，用于定义元素的尺寸和形状。\n   - 在 CSS 中，您可以使用属性来控制元素的边框，如 `border-width`（边框宽度），`border-color`（边框颜色），和 `border-style`（边框样式）。\n   - 例如，要创建一个具有 2 像素宽、红色边框的元素，您可以使用以下 CSS 代码：\n     ```css\n     border: 2px solid red;\n     ```\n\n2. **轮廓 (Outline)**:\n   - 轮廓是元素周围的线条，通常用于强调元素或指示用户正在与哪个元素交互。\n   - 轮廓不影响元素的尺寸或布局，它是可见于元素外部的虚线。\n   - 在 CSS 中，您可以使用属性来定义元素的轮廓，如 `outline-width`（轮廓宽度），`outline-color`（轮廓颜色），和 `outline-style`（轮廓样式）。\n   - 例如，要创建一个具有 5 像素宽、蓝色虚线轮廓的元素，您可以使用以下 CSS 代码：\n     ```css\n     outline: 5px dotted blue;\n     ```\n\n总结：边框用于定义元素的尺寸和形状，而轮廓通常用于突出显示元素或指示焦点元素。它们都是网页设计中常用的样式属性。","type":"text/markdown","created":"20231021072345774","creator":"Lenovo","modified":"20231021072358886","modifier":"Lenovo","tags":"HTML"},{"title":"bower","text":"Bower 是一种 Web 前端资源依赖管理工具，它可以帮助我们方便地下载、安装和更新各种 JavaScript、CSS、图像等资源文件，并将这些文件统一放到一个指定的目录中，以便于代码引用。Bower 有以下几个特点：\r\n\r\n1. 简单易用：Bower 的命令行界面非常简洁，使用起来比较容易上手。通过 bower install 命令可以快速地下载和安装所需的依赖包。\r\n\r\n2. 集成性好：Bower 提供了很多插件和工具，可以与其他常用工具（如 Grunt、Gulp、Yeoman 等）进行集成，使得整个开发环境更加完善和便捷。\r\n\r\n3. 可配置性强：Bower 支持自定义配置文件（bower.json），可以在其中指定依赖包名称、版本号、下载地址、依赖关系等信息，同时还提供了许多配置选项，可以满足不同场景下的需求。\r\n\r\n4. 社区支持广泛：Bower 拥有一个庞大的开发者社区，有许多优秀的开源项目使用 Bower 作为 Web 前端资源管理工具。同时，Bower 还提供了丰富的文档和示例，方便用户学习和使用。\r\n\r\n虽然 Bower 曾经是 Web 前端开发中最流行的资源管理工具之一，但是随着 Node.js 的流行和前端构建工具的发展，Bower 逐渐被替代。现在，许多前端开发者更倾向于使用 npm 或 yarn 来管理前端依赖包，以及使用 Webpack、Rollup 等构建工具来打包和压缩代码。","type":"text/markdown","created":"20230503031142073","creator":"oeyoews","modified":"20230503031152541","modifier":"oeyoews","tags":"JavaScript"},{"title":"box-model","text":"盒模型是 CSS 中的一个重要概念，它可以让我们更好地控制 HTML 元素的大小、位置和样式。盒模型由四部分组成：\r\n\r\n内容（content）：即元素的实际内容，例如文本、图片等。\r\n\r\n内边距（padding）：内容和边框之间的空白区域，可以用来控制元素的内部间距。\r\n\r\n边框（border）：围绕内容和内边距的线条，可以用来控制元素的边框样式、粗细和颜色。\r\n\r\n外边距（margin）：边框和相邻元素之间的空白区域，可以用来控制元素与其他元素之间的间距。\r\n\r\n这四部分依次包裹着元素，构成了一个矩形盒子。例如，下面的 CSS 代码可以为一个 div 元素设置盒模型：\r\n\r\n```css\r\ndiv {\r\n  width: 200px; /* 设置元素的宽度 */\r\n  height: 100px; /* 设置元素的高度 */\r\n  padding: 10px; /* 设置元素的内边距 */\r\n  border: 1px solid black; /* 设置元素的边框 */\r\n  margin: 20px; /* 设置元素的外边距 */\r\n}\r\n```\r\n在上面的代码中，我们为一个 div 元素设置了固定的宽度和高度，并分别设置了内边距、边框和外边距。这样，这个 div 元素就被包裹在一个矩形盒子中，我们可以通过调整这些属性来控制盒子的大小、位置和样式。","type":"text/markdown","created":"20230426012227569","creator":"oeyoews","modified":"20230426012319010","modifier":"oeyoews","tags":"CSS"},{"title":"box-shadow","text":"```css\r\n/* x 偏移量 | y 偏移量 | 阴影颜色 */\r\nbox-shadow: 60px -16px teal;\r\n\r\n/* x 偏移量 | y 偏移量 | 阴影模糊半径 | 阴影颜色 */\r\nbox-shadow: 10px 5px 5px black;\r\n\r\n/* x 偏移量 | y 偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */\r\nbox-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2);\r\n\r\n/* 插页 (阴影向内) | x 偏移量 | y 偏移量 | 阴影颜色 */\r\nbox-shadow: inset 5em 1em gold;\r\n\r\n/* 任意数量的阴影，以逗号分隔 */\r\nbox-shadow: 3px 3px red, -1em 0 0.4em olive;\r\n\r\n/* 全局关键字 */\r\nbox-shadow: inherit;\r\nbox-shadow: initial;\r\nbox-shadow: unset;\r\n```","type":"text/markdown","created":"20230424030203156","creator":"oeyoews","modified":"20230424030322219","modifier":"oeyoews","tags":""},{"title":"box-sizing","text":"`box-sizing: border-box` 是 CSS 中一个重要的属性值，它用于指定元素的盒模型的计算方式。通过设置 `border-box` 来改变盒子模型的默认行为，可以更方便地控制元素的尺寸和布局。\r\n\r\n在默认的盒子模型中，元素的宽度和高度仅包括内容区域（content），而不包括边框（border）、内边距（padding）和外边距（margin）。这意味着当您设置元素的宽度和高度时，实际显示的尺寸会因为边框和内边距的增加而变大。这对于一些布局需求可能会带来困扰。\r\n\r\n然而，使用 `box-sizing: border-box` 可以改变这种计算方式。设置了 `border-box` 后，元素的宽度和高度将包括边框和内边距，而内容区域的尺寸会自动调整，以使总体计算结果保持不变。换句话说，设置了 `border-box` 后，您设置的宽度和高度就是元素最终显示的尺寸，不会受到边框和内边距的影响。\r\n\r\n下面是一个示例，展示了使用 `box-sizing: border-box` 的效果：\r\n\r\n```html\r\n<style>\r\n  .box {\r\n    width: 200px;\r\n    height: 100px;\r\n    padding: 20px;\r\n    border: 5px solid black;\r\n    box-sizing: border-box;\r\n  }\r\n</style>\r\n\r\n<div class=\"box\">这是一个示例</div>\r\n```\r\n\r\n在上述示例中，一个具有 `box-sizing: border-box` 属性的 `.box` 元素被设置了宽度、高度、内边距和边框。由于使用了 `border-box`，最终显示的尺寸仍然是 200x100 像素，包括了边框和内边距。\r\n\r\n总结起来，`box-sizing: border-box` 的作用是改变元素盒模型的计算方式，使其更加灵活和直观。特别在响应式布局和网页设计中，使用 `border-box` 可以更方便地控制元素的尺寸和布局。","type":"text/markdown","created":"20230424025526316","creator":"oeyoews","modified":"20230928021232088","modifier":"oeyoews","tags":"CSS"},{"title":"brotli","text":"brotli compress ","type":"text/markdown","created":"20230410071428982","creator":"oeyoews","modified":"20230410071437863","modifier":"oeyoews","tags":""},{"title":"bug-free","text":"\"bug free\"是英文中的短语，意思是没有 bug 或错误。在软件开发和技术领域中，当我们说某个程序、应用或系统是\"bug free\"时，表示它没有任何功能上的问题或缺陷，可以正常运行并且没有任何错误。这是一个理想状态，但实际上很难达到完全没有 bug 的程度，因为复杂的软件系统总会存在一些潜在的问题。","type":"text/markdown","created":"20231009130356212","creator":"Lenovo","modified":"20231009130404338","modifier":"Lenovo","tags":""},{"title":"built-blog-with-react","text":"<https://www.joshwcomeau.com/blog/how-i-built-my-blog/>","type":"text/markdown","created":"20230401110030217","creator":"oeyoews","modified":"20230401110039616","modifier":"oeyoews","tags":""},{"title":"bullet-journal","text":"手帐（Bullet Journal）是一种笔记和日历管理系统，通常使用一个简单的笔记本来记录和组织个人任务、日历、日志、备忘录等信息。手帐最初由 Ryder Carroll 在 2013 年提出，它推崇自主性、跨越时空和简洁性的理念，旨在让你通过手动的方式与事物和自我联系，增强生活的品质。\r\n\r\n从形式上来说，手帐通常采用点阵笔记本，并可以根据自己的需要和兴趣设计各种布局、图表、色彩等元素。手帐具有可定制化和灵活性的特点，通过写下清单、提醒、目标等，不仅可以记录并跟踪重要事件，还可以反思过去、计划未来，提高自我效能和工作效率。\r\n\r\n手帐在过去几年内成为了一种全球性的流行文化，许多人将其视为一种艺术形式和生活态度，还出现了大量的手帐社群和相关产品。无论你是学生、职业人士，还是爱好者，手帐都可以成为你生活中的一部分，提供更好的组织和启示。","type":"text/markdown","created":"20231003035457508","creator":"oeyoews","modified":"20231003035509340","modifier":"oeyoews","tags":""},{"title":"bun-bug","text":":::warning \n<$iconify icon=\"devicon:bun\" /> bun 1.0 虽然能用, 但是 bug 很多, 几乎没有么生态\n:::\n\n* 全局使用 bun 安装 vercel\n\n`bun add --global vercel` 导致 vercel 安装了一个 4.8 的 typescript 在 ~/node_modules(bun 全局安装的目录在自动生成不理解, 为什么还有一个 ~/.bun/cache, 难道是为了全局自动安装吗, 是的, 不知道是不是又是硬链接)\n\ntsconfig.json 自动使用的是 5.x 的配置 modduleresolution 是 bundler, 4.x 需要使用 node, 或者 nodenext, neovim 会自动找到全局的 typescript 的 types, 导致解析报错, vscode 之所以不报错, 是因为自己安装了最新的 typescript\n\n","type":"text/markdown","created":"20230911070439531","creator":"Lenovo","modified":"20231021133306913","modifier":"Lenovo","tags":"tools"},{"title":"Bye-bye_useState_&_useEffect__Revolutionizing_React_Development!","text":"{{||headerTemplate}}\n\n![](https://miro.medium.com/v2/resize:fit:1050/1*lA-_v4GToxBmh1v7D7xk3A.jpeg)\n\n[![Emmanuel Odii](https://miro.medium.com/v2/resize:fill:66:66/1*urianex_H3N9EL-Sy8KEnA.jpeg)](https://medium.com/@emmanuelodii80?source=post_page-----d91f95891adb--------------------------------)\n\n**Thank you to our sponsors who keep my articles free:感谢我们的赞助商，他们让我的文章免费：**\n\nIf you’re building a SaaS, AI tool or any other web app, and you don’t have the all the time to set up boilerplate codes (e.g auth, DNS records, payment webhooks, components, animation, etc),如果您正在构建 SaaS、AI 工具或任何其他 Web 应用程序，并且您没有所有时间来设置样板代码（例如身份验证、DNS 记录、支付网络钩子、组件、动画等），\\\nThen, you need [ShipFast](https://shipfa.st/?via=76b1ktxw7bbln9yvdrh9). Shipfast saves 18+ hrs of development headache , it’s trusted by 300+ devs and it has a very great documentation.然后，您需要快速发货。Shipfast 节省了 18+ 小时的开发难题，它受到 300+ 开发人员的信任，并且它有一个非常好的文档。\n\nToday, I want to show you an alternative for the **useState** and **useEffect** hook in React. (*It reduces a lot of boilerplate codes)*今天，我想向您展示 React 中 useState 和 useEffect 钩子的替代方案。（它减少了很多样板代码）\n\nMany developers continue to use the useState and useEffect hooks to update states, but I have not been fond of this approach. The issue is that it causes the component to mount, remount, and unmount simultaneously, leading to unexpected behavior. As a result, when logging something into the console, you may see the result repeated three times.许多开发人员继续使用 useState 和 useEffect 钩子来更新状态，但我不喜欢这种方法。问题是它会导致组件同时装载、重新装载和卸载，从而导致意外行为。因此，在将某些内容登录到控制台时，您可能会看到结果重复三次。\n\n## Introducing the useLoaderData Hook:介绍 useLoaderData Hook\n\nThe `useLoaderData` hook is a custom hook in React that helps you load data into your component. It simplifies the process of fetching data from an API or performing any asynchronous operation.钩 `useLoaderData` 子是 React 中的一个自定义钩子，可帮助您将数据加载到组件中。它简化了从 API 获取数据或执行任何异步操作的过程。\n\n*When you use the **`useLoaderData`** hook, you provide it with a function that returns a Promise. This Promise represents an asynchronous operation that will fetch the data you need. Once the Promise resolves, the data becomes available to your component.*\n\nThe `useLoaderData` hook handles the loading state for you, so you don't need to manually track whether the data is still loading or if it has finished loading. It provides you with a convenient way to access the data and also handles any potential errors that might occur during the data loading process.`useLoaderData` 挂钩为您处理加载状态，因此您无需手动跟踪数据是否仍在加载或是否已完成加载。它为您提供了一种访问数据的便捷方法，还可以处理数据加载过程中可能发生的任何潜在错误。\n\nBy using the `useLoaderData` hook, you can keep your component code clean and organized, separating the data-loading logic from the rest of your component's responsibilities. It allows you to easily fetch and manage data in a more beginner-friendly way.通过使用 `useLoaderData` 挂钩，您可以保持组件代码干净有序，将数据加载逻辑与组件的其余职责分开。它允许您以更适合初学者的方式轻松获取和管理数据。\n\n## Why the useLoaderHook? 为什么使用 LoaderHook？\n\nThe useLoaderHook* from react-router helps achieve the same functionality* with minimal effort. These are some examples of why you should use it.\n\n* **Loading state management**: Loaders handle the loading state for you, providing a clear indication of when data is being fetched. This helps you manage loading spinners, progress indicators, or any other UI elements related to data loading.加载状态管理：加载程序为您处理加载状态，明确指示何时获取数据。这有助于管理加载微调器、进度指示器或与数据加载相关的任何其他 UI 元素。\n* **Error handling**: Loaders often include error handling mechanisms, allowing you to handle and display errors that occur during the data loading process. They provide a standardized way to handle errors, making it easier to implement consistent error handling across your application.错误处理：加载程序通常包括错误处理机制，允许您处理和显示数据加载过程中发生的错误。它们提供了一种标准化的错误处理方法，可以更轻松地在整个应用程序中实现一致的错误处理。\n* **Separation of concerns**: Loaders allow you to separate the data loading logic from other aspects of your component. This promotes better code organization and maintainability, as you can focus on specific responsibilities without mixing them.关注点分离：加载程序允许您将数据加载逻辑与组件的其他方面分开。这促进了更好的代码组织和可维护性，因为您可以专注于特定职责，而无需混合它们。\n\nAnd lots more. 等等。\n\n## Let’s see How This Works.让我们看看这是如何工作的\n\nIt’s assumed that you have a good knowledge of how react-router 6 works. If you don’t, Feel free to check out the docs [here](https://reactrouter.com/en/main)假设你对 react-router 6 的工作原理有很好的了解。如果您不这样做，请随时在此处查看文档\n\nFirstly, we have to set up the routing system in our application to work with the Loader API. Before now, we have been using the BrowserRouter setup to handle the various routes for our application.首先，我们必须在应用程序中设置路由系统以使用加载器 API。在此之前，我们一直在使用 BrowserRouter 设置来处理应用程序的各种路由。\\\nLet’s spend a little time talking about this.让我们花一点时间谈谈这个。\n\n```plain\nimport { BrowserRouter, Routes, Route, Outlet } from \"react-router-dom\"\nimport HomeComponent from \"./home\"\nimport AboutCompoent from \"./about\"\nfunction App () {\n    <BrowserRouter>\n        <Routes>\n            <Route path='/' element={<Outlet />}>\n                <Route index element={<HomeComponent /> } />\n                <Route path='about' element={<AboutComponent/> } />\n            </Route>\n        </Routes>\n    </BrowserRouter>\n};\nexport default App;\n```\n\nHere, we have set up a routing system traditionally using those imports from react-router.在这里，我们建立了一个路由系统，传统上使用从 react-router 导入的路由系统。\\\nThink for a second about what’s happening.想一想正在发生的事情。\n\nWell. The BrowserRouter from react-router creates an array of object from the `Routes` children. The snippet below provides a clear illustration of how this is working.井。来自 react-router 的 BrowserRouter 从 `Routes` 子对象创建一个对象数组。下面的代码片段清楚地说明了它是如何工作的。\n\n```plain\nBrowserRouter([\n{\n    path: '/',\n    element: <HomeComponent />,\n    children: []\n},\n{\n    path: '/about',\n    element: <AboutComponent/>,\n    children: []\n}\n])\n```\n\nIf they were to be a nested route, then it appends the children’s route to the children’s key in the parent route.如果它们是嵌套路由，则会将子路由附加到父路由中的子路由。\\\nYes, That’s how it keeps being **recursive.**是的，这就是它保持递归的方式。\n\nHowever, this method can’t be used to use the **loaderData** hook. We have to do a bit of refactoring. Don’t panic, It’s a bit similar to this. I highly recommend you check out the react-router docs for more information.但是，此方法不能用于使用 loaderData 挂钩。我们必须做一些重构。不要惊慌，它有点类似于这个。我强烈建议您查看 反应路由器文档 了解更多信息。\n\n```plain\nimport { \ncreateBrowserRouter,\ncreateRoutesFromElements,\nRouterProvider,\nRoute, \nOutlet\n } from \"react-router-dom\"\n\nimport HomeComponent from \"./home\"\nimport AboutComponent from \"./about\"\n\nfunction App() {\n    const browserRoutes = createBrowserRouter(createRoutesFromElements(\n       <Route path='/' element={<Outlet />}>\n                <Route index element={<HomeComponent /> } />\n                <Route path='about' element={<AboutComponent /> } />\n        </Route>\n    ))\n\n     return (\n        <RouterProvider router={browserRoutes} />\n    );\n}\n```\n\nI have imported `createBrowserRouter`, `createRoutesFromElement`, `RouterProvider`.我已经导入 `createBrowserRouter` 了 、 、 `createRoutesFromElement` `RouterProvider` 。\\\nThen, initialize a variable named `browserRoutes` to serve as that object that should be rendered. Noticed that I called the `createRoutesFromElements` function inside of the `createBrowserRouter` function. This was because I want to parse or convert the Routes to an object and the `createRoutesFromElements` as the name implies can help me do that. Then lastly the `RouterProvider` was returned with the value of the new `browserRouter`. Let's take a look at what we would have done without using the createRoutesFromElements function.然后，初始化一个名为 `browserRoutes` 作为应呈现的对象的变量。注意到我在函数内部调用了 `createRoutesFromElements` `createBrowserRouter` 函数。这是因为我想解析或将路由转换为对象，顾名思义 `createRoutesFromElements` 可以帮助我做到这一点。然后最后返回新的 `RouterProvider` `browserRouter` .让我们来看看如果不使用 createRoutesFromElements 函数，我们会做什么。\n\n```plain\ncreateBrowserRouter([\n{\n    path: '/',\n    element: <HomeComponent />,\n    children: []\n},\n{\n    path: '/about',\n    element: <AboutComponent/>,\n    children: []\n}])\n```\n\nI am not a big fan of this as your route can even go nested and at some point, this becomes confusing. You should keep things very simple.我不是这个的忠实粉丝，因为你的路线甚至可以嵌套，在某些时候，这变得令人困惑。你应该让事情变得非常简单。\n\n## Exploring the Loader functions:探索加载器功能\n\nAs we now have a bit of an understanding of how we can set up our application to use the Loader API, let’s see how we can use the API.由于我们现在对如何设置应用程序以使用 Loader API 有了一定的了解，让我们看看如何使用 API。\n\nSay you intend to fetch data from an endpoint andto be displayed on the `homeComponent`. What most developers would do is: initialize a state and update the state in the **useEffect **hook. The snippet below provides a clear illustration of what I am talking about.假设您打算从端点获取数据并显示在 . `homeComponent` 大多数开发人员会做的是：初始化一个状态并在 useEffect 钩子中更新状态。下面的片段清楚地说明了我在说什么。\n\n```plain\nimport { useState } from 'react'\n\nconst HomeComponent = () => {\n    const [data, setData] = useState([]);\n\n        useEffect(async () => {\n        const request = await fetch('http://localhost:3004/file');\n         if(!request.ok) throw new Error('Failed to fetch data')\n        const item= await request.json()\n        setData(item)  \n    }, [])\n\n    return (\n        <section>\n            { data.length > 0 ? data.map((foundData) => (\n                    <div key={foundData.id}>\n                        <strong>{foundData.name}</strong>\n                     </div>\n                 )) : <p>Data currently unavailable</p>}\n        </section>\n    )\n}\nexport default HomeComponent\n```\n\nThis is a tonne of lines as we might want to simplify this a bit and maybe reuse the same function.这是一吨行，因为我们可能希望简化一点，并可能重用相同的功能。\n\nTo use **Loaders**, you have to define a **loader **function. Loader functions are like **Custom Hooks**.要使用加载器，您必须定义一个加载器函数。加载器函数类似于自定义钩子。\\\nBesides, the naming convention of the function doesn’t matter as you can call it anything. In the code snippet below, I will create a basic loader function that fetches data from an API like I showed in the snipppet above 此外，函数的命名约定并不重要，因为您可以称呼它为任何东西。在下面的代码片段中，我将创建一个基本的加载器函数，该函数从 API 获取数据，如我在上面的截图中显示的\n\n```plain\nexport async function LoaderFunction () {\n    const request = await fetch('http://localhost:3004/file');\n    if (!request.ok) throw new Error ('Failed to fetch item')\n    const item = await  response.json();\n    return item;\n};\n```\n\nNow, we have to import the loader function to component where our routes are being handled. After setting up your route system using the `createBrowserRouter` and `createRouteFromElements` you should have access to a prop called `loader`. There you should pass in the `LoaderFunction` you created as the value.现在，我们必须将加载器函数导入到处理路由的组件中。使用 `createBrowserRouter` 和 `createRouteFromElements` 设置路由系统后，您应该可以访问名为 `loader` 的道具。在那里，您应该传入 `LoaderFunction` 您创建的值。\\\nIn the code snippet below provides a clear illustration of this.在下面的代码片段中提供了对此的清晰说明。\n\n```plain\nimport { \ncreateBrowserRouter,\ncreateRoutesFromElements,\nRouterProvider,\nRoute, \nOutlet\n } from \"react-router-dom\"\nimport HomeComponent from \"./home\"\nimport AboutComponent from \"./about\"\nimport { LoaderFunction as HomeLoader} from \"./loader\"\n\nfunction App() {\n    const browserRoutes = createBrowserRouter(createRoutesFromElements(\n       <Route path='/' element={<Outlet />}>\n                <Route index element={<HomeComponent /> }\n                     loader={HomeLoader}/>\n                <Route path='about' element={<AboutComponent /> } />\n        </Route>\n    ))\n\n     return (\n        <RouterProvider router={browserRoutes} />\n    );\n}\n```\n\nAfter that, We can access the data returned by the loader function using the **useLoaderData **Hook from react-router in the HomeComponent.之后，我们可以使用 useLoaderData Hook 从 HomeComponent 中的 react-router 访问加载器函数返回的数据。\\\nThe code snippet below best explains what just read.下面的代码片段最好地解释了刚刚阅读的内容。\n\n```plain\nimport { useLoaderData } from \"react-router-dom\"\n\nconst HomeComponent = () => {\n    const data = useLoaderData();\n\n    return (\n        <section>\n            {data.map((foundData) => (\n                    <div key={foundData.id}>\n                         <strong>{foundData.name}</strong> \n                    </div> \n            ))}\n        </section>\n    )\n}\nexport default HomeComponent\n```\n\n**Wow! 😲.. 哇！😲..**\\\nNow see how we have just cleaned up the HomeComponent :)现在看看我们刚刚如何清理主页组件:)\\\nNoticed we got rid of the guard clause that checks if the data is null.请注意，我们删除了检查数据是否为空的 guard 子句。\\\nThis is because react-router makes it load the data as soon as the url/path is active. So, it Makes the necessary requests even before the **Component is Mounted**. Yes!这是因为 react-router 让它在 url/path 处于活动状态时立即加载数据。因此，它甚至在挂载组件之前就发出了必要的请求。是的！\n\nWe are only making provisions for the happy path. What if we pass a non-existing endpoint? If that’s the case, don’t panic as react-router also allow us to pass components to another prop called `errorElement` .我们只是在为快乐的道路做准备。如果我们传递一个不存在的端点怎么办？如果是这种情况，请不要惊慌，因为 react-router 还允许我们将组件传递给另一个名为 `errorElement` .\\\nThis is specifically for Errors just as we use `ErrorBoundaries`. Let's see how this works in the snippet below 这是专门针对错误的，就像我们使用 `ErrorBoundaries` .让我们在下面的代码片段中看看它是如何工作的\n\n```plain\nimport { \ncreateBrowserRouter,\ncreateRoutesFromElements,\nRouterProvider,\nRoute, \nOutlet\n } from \"react-router-dom\"\nimport HomeComponent from \"./home\"\nimport AboutComponent from \"./about\"\nimport { LoaderFunction as HomeLoader} from \"./loader\"\n\nfunction App() {\n    const browserRoutes = createBrowserRouter(createRoutesFromElements(\n       <Route path='/' element={<Outlet />}>\n                <Route index element={<HomeComponent /> }\n                    loader={HomeLoader} errorElement={<h1>An Error occured</h1>}/>\n                <Route path='about' element={<AboutComponent /> } />\n        </Route>\n    ))\n\n     return (\n        <RouterProvider router={browserRoutes} />\n    );\n}\n```\n\nI have just used a header tag to show the error. It is advisable you use a Component so that you can also get access to the `useRouteError` Hook. I'd show how to use the useRouteError Hook in one of my upcoming blog posts. If you're keen to learn about it, Kindly use this [link](https://reactrouter.com/en/main/hooks/use-route-error).我刚刚使用标题标签来显示错误。建议您使用组件，以便您也可以访问 `useRouteError` 钩子。我将在我即将发布的一篇博客文章中展示如何使用 useRouteError Hook。如果您想了解它，请使用此链接。\\\nSince it pre-fetches the data before mounting the component, the loading state becomes irrelevant as it might either get the data or return the error message the you pass as a value to the **errorElement **prop.由于它在挂载组件之前预取数据，因此加载状态变得无关紧要，因为它可能会获取数据或返回错误消息，您将作为值传递给 errorElement 属性。\n\nThat’s all of the basics you need to know about making requests using the **Data Layer API**这就是您需要了解的有关使用数据层 API 发出请求的所有基础知识\n\nIf you found this helpful, please consider following me on [**Twitter**](https://twitter.com/devodii_), reacting to this post, leaving a comment, or support me by buying me a coffee through this [**link**](https://www.buymeacoffee.com/emmanuelod5).如果您觉得这有帮助，请考虑在 Twitter 上关注我，对此帖子做出反应，发表评论，或通过此链接为我买咖啡来支持我。\n","type":"text/markdown","created":"20231016002704457","creator":"太微搜藏","modified":"20231018054635504","modifier":"Lenovo","tags":"剪藏","url":"https://medium.com/@emmanuelodii80/bye-bye-usestate-useeffect-revolutionizing-react-development-d91f95891adb"},{"title":"Cannot load from mysql.proc","text":"* <https://github.com/antares-sql/antares/issues/159>\r\n* <https://stackoverflow.com/questions/27918764/cannot-load-from-mysql-proc-the-table-is-probably-corrupted>\r\n* sudo mysql_upgrade -u root -p root --force","type":"text/markdown","created":"20230328075031564","creator":"oeyoews","modified":"20230328075135824","modifier":"oeyoews","tags":""},{"title":"canvas-methods","text":"1. `toBlob()`: 这是一个 Canvas 元素的方法，它将当前 Canvas 中的图像数据转换为 Blob 对象。Blob 对象代表不可变、原始数据的片段，通常用于存储二进制数据或文件。`toBlob()`方法接受一个回调函数作为参数，该回调函数会在转换完成后被调用，并传递生成的 Blob 对象。示例代码如下：\r\n\r\n```javascript\r\ncanvas.toBlob(function(blob) {\r\n  // 在这里处理生成的Blob对象\r\n}, 'image/png');\r\n```\r\n\r\n2. `toDataURL()`: 这也是一个 Canvas 元素的方法，它将当前 Canvas 中的图像数据转换为一个表示图像的 Data URL 字符串。Data URL 是一种用于内联嵌入数据的 URL 格式，可以包含图像、文本等各种类型的数据。`toDataURL()`方法接受一个可选的参数，用于指定图像格式，默认为'image/png'。示例代码如下：\r\n\r\n```javascript\r\nvar dataURL = canvas.toDataURL('image/png');\r\n// 在这里使用生成的Data URL\r\n```\r\n\r\n3. `new Blob()`: 这是 JavaScript 中的构造函数，用于创建 Blob 对象。Blob 对象可以包含任意类型的数据，例如图像、音频、视频等。`new Blob()`接受一个数组作为参数，数组中的每个元素是要包含在 Blob 中的数据块。示例代码如下：\r\n\r\n```javascript\r\nvar data = ['Hello, world!'];\r\nvar blob = new Blob(data, { type: 'text/plain' });\r\n// 在这里使用生成的Blob对象\r\n```\r\n","type":"text/markdown","created":"20231003033436615","creator":"oeyoews","modified":"20231003033453883","modifier":"oeyoews","tags":"JavaScript"},{"title":"carbon-screenshot","text":"<https://carbon.now.sh/>","type":"text/markdown","created":"20230403005852015","creator":"oeyoews","modified":"20230403005902857","modifier":"oeyoews","tags":""},{"title":"card-example","text":"<div class=\"flex justify-center \">\n<div class=\"max-w-sm rounded overflow-hidden shadow-lg m-5\">\n        <img class=\"w-full\" src=\"https://place-hold.it/222x122\" alt=\"Laravel\">\n        <div class=\"px-6 py-4\">\n            <div class=\"font-bold text-xl mb-2\">PHP 全栈工程师指南</div>\n            <p class=\"text-gray-700 text-base\">\n                带你彻底掌握 Laravel + Vue.js，成为合格的 PHP 全栈工程师！\n            </p>\n        </div>\n        <div class=\"px-6 pb-4\">\n            <button class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\">\n                前往学习\n            </button>\n        </div>\n    </div>\n    </div>","type":"text/markdown","created":"20230410060539146","creator":"oeyoews","modified":"20231017134708376","modifier":"Lenovo","tags":""},{"title":"center","text":"<div\r\n      class=\"fixed left-1/2 top-1/2 bg-slate-200 rounded p-4 -translate-x-1/2 w-48 h-24 -translate-y-1/2\"\r\n    >\r\n      dmeo\r\n    </div>","type":"text/markdown","tags":"Tailwindcss"},{"title":"center-el","text":"```css\r\nbody {\r\n        min-height: 100vh;\r\n        display: grid;\r\n        place-items: center;\r\n      }\r\n```","type":"text/markdown","created":"20230913105829348","modified":"20230913105856511","tags":"HTML"},{"title":"cf","text":"但 ChatGPT 配备了 CloudFlare 防火墙，不仅会检测用户访问页面时的 IP, 还会每隔一段时间就断开用户（包含 ChatGPT PLUS 用户）的连接，","type":"text/markdown","created":"20230422041701714","creator":"oeyoews","modified":"20230422041717806","modifier":"oeyoews","tags":"ai"},{"title":"change-to-root","text":"```bash\r\nsu\r\n```","type":"text/markdown","created":"20231002161707859","creator":"oeyoews","modified":"20231002161731067","modifier":"oeyoews","tags":"gnome"},{"title":"chatbot-ui","text":"```html\r\n<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>ChatGPT UI</title>\r\n    <script src=\"https://cdn.tailwindcss.com\"></script>\r\n    <script>\r\n      tailwind.config = { corePlugins: { preflight: false } };\r\n    </script>\r\n  </head>\r\n  <body class=\"bg-gray-200 p-20\">\r\n    <div class=\"w-3/4 mx-auto bg-white rounded overflow-hidden shadow-lg\">\r\n      <div class=\"bg-blue-500 text-white py-4 px-6 font-bold text-xl\">\r\n        ChatGPT\r\n      </div>\r\n      <div class=\"px-4 py-6\">\r\n        <div id=\"messageContainer\" class=\"overflow-y-auto max-h-96\"></div>\r\n        <form onsubmit=\"sendMessage(event)\">\r\n          <div class=\"flex mt-4\">\r\n            <input\r\n              type=\"text\"\r\n              id=\"userInput\"\r\n              class=\"flex-1 bg-gray-100 rounded-l py-2 px-4 focus:outline-none border-none\"\r\n              placeholder=\"请输入消息\"\r\n            />\r\n            <button\r\n              type=\"submit\"\r\n              class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-r border-none\"\r\n            >\r\n              发送\r\n            </button>\r\n          </div>\r\n        </form>\r\n      </div>\r\n    </div>\r\n\r\n    <script>\r\n      function sendMessage(event) {\r\n        event.preventDefault();\r\n\r\n        var userInput = document.getElementById(\"userInput\");\r\n        var messageContainer = document.getElementById(\"messageContainer\");\r\n\r\n        // 获取用户输入的消息内容\r\n        var userMessage = userInput.value.trim();\r\n\r\n        if (userMessage !== \"\") {\r\n          // 创建并添加用户消息元素\r\n          var userMessageElement = document.createElement(\"div\");\r\n          userMessageElement.className =\r\n            \"py-2 px-4 rounded my-2 bg-blue-500 text-white\";\r\n          userMessageElement.textContent = userMessage;\r\n          messageContainer.appendChild(userMessageElement);\r\n\r\n          // 发送用户消息给后端进行处理，并获取对应的回复消息\r\n          var botReply = getBotReply(userMessage);\r\n\r\n          // 创建并添加机器人回复消息元素\r\n          var botMessageElement = document.createElement(\"div\");\r\n          botMessageElement.className =\r\n            \"py-2 px-4 rounded my-2 bg-gray-200 text-gray-700 inline-block\";\r\n          botMessageElement.textContent = botReply;\r\n          messageContainer.appendChild(botMessageElement);\r\n\r\n          // 滚动到消息容器的底部以显示最新的消息\r\n          messageContainer.scrollTop = messageContainer.scrollHeight;\r\n\r\n          // 清空用户输入框\r\n          userInput.value = \"\";\r\n        }\r\n      }\r\n\r\n      function getBotReply(userMessage) {\r\n        const predefinedAnswers = {\r\n          你好: \"你好，请问有什么可以帮助您的？\",\r\n          你叫什么名字: \"我是 ChatGPT，很高兴为您服务。\",\r\n          天气怎么样: \"很抱歉，我无法提供实时天气信息。\",\r\n        };\r\n\r\n        if (predefinedAnswers.hasOwnProperty(userMessage)) {\r\n          return predefinedAnswers[userMessage];\r\n        }\r\n\r\n        return \"🧊 不好意思,我还没有想好啦。\";\r\n      }\r\n    </script>\r\n  </body>\r\n</html>\r\n```","type":"text/markdown","created":"20230719113718915","creator":"oeyoews","modified":"20230726045248446","modifier":"oeyoews"},{"title":"chatgpt-bash","text":"```bash\r\n#!/bin/bash\r\n\r\nAPI_KEY=$OPENAI_API_KEY\r\n# Set the endpoint URL\r\nENDPOINT=\"https://api.openai.com/v1/engines/davinci-codex/completions\"\r\n# Set the prompt\r\nPROMPT=\"$1\"\r\n# Set the parameters\r\nPARAMETERS='{\"prompt\": \"'\"$PROMPT\"'\", \"max_tokens\": 60, \"temperature\": 0.5}'\r\n# Send the request to the API\r\nRESPONSE=$(curl -s -X POST -H \"Content-Type: application/json\" -H \"Authorization: Bearer $API_KEY\" -d \"$PARAMETERS\" $ENDPOINT)\r\n# Parse the response and print the generated text\r\necho $RESPONSE | jq -r '.choices[0].text'\r\n```","type":"text/markdown","created":"20230319100235717","creator":"oeyoews","modified":"20230319100258232","modifier":"oeyoews","tags":""},{"title":"chatgpt-plus-api","text":"https://chatgpt-plus.github.io/chatgpt-plus/","type":"text/markdown","created":"20230604052322315","creator":"oeyoews","modified":"20230726045248447","modifier":"oeyoews"},{"title":"check-binary-with-ldd","text":"```sh\r\nldd /usr/bin/xx\r\n```","type":"text/markdown","created":"20230329073521153","creator":"oeyoews","modified":"20230329073545251","modifier":"oeyoews","tags":""},{"title":"check-docker-log","text":"```plain\r\ndocker-compose logs\r\ndocker logs -f xxx\r\n```","type":"text/markdown","created":"20230915010917216","modified":"20230915010946416","tags":"docker"},{"title":"check-update-version","text":"```javascript\r\n// check tiddlywiki update\r\n\r\nversion = $tw.version;\r\n\r\nfetch('https://registry.npmjs.org/tiddlywiki', {\r\n  headers: { Accept: 'application/vnd.npm.install-v1+json' },\r\n})\r\n  .then(response => response.json())\r\n  .then(data => {\r\n    const latestVersion = data['dist-tags'].latest;\r\n    if (version != latestVersion) {\r\n      console.log(`A new version of TiddlyWiki is available: ${latestVersion}`);\r\n    }\r\n    console.log(`Your TiddlyWiki version is latest version: ${version}`);\r\n  })\r\n  .catch(error => console.error(error));\r\n```","type":"text/markdown","created":"20230511134635327","creator":"oeyoews","modified":"20230511134708201","modifier":"oeyoews","tags":""},{"title":"chrome-developer","text":"似乎现在的 app 商店平台都是收费制\n\n![img](https://i.imgur.com/Jdy9rPU.png)","type":"text/markdown","created":"20231016110625990","creator":"Lenovo","modified":"20231016110721416","modifier":"Lenovo","tags":""},{"title":"Chrome-slow3G","text":"* on network, you can choose slow 3G","type":"text/markdown","created":"20230429015004344","creator":"oeyoews","modified":"20230429015030258","modifier":"oeyoews","tags":"Tips"},{"title":"class-compare","text":"> [ref](https://www.bilibili.com/video/BV1UX4y1C7gQ/?spm_id_from=333.788&vd_source=d6afd7eedd9f9c940321c63f0a1539e3)\r\n\r\n```js\r\nconst Person = function (name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n};\r\nPerson.prototype.greeting = function () {\r\n  console.log(`Hi, my name is ${this.name}`);\r\n};\r\n\r\nclass P {\r\n  constructor(name, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n  }\r\n  greeting() {\r\n    console.log(`Hi, my name is ${this.name}`);\r\n  }\r\n}\r\n\r\nconst person1 = new Person(\"John\", 30);\r\nconsole.log(person1.age);\r\nperson1.greeting();\r\nconst p = new P(\"John\", 30);\r\nconsole.log(p.age);\r\np.greeting();\r\n```","type":"text/markdown","created":"20230524101743864","creator":"oeyoews","modified":"20230726045248447","modifier":"oeyoews","tags":"JavaScript"},{"title":"class-components","text":"类组件和 useState()钩子都用于处理 React 组件中的状态（state），但它们之间有一些区别。\r\n\r\n首先，类组件是使用 ES6 class 语法创建的，而 useState()是一个 React 钩子函数，用于函数式组件中定义状态。因此，使用类组件需要继承 React 的 Component 类，而使用 useState 需要在函数式组件中调用 useState 钩子。\r\n\r\n其次，类组件的状态是通过类成员变量（this.state）进行管理，并且必须在构造函数中初始化。例如：\r\n\r\n```jsx\r\nimport React, { Component } from 'react';\r\n\r\nclass MyComponent extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      name: 'World'\r\n    };\r\n  }\r\n  \r\n  handleClick = () => {\r\n    this.setState({ name: 'Alice' });\r\n  };\r\n  \r\n  render() {\r\n    return (\r\n      <div>\r\n        <h1>Hello, {this.state.name}!</h1>\r\n        <button onClick={this.handleClick}>Change Name</button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n上面的示例中，MyComponent 类的本地状态通过 this.state 进行管理，初始值为'World'。 handleClick()方法可以更新状态值，从而更改组件的呈现方式。\r\n\r\n而钩子 useState()则是通过声明式函数创建状态，如下所示：\r\n\r\n```jsx\r\nimport { useState } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const [name, setName] = useState('World');\r\n  \r\n  const handleClick = () => {\r\n    setName('Alice');\r\n  };\r\n  \r\n  return (\r\n    <div>\r\n      <h1>Hello, {name}!</h1>\r\n      <button onClick={handleClick}>Change Name</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n在上面的示例中，useState 钩子创建了一个名为 name 的状态，并赋初值'World'。setState()函数的等价函数是 setName()，可用于更新状态值。\r\n\r\n需要注意的是，useState()钩子可以多次使用来定义多个状态，并且可以在每次组件渲染时动态计算初始值。此外，钩子还可以使用 useEffect(), useContext()和 useReducer()等其他钩子来增强功能。\r\n\r\n综上所述，类组件与 useState()钩子都可以用于管理 React 组件中的状态，但使用方法不同，具有不同的特点和优势。开发者应该根据自己的需求和使用习惯选择合适的方法。","type":"text/markdown","created":"20230428083112941","creator":"oeyoews","description":"类组件和useState","modified":"20230502131102996","modifier":"oeyoews","tags":"React"},{"title":"classList-error","text":"`classList.add` 是 JavaScript 中用于向元素的 class 列表添加一个或多个类名的方法。通常情况下，它不会报错，但有一些情况下可能会出现问题：\n\n1. **参数为空或非字符串值**：如果你尝试将一个空的字符串或非字符串值传递给 `classList.add`，它不会报错，但不会有任何效果。\n\n    ```javascript\n    element.classList.add(\"\");  // 无效操作，不会报错\n    element.classList.add(123);  // 无效操作，不会报错\n    ```\n\n2. **DOM 未加载完全**：如果你尝试在文档的 DOM 结构尚未完全加载的时候调用 `classList.add`，它也可能会无效，因为元素尚不存在。\n\n    ```javascript\n    document.addEventListener(\"DOMContentLoaded\", function() {\n        var element = document.getElementById(\"myElement\");\n        element.classList.add(\"myClass\"); // 正确的使用方式\n    });\n    ```\n\n3. **不存在的元素**：如果你尝试将类名添加到不存在的元素上，也会出现问题。\n\n    ```javascript\n    var element = document.getElementById(\"nonExistentElement\");\n    element.classList.add(\"myClass\"); // 无效操作，不会报错\n    ```\n\n总的来说，`classList.add` 主要在处理 DOM 元素时使用，因此确保元素存在并且参数是有效的字符串值，通常可以避免出现错误。如果不符合这些条件，它可能会失败，但通常不会抛出异常。","type":"text/markdown","created":"20231017012552669","creator":"Lenovo","modified":"20231017012610588","modifier":"Lenovo","tags":"JavaScript TiddlyWiki"},{"title":"clean-pc","text":"> 今天突然发现 500G 的电脑竟然快满了\r\n\r\n* yay -Scc\r\n* yarn cache clean","type":"text/markdown","created":"20230402161915292","creator":"oeyoews","modified":"20230910080101016","modifier":"oeyoews"},{"title":"clear-data","text":"`ctrl shift delete`","type":"text/markdown","created":"20230415015351670","creator":"oeyoews","modified":"20230415015405082","modifier":"oeyoews","tags":""},{"title":"clipboard","text":"`clipboard.js` 使用了浏览器自带的复制 API，而不是通过 JavaScript 直接操作剪贴板，可以避免一些安全问题。\r\n\r\n在过去，网页通常使用 Flash 或 Java 等插件来实现复制操作，这些插件会通过 JavaScript 直接访问剪贴板，并将剪贴板中的内容复制到网页中。这种方式存在很多安全问题，例如可以通过篡改剪贴板中的内容来攻击用户或窃取用户的敏感信息。\r\n\r\n为了解决这些安全问题，浏览器引入了新的复制 API，例如 `document.execCommand('copy')` 和 `navigator.clipboard.writeText()` 等，可以让网页在不直接访问剪贴板的情况下实现复制操作。`clipboard.js` 利用了这些浏览器提供的 API，避免了直接访问剪贴板带来的安全风险。","type":"text/markdown","created":"20230610023144118","creator":"oeyoews","modified":"20230726045248448","modifier":"oeyoews"},{"title":"cloneNode","text":"cloneNode 是一个 DOM API 中的方法，用于复制一个节点并返回它的副本。该方法可以接受一个布尔值参数 deep，表示是否复制节点的子节点。如果 deep 为 true，则会同时复制该节点的所有子孙节点，否则只复制该节点本身。\r\n\r\n> 引用; 克隆","type":"text/markdown","created":"20230609141408826","creator":"oeyoews","modified":"20230726045248448","modifier":"oeyoews","tags":"JavaScript"},{"title":"cname-file","text":"* not all dns provider support cname file, such as aliyun","type":"text/markdown","created":"20230406100140026","creator":"oeyoews","modified":"20230406100201430","modifier":"oeyoews","tags":""},{"title":"codeberg","text":"<https://codeberg.org/issues>","type":"text/markdown","created":"20230307050646616","creator":"oeyoews","modified":"20230307050701998","modifier":"oeyoews","tags":""},{"title":"color-text","text":"## Wikitext\r\n\r\n@@.text-indigo-500\r\n@@.underline\r\n@@.decoration-wavy\r\n@@.decoration-rose-500\r\n@@.font-bold\r\nThis is a demo \r\n@@\r\n\r\n## Html\r\n\r\n<div class=\"text-indigo-500\r\nunderline\r\ndecoration-wavy\r\ndecoration-indigo-500 indent-4\r\n\" >\r\n\r\n<<.lorem>>\r\n\r\n</div>","type":"text/markdown","created":"20230407020820997","creator":"oeyoews","modified":"20230407021750733","modifier":"oeyoews","tags":""},{"title":"commit-times","text":"linux 命令行提交 commit 非常丝滑, window 整个速度极慢, commit 的频率大幅度降低\n\n:::tip\n如果一件事情很容易做到就会经常做, 反之亦然\n:::","type":"text/markdown","created":"20231009124755515","creator":"Lenovo","modified":"20231009124933622","modifier":"Lenovo","tags":""},{"title":"cookie-localstorage","text":"> <https://github.com/florian/cookie.js>\r\n\r\nCookie 和 localStorage 是在 Web 开发中常用的两种浏览器存储技术，它们之间有以下几个主要区别：\r\n\r\n1. Cookie 的大小通常受到浏览器和服务器的限制，不能超过 4KB。而 localStorage 则可以存储更大量级的数据，通常最大可存储 5MB 的数据。\r\n\r\n2. Cookie 会随着每个 HTTP 请求自动发送到服务器，包括图片、样式表等，这可能会影响性能。而 localStorage 只存储在客户端，不会随着每个请求发送到服务器，因此对于本地数据存储来说更适合。\r\n\r\n3. Cookie 可以设置过期时间，可以是一个确定的日期或者是一个持续时间。当到达过期时间后，浏览器会自动删除该 Cookie。而 localStorage 没有过期时间，除非手动删除，否则数据将一直存在。\r\n\r\n4. 因为 Cookie 存储在客户端，所以存在一些安全风险，如 CSRF（跨站请求伪造）攻击和 XSS（跨站脚本）攻击等问题。而 localStorage 只能通过 JavaScript 访问，其安全性相对较高。\r\n\r\n根据应用场景和需求的不同，选择使用 Cookie 还是 localStorage 也不同。如果需要与服务器交互并且存储小型数据，则使用 Cookie 可能更合适；而如果要在客户端存储大型数据或敏感数据，则使用 localStorage 可能更为安全。jkgg","type":"text/markdown","created":"20230507113407126","creator":"oeyoews","modified":"20230507113650198","modifier":"oeyoews","tags":"JavaScript"},{"title":"corepace-to-enable-pnpm","text":"```bash\n// https://pnpm.io/installation\ncorepack prepare pnpm@latest --activate\n// or npm i -g pnpm\n```","type":"text/markdown","created":"20231028005129232","creator":"Lenovo","modified":"20231028005301291","modifier":"Lenovo","tags":"tools"},{"title":"countTime","text":"console.time\r\nconsole.timeEnd","type":"text/markdown","created":"20230913054513716","modified":"20230913054531818","tags":"JavaScript"},{"title":"create-image","text":"`new Image()` 和 `createElement('img')` 都可以用来创建一个新的 `<img>` 元素，但它们的实现方式有所不同：\r\n\r\n- `new Image()` 是使用了 `Image` 构造函数来创建一个新的 `HTMLImageElement` 对象。这个对象具有所有 `<img>` 元素的特性和方法，例如 `src` 属性用于设置图像的源，`addEventListener` 方法用于添加事件监听器等。使用 `new Image()` 创建的对象是专门用于处理图像的元素。\r\n\r\n- `createElement('img')` 是使用 DOM 的 `createElement` 方法创建一个新的元素节点，类型为 `HTMLUnknownElement`。通过给这个元素节点设置标签名为 \"img\"，我们将创建一个 `<img>` 元素。与 `new Image()` 不同，使用 `createElement('img')` 创建的元素节点在初始时是一个普通的元素节点，不具备所有针对图像的特性和方法。\r\n\r\n综上所述，如果我们需要创建一个专门用于处理图像的元素，则推荐使用 `new Image()`。但如果只是简单地创建一个 `<img>` 元素节点，则可以使用 `createElement('img')`。","type":"text/markdown","created":"20230918151828478","modified":"20230918151843612","tags":"JavaScript"},{"title":"create-next-app","text":"```plain\r\nyarn create next-app --tailwind <project-folder-name>\r\nyarn next telemetry disable\r\n```\r\n\r\ncreate-next-app@latest 支持 tailwindcss","type":"text/markdown","created":"20230709140514063","creator":"oeyoews","modified":"20230726045248448","modifier":"oeyoews","tags":"React"},{"title":"CSS","text":"<$echarts $tiddler=\"addon/tagpie.js\" filter=\"[tag[CSS]]\"/>","type":"text/markdown","created":"20230502021043826","creator":"oeyoews","icon":"CSS.png","modified":"20231011071103934","modifier":"Lenovo","page-icon":"skill-icons:css","tags":""},{"title":"custom-tag-template","text":"plugins/aggregation/$__xp_ui_ViewTemplate_tag-handler.tid","type":"text/markdown","created":"20230202133057547","creator":"oeyoews","modified":"20230202133117240","modifier":"oeyoews","tags":""},{"title":"cwebp","text":"* use cwebp input.png -o output.png to compress png","type":"text/markdown","created":"20230408112703386","creator":"oeyoews","modified":"20230408112728838","modifier":"oeyoews","tags":""},{"title":"cypress","text":"cypress","type":"text/markdown","created":"20230429134826584","creator":"oeyoews","modified":"20230429134836382","modifier":"oeyoews","tags":""},{"title":"dark-macro-about-tailwindcss","text":"\\define code(mode)\r\n<html class=$mode$>\r\n<div class=\"bg-slate-200 p-2 rounded dark:bg-black dark:text-white \">\r\ndemo\r\n</div>\r\n</html>\r\n\\end\r\n\r\n<<code dark>>\r\n<<code>>","type":"text/markdown","created":"20230409114254827","creator":"oeyoews","modified":"20230501121945246","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"darkmode-switch","text":"```html\r\n<script src=\"https://cdn.tailwindcss.com\"></script>\r\n<script>\r\n  tailwind.config = { corePlugins: { preflight: false } };\r\n</script>\r\n<label for=\"modeToggle\" class=\"flex items-center cursor-pointer\">\r\n  <div class=\"relative\">\r\n    <!-- 非选中状态下的按钮 -->\r\n    <div class=\"w-10 h-4 bg-gray-400 rounded-full shadow-inner\"></div>\r\n    <!-- 滑动块 -->\r\n    <div\r\n      class=\"dot absolute w-6 h-6 bg-indigo-300 rounded-full shadow -left-1 -top-1 transition-transform duration-300 transform translate-x-0\"\r\n    ></div>\r\n  </div>\r\n  <!-- 文字标签 -->\r\n  <div class=\"ml-3 text-gray-700 font-medium\">日间模式</div>\r\n  <!-- 隐藏的复选框 -->\r\n  <input id=\"modeToggle\" type=\"checkbox\" class=\"hidden\" />\r\n</label>\r\n\r\n<script>\r\n  const modeToggle = document.getElementById(\"modeToggle\");\r\n  const dot = document.querySelector(\".dot\");\r\n\r\n  modeToggle.addEventListener(\"change\", function () {\r\n    if (modeToggle.checked) {\r\n      dot.style.transform = \"translateX(100%)\";\r\n    } else {\r\n      dot.style.transform = \"translateX(0)\";\r\n    }\r\n  });\r\n</script>\r\n```","type":"text/markdown","created":"20230930035240398","creator":"oeyoews","modified":"20230930035305675","modifier":"oeyoews","tags":"HTML Tailwindcss"},{"title":"data-docker","text":"docker 注意数据卷和挂载目录的区别","type":"text/markdown","created":"20230904032747021","creator":"oeyoews","modified":"20230904032808566","modifier":"oeyoews","tags":"docker"},{"title":"debounce-throttle-code","text":"<hr>\r\n\r\n# 防抖和节流的立即执行和非立即执行版本的代码\r\n\r\n## 防抖\r\n\r\n### 立即执行版本\r\n\r\n```js\r\nfunction debounceImmediate(fn, wait) {\r\n  let timer = null; // 定义计时器，初始值为null\r\n  return function (...args) {\r\n    // 返回一个函数，利用闭包来保存timer变量\r\n    if (timer) {\r\n      // 如果timer存在，则说明函数还在等待执行\r\n      clearTimeout(timer); // 清除计时器\r\n    } else {\r\n      // 如果timer不存在，则说明可以立即执行函数\r\n      fn.apply(this, args); // 执行函数，并将上下文和参数传递进去\r\n    }\r\n    timer = setTimeout(() => {\r\n      // 设置计时器，在规定时间后将timer设为null\r\n      timer = null;\r\n    }, wait);\r\n  };\r\n}\r\n```\r\n\r\n这个函数实现了立即执行一次函数，并在规定的时间内限制函数的调用次数。在函数被调用时，会判断计时器是否存在，如果存在则说明函数还在等待执行，此时需要清除计时器。如果计时器不存在，则说明可以立即执行函数，并将上下文和参数传递进去。在函数执行后，会设置一个计时器，在规定时间内将计时器设为 null，从而限制接下来的函数调用。这个函数也使用了闭包来保存计时器变量，从而实现了防抖的效果。\r\n\r\n### 非立即执行版本\r\n\r\n```javascript\r\nfunction debounce(fn, wait) {\r\n  let timer = null;\r\n  return function (...args) {\r\n    const context = this;\r\n    timer && clearTimeout(timer);\r\n    timer = setTimeout(() => {\r\n      fn.apply(context, args);\r\n    }, wait);\r\n  };\r\n}\r\n```\r\n\r\n## 节流\r\n\r\n### 立即执行版本\r\n\r\n```js\r\nfunction throttleImmediate(fn, wait) {\r\n  let timer = null; // 定义计时器，初始值为null\r\n  return function (...args) {\r\n    // 返回一个函数，利用闭包来保存timer变量\r\n    if (!timer) {\r\n      // 如果timer不存在，则说明可以立即执行函数\r\n      fn.apply(this, args); // 执行函数，并将上下文和参数传递进去\r\n      timer = setTimeout(() => {\r\n        // 设置计时器，在规定时间后将timer设为null\r\n        timer = null;\r\n      }, wait);\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n这个函数实现了立即执行一次函数，并在规定的时间内限制函数的调用次数。在函数被调用时，会判断计时器是否存在，如果不存在则说明可以立即执行函数。在函数执行后，会设置一个计时器，在规定时间内将计时器设为 null，从而限制接下来的函数调用。这个函数也使用了闭包来保存计时器变量，从而实现了节流的效果。\r\n\r\n### 非立即执行版本\r\n\r\n```javascript\r\nfunction throttle(fn, wait) {\r\n  let timer = null;\r\n  return function (...args) {\r\n    if (!timer) {\r\n      const context = this;\r\n      fn.apply(context, args);\r\n      timer = setTimeout(() => {\r\n        timer = null;\r\n      }, wait);\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n在这些代码中，立即执行版本的函数会在第一次触发时立即执行，而非立即执行版本的函数会在等待一定时间后执行。这两种函数都可以根据需要使用防抖或节流功能来限制函数的执行次数。\r\n\r\n> https://juejin.cn/post/7087286029551403015\r\n","type":"text/markdown","created":"20230605112003013","creator":"oeyoews","modified":"20230726045248449","modifier":"oeyoews","publish":"public","tags":"JavaScript"},{"title":"debounce-throttle2","text":"JavaScript 中的防抖（debounce）是一种常用的优化技术，它可以有效地降低高频事件触发时的资源消耗和性能问题。主要是因为以下几个原因：\r\n\r\n1. 防止高频触发事件导致的性能问题：例如，当用户连续快速输入搜索关键词时，每次输入都会触发一次搜索请求，这可能会导致浏览器出现卡顿或崩溃等问题。使用防抖技术可以延迟事件处理，从而避免过多的请求和计算工作。\r\n\r\n2. 减少不必要的网络请求：例如，当用户在短时间内多次点击提交按钮时，每次点击都会触发一次表单提交操作，这可能会导致服务器端出现重复的请求或者数据丢失等问题。使用防抖技术可以确保只有最后一次点击事件被执行，从而避免重复提交。\r\n\r\n3. 提高用户体验：通过合理使用防抖技术，可以让用户获得更加流畅的交互体验，同时也能够减少冗余的操作以及对系统资源的浪费。\r\n\r\n因此，在 JavaScript 开发中，通常会使用防抖技术来控制高频事件的触发，从而提高程序的性能和稳定性。常见的防抖实现方式包括基于定时器的简单防抖和基于时间戳的立即执行防抖等。\r\n\r\n防抖和节流都是常用的事件优化技术，它们可以避免高频事件触发导致的性能问题，但它们的实现方式和使用场景有所不同：\r\n\r\n1. 防抖（debounce）：指的是在事件被触发 n 秒后才执行回调函数（如果在这段时间内事件又被触发，则重新计时），主要应用于一些高频触发事件（如窗口缩放、搜索框输入等）。通过使用防抖，可以有效地减少事件处理的次数，从而提高程序的性能和稳定性。\r\n\r\n2. 节流（throttle）：指的是在 n 秒内最多只执行一次回调函数，主要应用于一些频率较高但处理逻辑简单的事件（如鼠标滚轮、页面滚动等）。通过使用节流，可以限制事件处理的频率，从而降低计算机资源的负担，并提高程序的响应速度。\r\n\r\n总体来说，防抖和节流都是为了优化事件处理效率而产生的技术。二者的选择取决于具体的场景需求，如果是针对高频触发事件，可以考虑使用防抖；如果是针对频率较高且处理逻辑简单的事件，则可以考虑使用节流。需要注意的是，在实际应用中，还需要根据具体情况来调整防抖和节流的时间参数，以达到最佳效果。","type":"text/markdown","created":"20230513120708785","creator":"oeyoews","modified":"20230513120745457","modifier":"oeyoews","tags":"JavaScript"},{"title":"declare-interface","text":"虽然`declare`和`interface`关键字都用于定义类型，但它们的作用和使用方式有所不同。\r\n\r\n`declare`关键字用于声明一个变量、函数、类或模块的类型，通常用于描述已经存在的 JavaScript 代码。它告诉 TypeScript 编译器，某个标识符的类型信息已经存在，无需再进行检查和分析。因此，`declare`关键字常用于解决 TypeScript 无法识别第三方 JavaScript 库或模块的类型问题。\r\n\r\n例如，可以使用`declare`关键字声明一个名为`$`的全局变量，使 TypeScript 能够正确地识别 jQuery 库：\r\n\r\n```typescript\r\ndeclare const $: {\r\n  (selector: string): any;\r\n};\r\n```\r\n\r\n`interface`关键字用于定义一个对象的类型和结构，通常用于描述应用程序中的数据。它定义了一个包含属性和方法的抽象类型，用于描述对象的形态。\r\n\r\n例如，可以使用`interface`关键字定义一个名为`Person`的接口，描述一个人的基本信息：\r\n\r\n```typescript\r\ninterface Person {\r\n  name: string;\r\n  age: number;\r\n  sayHello(): void;\r\n}\r\n```\r\n\r\n`interface`关键字还可以用于定义可索引类型、函数类型等，以便更精确地描述数据类型和结构。和`declare`关键字不同，`interface`关键字会在编译时生成相应的 JavaScript 代码。\r\n\r\n需要注意的是，`declare`和`interface`关键字都是 TypeScript 的语法特性，它们不会影响 JavaScript 的运行时行为。","type":"text/markdown","created":"20230509161846469","creator":"oeyoews","modified":"20230509161902669","modifier":"oeyoews","tags":"TypeScript"},{"title":"decorator","text":"装饰器函数是一种在 JavaScript 中常用的语法，它可以用来修改类、方法或属性的行为。装饰器函数通常被定义为一个函数，它接受一个类或函数作为参数，并返回一个新的类或函数。在应用装饰器函数时，我们可以使用 `@` 符号来注释一个类、方法或属性，例如：\r\n\r\n```javascript\r\n@decorator\r\nclass MyClass {\r\n  // ...\r\n}\r\n\r\nclass MyClass {\r\n  @decorator\r\n  myMethod() {\r\n    // ...\r\n  }\r\n}\r\n\r\nclass MyClass {\r\n  @decorator\r\n  myProperty = 123;\r\n}\r\n```\r\n\r\n装饰器函数可以用来实现很多功能，例如修改函数的参数、修改类的属性等等。需要注意的是，装饰器函数目前还不是 JavaScript 的标准语法，需要使用特定的工具来进行转换才能使用。","type":"text/markdown","created":"20230606093427215","creator":"oeyoews","modified":"20230726045248452","modifier":"oeyoews","tags":"JavaScript"},{"title":"deepl-tw-bug","text":"```plain\r\nvar errHeading = ( $tw.language == undefined ? \"Internal JavaScript Error\" : $tw.language.getString(\"InternalJavaScriptError/Title\") ),\r\n\t\tpromptMsg = ( $tw.language == undefined ? \"Well, this is embarrassing. It is recommended that you restart TiddlyWiki by refreshing your browser\" : $tw.language.getString(\"InternalJavaScriptError/Hint\") );\r\n\t// Log the error to the console\r\n\tconsole.error($tw.node ? \"\\x1b[1;31m\" + err + \"\\x1b[0m\" : err);\r\n```\r\n\t\r\n> 使用 deepl 浏览器扩展可能会导致频繁弹出 ResizeObserver loop limit exceeded 警告(猜测是整个扩展导致的问题)\t","type":"text/markdown","created":"20230317163217608","creator":"oeyoews","modified":"20230317163351954","modifier":"oeyoews","tags":""},{"title":"defaultProps","text":"虽然 defaultProps 是 React 中一种设置默认 props 值的方式，但是在 React 官方文档中并不推荐使用它。使用 defaultProps 可能会导致代码难以理解和维护，因为您必须跳到组件定义的另一个位置才能了解它的默认值。\r\n\r\n相反，React 官方文档建议使用 ES6 中的解构赋值来指定默认值，这样更直接、明确。以下是一个带有默认值的示例：\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\nfunction Button({ color = 'blue', label = 'Submit' }) {\r\n  return (\r\n    <button style={{ backgroundColor: color }}>\r\n      {label}\r\n    </button>\r\n  );\r\n}\r\n```\r\n\r\nexport default Button;\r\n在这个例子中，我们将 Button 组件的 props 对象进行了解构，并为 color 和 label 这两个属性定义了默认值。这样，当父组件调用 Button 组件时未提供相应属性值时会使用默认值。这种方法使得默认值更直接、明确，也更容易阅读和维护。\r\n\r\n总而言之，虽然 defaultProps 是一种设置默认 props 值的方式，但是并不是最佳实践，因为在某些情况下，它可能会使组件更难以理解和维护。React 建议使用 ES6 的解构赋值来指定默认值。","type":"text/markdown","created":"20230423073208284","creator":"oeyoews","modified":"20230423073256122","modifier":"oeyoews","tags":"React"},{"title":"delete-npm-pkg","text":"```bash\r\nnpm unpublish foo --force // 删除上传的npm包(如果有依赖问题,需要解决依赖问题)\r\n```","type":"text/markdown","created":"20230831112128115","creator":"oeyoews","modified":"20230831112343698","modifier":"oeyoews","tags":""},{"title":"delete-obj-attr","text":":::abstract\n今天才知道还有这种语法,我还是以为是 sql\n:::\n\n要从 JavaScript 对象中删除一个属性，可以使用`delete`运算符。这个运算符接受对象和要删除的属性作为操作数。以下是一个简单的示例：\n\n```javascript\nlet obj = {\n  name: 'John',\n  age: 30,\n  city: 'New York'\n};\n\nconsole.log(obj); // 输出 { name: 'John', age: 30, city: 'New York' }\n\ndelete obj.age;\n\nconsole.log(obj); // 输出 { name: 'John', city: 'New York' }\n```\n\n在上面的示例中，我们首先创建了一个名为`obj`的对象，并设置了三个属性：`name`、`age`和`city`。然后，我们使用`delete`运算符将`age`属性从对象中删除。最后，我们再次打印对象，发现`age`属性已经被移除。\n\n需要注意的是，`delete`运算符只能删除对象自身的属性，不能删除继承的属性或变量。另外，如果尝试删除一个不存在的属性，不会产生错误，而只是什么都不会发生。\n\n```javascript\ndelete obj.nonExistentProperty; // 不会产生错误，什么都不会发生\n```\n\n希望这可以帮助你理解如何从 JavaScript 对象中删除属性。","type":"text/markdown","created":"20231101015636027","creator":"Lenovo","modified":"20231101015734228","modifier":"Lenovo","tags":"JavaScript"},{"title":"delete-timestamp","text":"```py\r\nimport os\r\nimport re\r\nimport logging\r\nimport time\r\nfrom datetime import datetime\r\nfrom colorama import Fore, Style\r\nfrom halo import Halo\r\nfrom tqdm import tqdm\r\n\r\n\r\ndef delete_timestamp_lines_in_folder(folder_path):\r\n    # Initialize logging\r\n    logging.basicConfig(filename=\"delete_timestamp_lines.log\",\r\n                        level=logging.INFO, format=\"%(asctime)s - %(message)s\")\r\n\r\n    # Initialize counter\r\n    num_processed = 0\r\n\r\n    # Initialize progress bar\r\n    files = []\r\n    for dirpath, dirnames, filenames in os.walk(folder_path):\r\n        for filename in filenames:\r\n            if filename.endswith(\".tid\"):\r\n                files.append(os.path.join(dirpath, filename))\r\n    pbar = tqdm(files, desc=\"Processing files\", unit=\"file\")\r\n\r\n    # Record start time\r\n    start_time = time.time()\r\n\r\n    for file_path in pbar:\r\n        pbar.set_postfix(file=file_path)\r\n        with open(file_path, \"r+\") as f:\r\n            lines = f.readlines()\r\n            f.seek(0)\r\n            for line in lines:\r\n                words = line.split()\r\n                if len(words) >= 2 and not re.match(r'^\\d{14,}$', words[1]):\r\n                    f.write(line)\r\n            f.truncate()\r\n        num_processed += 1\r\n        pbar.update()\r\n\r\n    # Log result\r\n    elapsed_time = time.time() - start_time\r\n    logging.info(\"Processed %d files in %s seconds\", num_processed, str(\r\n        datetime.fromtimestamp(elapsed_time).strftime('%H:%M:%S')))\r\n\r\n    # Close progress bar\r\n    pbar.close()\r\n\r\n\r\n# Example usage:\r\ndelete_timestamp_lines_in_folder(\"./tiddlers\")\r\n```","type":"text/markdown","created":"20230319112240632","creator":"oeyoews","modified":"20230319112308079","modifier":"oeyoews","publish":"public","tags":""},{"title":"design-mode","text":"前端开发中常用的设计模式有以下几种：\r\n\r\n1. 单例模式（Singleton Pattern）：单例模式是指保证一个类仅有一个实例，并提供一个全局的访问点。它通常用于管理全局资源、配置信息、日志等。在 JavaScript 中，可以通过闭包和模块化的方式来实现单例模式。\r\n\r\n2. 工厂模式（Factory Pattern）：工厂模式是指定义一个用于创建对象的接口，让子类决定实例化哪一个类。它将对象的创建延迟到子类中进行，从而避免了在代码中显式地引用具体类。常用于创建一些复杂的对象。\r\n\r\n3. 观察者模式（Observer Pattern）：观察者模式是指定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新。常用于解决对象间的耦合问题，可以实现松耦合的设计。\r\n\r\n4. 装饰器模式（Decorator Pattern）：装饰器模式是指动态地给一个对象添加一些额外的职责，而不需要修改它的原始代码。它通过包装一个对象来扩展它的功能，从而避免了继承带来的静态性和不可扩展性。常用于增强对象的功能和可维护性。\r\n\r\n5. 策略模式（Strategy Pattern）：策略模式是指定义一系列算法，将每个算法都封装起来，并使它们可以相互替换。它可以让算法的变化独立于使用它的客户端，从而提高代码的灵活性和可维护性。常用于实现一些动态的算法和逻辑。\r\n\r\n6. 命令模式（Command Pattern）：命令模式是指将一个请求封装成一个对象，从而使你可以用不同的请求对客户端进行参数化。它可以将请求的发送者和接收者解耦，从而提高系统的灵活性和可扩展性。常用于实现一些可撤销的操作和日志记录。\r\n\r\n这些设计模式在前端开发中都有着广泛的应用，可以帮助我们更好地组织代码、降低耦合、提高可维护性和可扩展性。不同的设计模式适用于不同的场景和需求，我们需要根据实际情况来选择合适的模式来进行开发。希望这个解释能够帮助您更好地了解前端常用的设计模式。\r\n\r\n好的，让我来举几个前端开发中常用的设计模式的例子：\r\n\r\n1. 单例模式：在前端开发中，单例模式常用于管理全局资源、配置信息和日志等。例如，我们可以通过创建一个全局的 Logger 对象来实现日志的记录和管理：\r\n\r\n```js\r\nclass Logger {\r\n  constructor() {\r\n    this.log = [];\r\n  }\r\n\r\n  add(message) {\r\n    this.log.push(message);\r\n  }\r\n\r\n  print() {\r\n    console.log(this.log.join('\\n'));\r\n  }\r\n\r\n  static getInstance() {\r\n    if (!Logger.instance) {\r\n      Logger.instance = new Logger();\r\n    }\r\n    return Logger.instance;\r\n  }\r\n}\r\n\r\nconst logger = Logger.getInstance();\r\nlogger.add('Hello');\r\nlogger.add('World');\r\nlogger.print();\r\n```\r\n\r\n```javascript\r\nconst Logger = (function () {\r\n  let instance;\r\n\r\n  function createInstance() {\r\n    const log = [];\r\n\r\n    function add(message) {\r\n      log.push(message);\r\n    }\r\n\r\n    function print() {\r\n      console.log(log.join('\\n'));\r\n    }\r\n\r\n    return {\r\n      add,\r\n      print,\r\n    };\r\n  }\r\n\r\n  return {\r\n    getInstance: function () {\r\n      if (!instance) {\r\n        instance = createInstance();\r\n      }\r\n      return instance;\r\n    },\r\n  };\r\n})();\r\n\r\nconst logger = Logger.getInstance();\r\nlogger.add('Hello');\r\nlogger.add('World');\r\nlogger.print();\r\n```\r\n\r\n在这个例子中，我们通过创建一个闭包来实现单例模式，保证了 Logger 对象仅有一个实例。我们在 Logger 对象中定义了一些方法，如 add 和 print，用于记录和输出日志。然后，我们通过调用 Logger.getInstance()方法来获取 Logger 对象的实例，从而实现了全局的日志管理。\r\n\r\n2. 工厂模式：在前端开发中，工厂模式常用于创建复杂的对象和组件，例如 React 组件、Redux store 等。以下是一个简单的 React 组件工厂的例子：\r\n\r\n```javascript\r\nclass Button extends React.Component {\r\n  // Button组件的实现\r\n}\r\n\r\nclass Input extends React.Component {\r\n  // Input组件的实现\r\n}\r\n\r\nclass ComponentFactory {\r\n  static create(type) {\r\n    if (type === 'button') {\r\n      return Button;\r\n    } else if (type === 'input') {\r\n      return Input;\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\nconst ButtonComponent = ComponentFactory.create('button');\r\nconst InputComponent = ComponentFactory.create('input');\r\n```\r\n\r\n在这个例子中，我们定义了两个 React 组件 Button 和 Input，分别用于创建按钮和输入框。然后，我们创建了一个 ComponentFactory 工厂类，用于根据传入的参数来创建对应的组件。最后，我们通过调用 ComponentFactory.create('button')和 ComponentFactory.create('input')来获取 Button 和 Input 组件的实例，从而实现了组件的动态创建和管理。\r\n\r\n3. 观察者模式：在前端开发中，观察者模式常用于处理事件和状态的变化，例如 React 组件的生命周期、Redux store 的状态更新等。以下是一个简单的 Redux store 的观察者的例子：\r\n\r\n```javascript\r\nclass Store {\r\n  constructor() {\r\n    this.listeners = [];\r\n    this.state = {};\r\n  }\r\n\r\n  getState() {\r\n    return this.state;\r\n  }\r\n\r\n  subscribe(listener) {\r\n    this.listeners.push(listener);\r\n  }\r\n\r\n  dispatch(action) {\r\n    this.state = reducer(this.state, action);\r\n    this.listeners.forEach((listener) => listener(this.state));\r\n  }\r\n}\r\n\r\nfunction reducer(state, action) {\r\n  // 处理state和action，返回新的state\r\n}\r\n\r\nconst store = new Store();\r\n\r\nstore.subscribe((state) => {\r\n  console.log('State has changed:', state);\r\n});\r\n\r\nstore.dispatch({ type: 'INCREMENT' });\r\n```\r\n\r\n在这个例子中，我们定义了一个 Redux store 的类 Store，用于管理应用的状态。我们在 Store 类中定义了 getState、subscribe 和 dispatch 等方法，用于获取状态、添加观察者和派发 action。然后，我们在 store 对象上添加了一个观察者函数来监听状态的变化。最后，我们调用 store.dispatch({ type: 'INCREMENT' })来触发状态的变化，从而实现了观察者模式的应用。\r\n\r\n希望这些例子能够帮助您更好地理解前端常用的设计模式，以及如何在实际开发中应用它们。","type":"text/markdown","created":"20230601030750449","creator":"oeyoews","modified":"20230726045248452","modifier":"oeyoews","tags":"JavaScript"},{"title":"difference-template-var","text":"```js\r\nconst tags = [\"想法\", \"任务\", \"工作\", \"生活\", \"其他\"];\r\nconsole.log(`${tags}`);\r\nconsole.log(tags);\r\n```\r\n\r\n模板字符串会自动将数组转换成字符串","type":"text/markdown","created":"20230908111439790","creator":"oeyoews","modified":"20230908111523283","modifier":"oeyoews","tags":"JavaScript"},{"title":"display-four","text":"inline：元素会被显示为内联元素，元素的高度、宽度、外边距和内边距不可设置，它们的大小由元素的内容决定。\r\n\r\nblock：元素会被显示为块级元素，元素会在新行上开始，并占据一个可设置的宽度，高度、外边距和内边距也可设置。\r\n\r\ninline-block：元素会被显示为内联元素，但是可以设置宽度、高度、外边距和内边距。\r\n\r\nflex：元素会被显示为一个弹性盒子，元素的子元素可以在弹性盒子中被排列。\r\n\r\ninline-flex：元素会被显示为一个内联块级弹性盒子，元素的子元素可以在弹性盒子中被排列。","type":"text/markdown","created":"20230322142248095","creator":"oeyoews","modified":"20230322142308720","modifier":"oeyoews","tags":""},{"title":"docker-bug","text":"docker COPY . . COPY * ./ 区别很大  \r\n\r\n是否挂在卷, 区别也很大","type":"text/markdown","created":"20230904023642215","creator":"oeyoews","modified":"20230904023721162","modifier":"oeyoews","tags":""},{"title":"docker-bug01","text":"tw 在 docker 里面资源的启动顺序变化啦","type":"text/markdown","created":"20230904045912068","modified":"20230904045949362","tags":"docker"},{"title":"docker-build","text":"\"Docker build -t\" 是用于构建 Docker 镜像的命令。在这个命令中，\"-t\" 参数用来指定构建的镜像的名称（tag）。通常，您可以将其理解为给您的镜像取一个易于识别的名称，以便在后续的操作中使用。例如，如果您想要构建一个名为 \"myapp\" 的镜像，您可以运行以下命令：\r\n\r\n```plain\r\ndocker build -t myapp:tagname .\r\n```\r\n\r\n这个命令会在当前目录中查找 Dockerfile，并使用它来构建名为 \"myapp\" 的镜像。然后，您可以使用这个名称来运行、推送或执行其他 Docker 操作，以管理您的镜像。","type":"text/markdown","created":"20230903154914294","creator":"oeyoews","modified":"20230903154953855","modifier":"oeyoews","tags":"docker"},{"title":"docker-cache","text":"只要 dockerfile 的指令不发生变化就会走缓存\r\n\r\n可以加--no-cache 不使用缓存","type":"text/markdown","created":"20230905080020734","creator":"oeyoews","modified":"20230905080249416","modifier":"oeyoews","tags":"docker"},{"title":"docker-mirror","text":"~/.docker/config.json\r\n/etc/docker/daemon.json \r\n\r\n```config.json\r\n{\r\n\"registry-mirrors\": [\r\n    \"https://hub-mirror.c.163.com\",\r\n    \"https://mirror.baidubce.com\"\r\n  ]\r\n}\r\n```\r\n\r\n restart docker","type":"text/markdown","created":"20230903145320911","creator":"oeyoews","modified":"20230903145442028","modifier":"oeyoews","tags":"docker"},{"title":"docker-port","text":"如果你在运行 Docker 容器时不使用`-d`标志，容器将以交互模式运行，这意味着容器的标准输出将会显示在终端上，并且终端会保持与容器的连接。在这种情况下，终端将被容器占用，容器的标准输入和输出都将与终端相关联。\r\n\r\n这可能会导致一些端口无法访问的情况，因为容器的执行占用了终端，你不能在同一终端中运行其他命令来与容器进行交互，包括通过容器暴露的端口进行访问。\r\n\r\n为了解决这个问题，你有几个选择：\r\n\r\n1. 使用`-d`标志：像之前提到的那样，在后台模式运行容器，这将释放终端并允许其他进程通过容器暴露的端口进行访问。\r\n\r\n2. 打开一个新终端窗口：如果你不使用`-d`标志，并且希望让容器保持交互模式，可以在新的终端窗口中执行其他命令以与容器进行交互。\r\n\r\n3. 后台运行容器并使用`docker exec`：你可以使用`docker exec`命令在容器后台运行的情况下与容器进行交互。例如：\r\n\r\n   ```bash\r\n   docker run my-image\r\n   ```\r\n\r\n   然后，在另一个终端中运行：\r\n\r\n   ```bash\r\n   docker exec -it <container_id> /bin/bash\r\n   ```\r\n\r\n   这将允许你进入容器的 shell，以便执行命令，同时容器仍然在后台运行并保持端口访问。\r\n\r\n选择哪种方法取决于你的需求和工作流程。如果你希望容器在后台运行并通过端口提供服务，那么使用`-d`标志是常见的做法。","type":"text/markdown","created":"20230903144726298","creator":"oeyoews","modified":"20230903144737155","modifier":"oeyoews","tags":"docker"},{"title":"docker-tag","text":"docker latest 标签只是一个普通的标签, 不会自动更新","type":"text/markdown","created":"20230904041654734","creator":"oeyoews","modified":"20230904041722338","modifier":"oeyoews","tags":"docker"},{"title":"docker-with-sudo","text":"if you install docker firstly, you need use sudo to run docker command\r\n\r\n```bash\r\nusermod -aG docker $USER\r\n```","type":"text/markdown","created":"20231001111751535","creator":"oeyoews","modified":"20231001111928235","modifier":"oeyoews","tags":"docker"},{"title":"docker-with-tiddlywiki-starter-kit","text":"```bash\r\ndocker exec -it id -sh  // 连接 docker instance\r\ndocker cp id:/app/.tiddlywiki . // copy folder\r\n```\r\n\r\n","type":"text/markdown","created":"20230912095816178","modified":"20230912101522238","tags":"docker"},{"title":"docs/README","text":"## 写在前面\n\n完备的文档可以让开发者快速了解一个项目进行开发，很遗憾， tiddlywiki 虽然有文档，但不多。如果想要深入了解，只能通过源代码，好在 tw 的源代码的注释还是比较友好的（我并没有看完 tw 的源代码，只是大致过了一遍，然后需要的时候就直接搜索关键词再仔细看具体的代码，难道这就是面向 api 开发？） ... 未完待续\n\n这无疑增加了每个开发者的负担，并且严重影响效率，tw 的用户很少很少，一直坚持使用的大概是真爱了吧，使用 tw 并且进行开发 tw 插件的就少上加少了，tw 没有进行商业化开发，所以很多功能虽然有了，但是使用体验过上并不好，但 tw 真的是一款令人瞬间眼前一亮的软件.\n\n> :warning:\n> 此文件处于 alpha 阶段，正在不断整理并更新（并没有什么整理计划，比较凌乱，目前放在仓库的 docs 目录中，并且也可以在网站中预览，后期可能会将此文档单独分离出来做一个网站），此文件根据个人时间安排不定期更新， 前期主要以文字代码为主， 相关示例图片会在后期添加..\n\n[online preview](https://tiddlywiki-starter-kit.vercel.app/#docs%2FREADME)\n\n## 为什么写 tiddlywiki starter kit？\n\n本身 nodejs 启动 tw 也就是一条命令行的事，很简单，但是为了满足自己的各种需求，命令行就显得很吃力了，tiddlywiki starter kit 经过多版本迭代，历经两年打磨而成.\n\n## 使用场景\n\n- 日记\n- 图片画廊\n- 链接汇总\n- 视频汇总\n- 剪藏文章\n- 在线分享\n- 文章写作\n- 代码展示\n- 个人主页\n- 电视,电影,动漫纪律\n- 书籍整理\n- ...\n\n# Tutorials\n\n## 安装方式\n\n```bash\nnpm create neotw-app@latest\n```\n\n```bash\n# dependcies: git node bun docker docker-compose\n\n# method 01: docker\ndocker run -d --name tiddlywiki -p 8080:8080 -v $(pwd)/wiki:/app/wiki oeyoews/tiddlywiki:latest tiddlywiki wiki --listen port=8080 host=0.0.0.0\n\n# method 02: use docker-compose(推荐使用, 最为方便快捷的方法)\ndocker-compose up -d ## docker-compose.yml 参考 [docker-compose.yml](./docker-compose.yml)\n\n# method 03: clone repo directly\ngit clone --depth 1 https://github.com/oeyoews/tiddlywiki-starter-kit\ncd tiddlywiki-starter-kit && pnpm install  # install packages\npnpm start  # start tiddlywiki on https://localhost:8099 or use pm2 with yarn pm2:start\n\n# method 04: 单文件版本 打开 https://neotw.oeyoewl.top/editions, 直接保存网页到本地\n\n# method 05: systemd https://www.freedesktop.org/software/systemd/man/systemd.service.html\n\n# method 06: pnpm pm2 start（我目前使用的方式， 因为我主要在本地使用，需要频繁更新tiddlywiki-starter-kit源码，避免每次都要构建docker mirror的步骤）\n\n```\n\n## Introduce\n\n## 开发依赖\n\n- FONTS: maple\n- ENV: nodejs/bun pnpm/npm git\n- EDITOR: vscode/neovim/others\n\n## How to use tiddlywiki starter kit with locally ?\n\n- 事实上 tiddlywiki starter kit 由三部分组成\n\n1. tiddlywiki-starter-kit（核心）\n2. neotw-tiddlers（用户 markdown 文件）\n3. subwiki（用户个人 wiki）\n\n`tiddlywiki.info` 实际上一个 json 类型的文件，但是 json 文件不支持注释，每次只能手动编辑这个文件手动更新， 因此 tiddlywiki-starter-kit 借助 dotenv 将配置放在.env 文件中， 每次启动 tw 的时候动态生成 tiddlywiki.info 文件，这可以在不同的环境使用不同的配置，目前主要针对本地和部署环境， 部署环境下可以自动移除不需要的插件，并且使用仅仅在部署时使用的插件， 因此不建议手动编辑 tiddlywiki.info 文件，此文件仅仅用来让 tw 来读取启动\n\n## Playground\n\n- 每个 tw 网页都可以看作是一个 playground,你可以在上面任情玩耍,而不用担心弄坏什么\n\n## 构建\n\n- 在 tiddlywiki.info 文件中， build 是一个数组， 在里面可以添加多个构建步骤， 在构建的时候如果 build 后面不加具体的构建步骤， 默认会执行里面的所有步骤，在 tiddlywiki-starter-kit 里面默认支持目录为.tiddlywiki, 默认使用 external.js 同时生成 offline.html/index.html\n\n## 部署\n\n- tw 生成的是单文件可部署文件，因此不限制部署平台，甚至可以直接使用 tw server， tiddlywiki-starter-kit 使用的 vercel/github pages 方式\n\n## How to use tiddlywiki starter kit with docker ?\n\n## How to write tiddlywiki plugin for yourself ？\n\n## 插件配置\n\n...\n\n## 插件加载顺序\n\n很抱歉，tw 并不支持指定插件的加载顺序，但是你可以决定条目的优先级 ...未完待续\n\n## 文件后缀\n\n一般文件后缀都是 tid 开头，但是如果你看过 tw 的官方插件的写法，你会发现也可以直接使用 js 后缀， 而不需要使用 tid，\n那么 tw 是靠什么识别的呢， 就是文件开头的注释，tw 会自动识别注释中的一些特殊格式的数据（注释删除真的会影响代码运行）\n\n```js\n/*\\\ntitle: plugin/username/pluginname/widget.js\ntype: application/javascript\nmodule-type: widget\n\nhere is a js file description\n\nfilename: widget.js\n\n\\*/\n```\n\n就是类似上面的那种格式， 或者你也可以直接写 js 代码，将这些数据注释放在 widget.js.meta 的文件中去， 写法和 tid 写法一致， 注意 meta 前面的名字文件一定要保持一致，其它类型的文件也同理，比如 style.css 和 style.css.meta\n\n## 插件名字\n\n$:/plugins/author/pluginname (插件名字可以任意命名但不推荐，建议使用官方写法）\n\n## 插件介绍\n\n```bash\n--- tiddlers\n--- readme.tid\n--- plugin.info\n--- icon.tid\n```\n\n在 tw 里面存储 tiddler 的文件目录默认是 tiddlers，所以在插件目录里面也默认使用 tiddlers 名字，可以看作 src 的意思，核心代码都在这个木里面;\n\nicon.tid 提供插件的图标，就是插件 logo 的意思\n\nreadme.tid 是关于插件的 readme， 同样你也可以使用 readme.md 代替，你可以在 readme.md 文件里面使用 markdown 语法，但是需要安装 markdown 插件，在 tw 里面才能识别\n\n## 插件的开发方式\n\n> 下面顺序还没有经过整理，想到哪写到哪，如有错误遗漏之处欢迎 pr。\n\n- tw5 里面的插件开发由于其独特的风格，开发方式有很多种，tw 官方的 dev 文档也没有明确说明，仅仅展示了一些具体的插件代码示例，并没有具体说明（tw 的文档是多个 tiddler 组成的，全靠链接进行联系， 如果没有按照官方的顺序来看，很容易犹豫不知道 tiddler 的上下文环境感到迷惑\n- 如果你对 tw 的插件代码编写熟悉后，建议在 tw 源代码仓库里面搜索相关的关键词，查看对应的源码，或者直接看 tw 官方的插件是如何编写的（js 插件官方使用 es5 编写，建议直接使用 es6 的 class 编写代码\n\n- 由于 wikitext 编写体验没有 js/ts 代码体验好（wikitext 没有 lsp，提示全靠 snippet， 我个人写的更多是 js 插件，下面如果没有特殊说明，默认就是 js 插件开发细节\n\n- 你可以直接在 tw 里面新建一个文件，文件类型选择 javascript，额外添加一个 key-value 字段 module-type: widget\n\n## UI\n\n在 tw 经常需要操作一些 dom， 一般 js 的写法就是使用`document.createElement('xxx')`的做法， 但是如果有多个节点需要插入，就需要不断进行 append， 看起来比较混乱， tw 基于 createElement 封装了了一个函数 `$tw.utils.domMaker`\n\n```js\nconst createElement = $tw.utils.domMaker;\n\nconst div = createElement('div', {\n  class: 'm-2',\n  text: 'this is a div node',\n  attributes: {\n    title: 'tooptip',\n  },\n  children: [divNode1, divNode2, xxx],\n});\n```\n\n## 指定保存目录\n\n```bash\n'default-tiddler-location': 'tiddlers'\n```\n\ntw 会一直读取这个文件的内容, 无论修改成什么值, 可以看作值 public folder, 但是注意, 如果在改成了别的之后, 如果修改了 tiddlers 文件夹的内容, 对应的文件会转移到新的文件. https://github.com/oeyoews/tiddlywiki-starter-kit/issues/117\n\n## Data\n\n- tw 里面的数据有两种格式 json 和 tw 自带的 x-dictionary-tiddler 类型的文件， 但是获取后都是一个 json 对象，没有区别， x-dictionary-tiddler 的形式都是 key- value 的类型，形式比较固定， 直接使用 require（'xxx.json')即可加载，就像加载普通的 json 文件一样， 唯一需要注意的是文件名字需要使用 tw 里面的文件名字\n\n## meta\n\n- tw 识别每个 tiddler 的 title 全靠 meta 数据， 如果一个 tiddler 没有 title 字段，就会默认使用文件系统的真实路径作为 title， 比如 `/home/username/workspace/wiki/tiddlers/GettingStarted.tid`，\n\n## 相对路径\n\n- require 在 tw 里面同样支持相对路径， 只不过是基于 tw 的虚拟文件路由\n\n## 插件文档\n\n- 除了写出好的插件代码，详尽的插件文档或者是教程也是很重要的，因为你的插件面向的是用户，用户只有通过文档才能了解作者的插件应当如何使用，进而完全发挥插件的最大作用，尽可能简洁扼要的说明插件的功能，用法，注意事项，使用示例等必要的说明\n\n## 插件示例\n\n[template](https://github.com/oeyoews/tiddlywiki-starter-kit/tree/main/plugins/oeyoews)\n\n## Concepts\n\n- 数据原子：tiddlywiki(以下简称 tw）的每一个 tiddler 都可以看作是一条数据，所有的 tiddler 可以类比为一个数据库，我们可以重新拿到这些数据以适当的形式重新展示这些数据， 比如写一个卡片组件，时间线组件，轮播图组件，文件树组件等各种 ui 组件， UI 本身没有任何意义， 有了数据后才有了灵魂。每个组件（widget）都可以看作是 react 的组件（component），可以在 tw 的任何地方嵌入使用。\n\n- 灵活性： 可以任意操作 dom\n\n## Recipes\n\n- 如果你的插件经常需要添加样式，请考虑使用 css library， 手写样式真的很影响插件的编写体验，如果你熟悉一个 css library， 就不需要为此烦恼（css library 不要过大， 在 tw 里面如果一个插件的大小超过 500 开， 就可以算得上一个大插件了，一定程度上会影响加载速度）\n- tw 源代码使用 es5， 但是你也可以使用 es6，这主要取决于你的浏览器的支持程度（2023 年了， 只要你的浏览器不是很旧，几乎都支持）， 但是注意 import 机制在这里肯定是不支持的，tw 使用 require； 使用 es6 可以极大程度上简化代码，比如最常使用的箭头函数，解构赋值，展开运算符，模版字符串， Promise 等\n\n- 由于 tw 为了兼容性，没有什么 es6，只能手动封装一些比较常用的函数\n\n## 源码解读系列\n\n[code.js](./code.js)\n\n## bug 排查\n\n- tiddlywiki starter kit 含有大量的定制化插件, 插件可以使用配置文件动态加载, tiddlers 文件夹默认为空, 尽量保持了高内聚低耦合, 但是仍然会有一些奇怪的问题排查起来很费时费力(尤其是多个 bug)\n\n## 关于中文教程\n\n中文教程里面也有一些相关的插件开发介绍， 但是不够系统，在 tw 里面分散为多个文件，很容易失去文章的上下文，不利于快速通读了解 tw 的大致插件开发流程\n\n## Plugins template\n\n[template](https://github.com/oeyoews/tiddlywiki-starter-kit/tree/main/templates/new-plugin)\n\n> Coming\n\n> 这个目录的文件已经通过软链接的相对路径链接到 tiddlers（neotw-tiddlers）里面， 所以你也可以在 [website](https://neotw.oeyoewl.top) 里面看到这些文章（docs 开头）\n","type":"text/markdown"},{"title":"document-getElementById","text":"`getElementById` 方法只能通过 `document` 对象来调用，因为它是 Document 接口的一部分，用于在文档对象模型（DOM）中通过元素的 ID 来获取相应的元素节点。这个方法的调用形式如下：\r\n\r\n```javascript\r\nvar element = document.getElementById(\"elementId\");\r\n```\r\n\r\n在这里，`document` 是一个全局对象，代表整个文档。通过 `getElementById` 方法，你可以在文档中查找匹配指定 ID 的元素节点。这是因为 HTML 规范要求一个文档中每个 ID 都是唯一的，所以可以通过 ID 来精确地获取一个特定的元素。\r\n\r\n需要注意的是，`getElementById` 方法只在浏览器环境中可用，因为它是浏览器提供的 DOM API 的一部分。在其他 JavaScript 运行环境（例如 Node.js）中，是无法直接使用该方法的，因为那些环境没有浏览器的 DOM。","type":"text/markdown","created":"20230829135039087","creator":"oeyoews","modified":"20230829135056960","modifier":"oeyoews","tags":"JavaScript"},{"title":"domMaker-iframe","text":"`$tw.utils.domMaker` 不支持 iframe(似乎也没有支持的必要)","type":"text/markdown","created":"20230929134951488","creator":"oeyoews","modified":"20230929135053563","modifier":"oeyoews","tags":"TiddlyWiki"},{"title":"double-question","text":"在编程中，\"??\" 和 \"||\" 是两个不同的操作符，它们有不同的作用和用途。\n\n1. \"??\"\n   \"?? \"是空值合并运算符，通常用于处理可能为空或未定义的值。如果左侧的操作数是 null 或 undefined，它会返回右侧的操作数，否则返回左侧的操作数。这对于确保你有一个有效的值来使用非常有用。\n\n   例如：\n   ```javascript\n   let value = someValue ?? defaultValue;\n   ```\n\n   如果 `someValue` 有值，那么 `value` 将等于 `someValue`。如果 `someValue` 是 null 或 undefined，那么 `value` 将等于 `defaultValue`。\n\n2. \"||\"\n   \"||\" 是逻辑或操作符，用于执行逻辑或操作。它返回第一个为真的操作数，如果都是假，则返回最后一个操作数。\n\n   例如：\n   ```javascript\n   let result = expression1 || expression2;\n   ```\n\n   如果 `expression1` 为真，那么 `result` 将等于 `expression1` 的值。如果 `expression1` 为假，但 `expression2` 为真，那么 `result` 将等于 `expression2` 的值。\n\n总结：\n- \"??\" 用于处理空值和未定义值，确保你有一个有效的值。\n- \"||\" 用于执行逻辑或操作，返回第一个为真的值。\n\n这两个操作符在不同情况下有不同的用途，根据你的需求选择合适的操作符。","type":"text/markdown","created":"20231014235309185","creator":"Lenovo","modified":"20231014235322340","modifier":"Lenovo","tags":"JavaScript"},{"title":"double-quote","text":"\"??\"是一个新的语法特性，也称为\"nullish coalescing operator\"，可以用于判断一个值是否为 null 或 undefined，如果是，就返回一个默认值。这个语法特性和逻辑运算符\"||\"有些类似，但是它可以明确地区分 null 和 0 或''这些\"假值\"，从而避免一些潜在的问题。例如：\r\n\r\n```js\r\nconst foo = null ?? 'default value';\r\nconsole.log(foo); // 输出'default value'\r\n\r\nconst bar = 0 || 'default value';\r\nconsole.log(bar); // 输出'default value'，这里会出现一些潜在的问题\r\n```\r\n\r\n可以看到，当我们使用\"??\"运算符时，只有在值为 null 或 undefined 时才会返回默认值，而使用逻辑运算符\"||\"时，除了 null 和 undefined 之外，其他的\"假值\"也会触发返回默认值的操作。因此，在某些情况下，使用\"??\"运算符可能会更加安全和可靠。","type":"text/markdown","created":"20230527113331431","creator":"oeyoews","modified":"20230726045248454","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&double-quote","tags":"JavaScript"},{"title":"double!!","text":"在编程中，`!!variable` 的用途是将一个值转换为相应的布尔值。这是一种常见的技巧，可以用来判断一个值是否为真或假。\r\n\r\n具体地说，`!!variable` 的作用是将 `variable` 转换为布尔类型。如果 `variable` 是一个真值（例如非空字符串、非零数字、非空对象等），则 `!!variable` 的结果为 `true`。如果 `variable` 是一个假值（例如空字符串、零、`null`、`undefined` 等），则 `!!variable` 的结果为 `false`。\r\n\r\n这种转换通常用于条件判断，例如在逻辑表达式中使用。它可以将非布尔类型的值转换为布尔类型，以便进行条件判断或逻辑运算。\r\n\r\n以下是一个示例：\r\n\r\n```javascript\r\nconst value = \"Hello\";\r\nconst booleanValue = !!value;\r\nconsole.log(booleanValue); // true\r\n```\r\n\r\n在上述示例中，将字符串 \"Hello\" 转换为布尔类型，结果为 `true`。\r\n\r\n需要注意的是，`!!variable` 的使用并不是必需的，因为在大多数情况下，JavaScript 会自动进行类型转换来进行条件判断。但是，使用 `!!` 可以明确地将值转换为布尔类型，以增加代码的可读性和清晰性。","type":"text/markdown","created":"20230709123558971","creator":"oeyoews","modified":"20230726045248455","modifier":"oeyoews","tags":"JavaScript"},{"title":"down-full-website","text":"```bash\r\nwget -m https://revealjs.com/\r\n```","type":"text/markdown","created":"20230623154326876","creator":"oeyoews","modified":"20230726045248456","modifier":"oeyoews"},{"title":"DSL","text":"DSL（Domain-Specific Language，领域特定语言）框架是一种用于简化特定领域的编程语言开发的工具。其目的是为了在特定领域内提高开发效率和代码可读性，以及减少错误。\r\n\r\n通常情况下，DSL 框架会提供一种领域特定的语法和编译器，使得用户可以快速地构建专门用于某个领域的应用或系统。与通用编程语言相比，DSL 更加专注于某个特定领域，因此它能够提供更丰富、更直观、更易用的语法和工具，使得用户可以更加轻松地完成相关任务","type":"text/markdown","created":"20230428081342677","creator":"oeyoews","modified":"20230428081351713","modifier":"oeyoews","tags":""},{"title":"dynamic-protocal","text":"`//tokinx.github.io/ViewImage/view-image.min.js` 看起来是一个文件路径或 URL 地址，可能是用于加载 JavaScript 脚本的。在这个上下文中，双斜杠 `//` 在 URL 中通常表示使用与当前页面相同的协议（通常是 HTTP 或 HTTPS），以便动态适应页面的协议。例如，如果当前页面是通过 HTTPS 访问的，那么 `//tokinx.github.io/ViewImage/view-image.min.js` 将使用 HTTPS 协议加载脚本，如果是通过 HTTP 访问的，则使用 HTTP 协议加载。\r\n\r\n这个路径或 URL 可能用于在网页中加载一个名为 `view-image.min.js` 的 JavaScript 脚本，以添加特定的功能或交互性。具体脚本的功能和用途可能需要查看脚本的文档或源代码来了解。\r\n\r\n如果您需要更多关于这个脚本的信息或有具体问题，可以提供更多上下文，我将尽力提供帮助。","type":"text/markdown","created":"20230910142329441","modified":"20230910142351199","tags":"JavaScript"},{"title":"eacces","text":"* POSIX defines EACCES as \" an attempt was made to access a file in a way forbidden by its file access permissions \" and EPERM as \" an attempt was made to perform an operation limited to processes with appropriate privileges or to the owner of a file or other resource \".","type":"text/markdown","created":"20230324144249616","creator":"oeyoews","modified":"20230324144259246","modifier":"oeyoews","tags":""},{"title":"ease-in-out","text":"\"ease\"、\"ease-in\"和\"ease-out\"是 CSS 中用于设置过渡动画的缓动函数。它们之间的区别如下：\r\n\r\n1. **ease**：这是默认的缓动函数。它以均匀的速度开始，然后在动画的中间部分变化速度，最后以均匀的速度结束。换句话说，动画开始和结束时速度较慢，中间部分速度稍快。\r\n\r\n2. **ease-in**：这个缓动函数以较慢的速度开始，然后逐渐加快动画的速度，直到结束。它在动画开始时速度较慢，逐渐加速直到达到最大速度。\r\n\r\n3. **ease-out**：这个缓动函数以较快的速度开始，然后逐渐减慢动画的速度，直到结束。它在动画开始时速度较快，然后逐渐减慢直到停止。\r\n\r\n简而言之，\"ease-in\"使动画开始时更慢，\"ease-out\"使动画结束时更慢，而\"ease\"则是在开始和结束时都有缓慢的效果。\r\n\r\n您可以根据您的具体需求选择适合的缓动函数来达到期望的动画效果。如果您需要更多的帮助或有其他问题，请随时提问。\r\n\r\n\"ease-in-out\"是 CSS 中用于设置过渡动画的缓动函数之一。它结合了\"ease-in\"和\"ease-out\"的特性，具体表现为：\r\n\r\n1. 开始和结束时速度较慢，中间部分速度较快。\r\n\r\n2. 在动画开始时，速度由慢逐渐加快，直到达到最大速度。\r\n\r\n3. 在动画结束时，速度由快逐渐减慢，直到停止。\r\n\r\n总的来说，\"ease-in-out\"可以产生平稳、自然的动画效果。它通常适用于需要从静止状态到动态状态变化，再到静止状态的场景，如按钮点击效果、图片轮播等。\r\n\r\n在使用\"ease-in-out\"缓动函数时，您可以通过调整过渡时间（transition-duration）和过渡延迟（transition-delay）等属性来实现更细致的控制，以达到期望的动画效果。\r\n\r\n","type":"text/markdown","created":"20230929013843094","creator":"oeyoews","modified":"20230929013910636","modifier":"oeyoews","tags":"Tailwindcss CSS"},{"title":"echarts-params","text":"> official docs:  https://echarts.apache.org/handbook/zh/concepts/event/\n\nechart 的 params 很奇怪, 使用 params.data.name 和 params.name 都行\n\nhttps://blog.csdn.net/qq_44774831/article/details/116611935\n","type":"text/markdown","created":"20231011085439480","creator":"Lenovo","modified":"20231011120016553","modifier":"Lenovo","tags":"echarts"},{"title":"ecosystem.config.js","text":"```js\r\nmodule.exports = {\r\n  apps: [\r\n    {\r\n      name: 'neotw',\r\n      script: './lib/startup.mjs',\r\n      args: '--listen port=PORT --verbose',\r\n      watch: ['./plugins/oeyoews/', './themes'],\r\n      ignore_watch: ['./tiddlers'],\r\n      cwd: './',\r\n      watch_delay: 100,\r\n      log_file: './.logs/combined.outerr.log',\r\n      out_file: './.logs/out.log',\r\n      err_file: './.logs/err.log',\r\n      log_date_format: 'YYYY-MM-DD HH:mm:ss',\r\n    },\r\n  ],\r\n};\r\n```","type":"text/markdown","created":"20230916055246175","modified":"20230916055450652","tags":""},{"title":"Electron_原作者是谁？_-_知乎","text":"是他，[赵成（zcbenz）](https://link.zhihu.com/?target=https%3A//github.com/zcbenz)（如侵权，马上删）\n\n![](https://picx.zhimg.com/50/v2-86152a714adff286d97dd9a32848a373_720w.jpg?source=2c26e567)\n\n没错，是中国人（华人），聊 Electron 初创时期的历史不得不说[NW.js](https://link.zhihu.com/?target=https%3A//nwjs.io/)\n\n2011 年左右，中国英特尔开源[技术中心](https://www.zhihu.com/search?q=%E6%8A%80%E6%9C%AF%E4%B8%AD%E5%BF%83\\&search_source=Entity\\&hybrid_search_source=Entity\\&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2767987551%7D)的[王文睿（Roger Wang）](https://link.zhihu.com/?target=https%3A//github.com/rogerwang)希望能用 Node.js 来操作 WebKit，而创建了 node-webkit 项目，这就是 NW.js 的前身。[英特尔公司](https://www.zhihu.com/search?q=%E8%8B%B1%E7%89%B9%E5%B0%94%E5%85%AC%E5%8F%B8\\&search_source=Entity\\&hybrid_search_source=Entity\\&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2767987551%7D)大力支持了这个项目，不但允许王文睿分出一部分精力来做这个[开源项目](https://www.zhihu.com/search?q=%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE\\&search_source=Entity\\&hybrid_search_source=Entity\\&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2767987551%7D)，还给了他招聘名额，允许他招聘其他工程师来一起完成这个项目。\n\n2012 年，[赵成（zcbenz）](https://link.zhihu.com/?target=https%3A//github.com/zcbenz)加入到王文睿的小组，并对 [node-webkit](https://www.zhihu.com/search?q=node-webkit\\&search_source=Entity\\&hybrid_search_source=Entity\\&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2767987551%7D) 项目做出了大量的改进。后来赵成离开了英特尔，帮助 GitHub 团队尝试把 node-webkit 应用到 Atom [编辑器](https://www.zhihu.com/search?q=%E7%BC%96%E8%BE%91%E5%99%A8\\&search_source=Entity\\&hybrid_search_source=Entity\\&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2767987551%7D)上，但由于当时 node-webkit 还并不稳定，且 node-webkit 项目的走向也不再受赵成的控制了，这个尝试最终以失败告终。\n\n但赵成和 GitHub 团队并没有放弃，而是着手开发另一个类似 node-webkit 的项目：Atom Shell（2013 年 4 月），这个项目就是 Electron 的前身，赵成在这个项目上倾注了大量的心血，这也是这个项目后来广受欢迎的关键因素之一，再后来 GitHub 把这个项目开源出来（2014 年 5 月），最终更名为 Electron（2015 年 4 月）。\n\n**现如今赵成好像已经不再负责 Electron 项目的管理工作了**，而是交棒给了一个小姐姐了，就是这张照片里的 C 位女孩儿：[Shelley（codebytere）](https://link.zhihu.com/?target=https%3A//github.com/codebytere)\n\n![](https://pica.zhimg.com/50/v2-9ab25ba5b83e15c6be2d0daef8c2d6f6_720w.jpg?source=2c26e567)\n\n这个女孩儿也厉害的很，在做 Electron 开发工作的同时，还是[nodejs](https://www.zhihu.com/search?q=nodejs\\&search_source=Entity\\&hybrid_search_source=Entity\\&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2767987551%7D)、tc39 和 openjs-foundation 的成员。不过我个人感觉她对待开发者提的 Issue 和 PR 比较草率，没有赵成认真。\n\n相对于[Shelley（codebytere）](https://link.zhihu.com/?target=https%3A//github.com/codebytere)来说，我更喜欢[Jeremy Rose（nornagon）](https://link.zhihu.com/?target=https%3A//github.com/nornagon)，是他最早提出[remote](https://www.zhihu.com/search?q=remote\\&search_source=Entity\\&hybrid_search_source=Entity\\&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2767987551%7D)模块的危害性的！不知道是照片里的哪一位（应该是坐着的右一）。\n\n另外 VSCode 团队工程师[Robo（deepak1556）](https://link.zhihu.com/?target=https%3A//github.com/deepak1556)，也是 Electron 的核心贡献者，他提了很多很有深度的 PR。（没错，当他们觉得 Electron 无法满足 VSCode 的需求的时候，他们就来帮着改 Electron 的代码。）\n","type":"text/markdown","created":"20231104034432669","creator":"太微搜藏","modified":"20231104034432669","modifier":"太微搜藏","tags":"剪藏","url":"https://www.zhihu.com/question/365145291/answer/2767987551"},{"title":"element-ui","text":"element-ui 是由饿了么团队（ElemeFE）开发的一款基于 Vue.js 框架的 UI 组件库。ElemeFE 团队是阿里巴巴的前端技术团队之一，致力于为 Web 开发者提供优秀的前端技术解决方案。element-ui 组件库具有易用性、美观性和灵活性，成为 Vue.js 生态圈中非常受欢迎的 UI 组件库之一。","type":"text/markdown","created":"20230419035731603","creator":"oeyoews","modified":"20230419035752940","modifier":"oeyoews","tags":""},{"title":"emotion-library","text":"emotion css library","type":"text/markdown","created":"20230410035918396","creator":"oeyoews","modified":"20230410035935540","modifier":"oeyoews","tags":""},{"title":"empty-status","text":"<div class=\"empty:hidden bg-black w-12 h-12\"></div>","type":"text/markdown","created":"20230830013635283","creator":"oeyoews","modified":"20230830013946454","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"epub","text":"EPUB 是电子出版物的缩写，是一种常用的文件格式，用于存储和分发数字图书和出版物。它是由国际数字出版论坛（IDPF）开发的开放标准，在各种设备和平台上广泛支持。\r\n\r\nEPUB 文件被设计为高度兼容和灵活，可以轻松重新排列内容以适应不同的屏幕尺寸和方向。这使得 EPUB 成为电子阅读器、平板电脑、智能手机和其他设备的理想格式。EPUB 文件可以包含文本、图像、多媒体元素和交互功能，例如超链接和书签。\r\n\r\nEPUB 的优点之一是它能够适应不同的阅读偏好。用户可以调整字体大小、选择喜欢的字体样式，并更改背景颜色以提高可读性。EPUB 文件还支持文本朗读、高亮显示和笔记等功能，具体取决于阅读设备或应用程序的功能。\r\n\r\nEPUB 文件通常以 ZIP 格式进行压缩和打包，其中包含 HTML、CSS 和其他支持文件。这种结构使得可以方便地浏览书籍的章节、部分和其他元素。\r\n\r\n此外，许多电子阅读器和平板电脑都内置了 EPUB 支持，您无需额外的软件即可阅读 EPUB 文件。\r\n\r\nEPUB 已成为出版行业的标准格式，使得作者、出版商和读者更容易创建、分发和享受数字图书和出版物。\r\n\r\n要阅读 EPUB 文件，可以使用各种电子阅读器应用程序和软件，例如：\r\n\r\n* Calibre(linux)\r\n* Foliate(linux)\r\n* Apple books 阅读(ios)\r\n* google play books(support pc, 不是很流畅)\r\n* 微信读书支持导入书籍, 不过排版不太行","type":"text/markdown","created":"20230629041713893","creator":"oeyoews","modified":"20230726045248456","modifier":"oeyoews"},{"title":"epub-books","text":"代码相关的文章如果做成了书，就没了代码高亮","type":"text/markdown","created":"20231009125215183","creator":"Lenovo","modified":"20231009125223155","modifier":"Lenovo","tags":""},{"title":"er-graph","text":"* 实体(E): 真实存在(矩形表示)\r\n* 联系(R): (菱形表示)有联通词\r\n* 属性使用椭圆形表示,主键加下划线\r\n\r\n\r\nR 模型（Entity-relationship model）是一种用于表示现实世界中实体、属性和实体之间关系的数据模型。ER 模型通常由实体、属性和关系三部分构成。\r\n\r\n1.实体：指现实世界中具有独立存在和可识别性的事物，例如人、物品、公司等。\r\n\r\n2.属性：指实体所拥有的特征或者性质，例如人可以有姓名、年龄、性别等属性。\r\n\r\n3.关系：指两个或多个实体之间的联系，例如人和公司之间可以有就职关系，人和人之间可以有亲属关系。\r\n\r\nER 模型通过实体、属性和关系的描述，抽象出现实世界中的模型，帮助我们更好地理解、设计和管理数据。在数据库设计阶段，ER 模型通常被用来作为设计数据表结构的基础，将现实世界中不同的事物和它们之间的关系转化为表的结构和字段之间的关系，从而构建出一个合理、高效的数据库系统。\r\n\r\n总之，ER 模型提供了一种可视化的方式来描述现实世界中的数据模型，尤其是在数据库设计阶段，能够帮助开发者更好地理解数据之间的关系，并且对于数据的维护和查询也有很大的帮助。","type":"text/markdown","created":"20230416025853978","creator":"oeyoews","modified":"20230726045248457","modifier":"oeyoews","publish":"readonly"},{"title":"error-widget","text":"<$error $message=\"error demo\" />","type":"text/markdown","created":"20230606060058932","creator":"oeyoews","modified":"20230726045248458","modifier":"oeyoews","tags":"TiddlyWiki"},{"title":"es5/6","text":"Yes, ES5 and ES6 code can be mixed together in the same JavaScript file or project. ES6 introduced new features and syntax to JavaScript, but it was designed to be backward-compatible with ES5, meaning that any valid ES5 code should still work in ES6.\r\n\r\nIn fact, many projects start by using ES5 and gradually transitioning to ES6 as new features are needed or as older code is rewritten. This gradual transition can help avoid breaking changes and make it easier to adopt new features without having to rewrite entire codebases.\r\n\r\nHowever, when mixing ES5 and ES6 code, it's important to keep in mind that some ES6 features may not be supported in older browsers or environments. In those cases, you may need to use a compiler like Babel to transpile ES6 code into ES5 compatible code.\r\n\r\nOverall, mixing ES5 and ES6 code is a common practice in modern JavaScript development, and it allows developers to take advantage of newer language features while still maintaining backward compatibility.","type":"text/markdown","created":"20230420052301964","creator":"oeyoews","modified":"20230420052322410","modifier":"oeyoews","tags":""},{"title":"es6-7","text":"ES6 和 ES7 都是 JavaScript 的版本，主要有以下区别：\r\n\r\nES6（ECMAScript 2015）是 JavaScript 的第六个版本，于 2015 年发布。ES6 引入了很多新特性，包括箭头函数、let/const、解构赋值、类、Promise 等。这些新特性使得 JavaScript 更加强大、灵活，代码可读性更高。\r\n\r\nES7（ECMAScript 2016）是 JavaScript 的第七个版本，于 2016 年发布。ES7 新增了一些语言特性，包括 Array.prototype.includes()、指数操作符**、Async/Await 等。这些新增特性也使得 JavaScript 的语言能力进一步提升，更易于开发人员使用。\r\n\r\n可以总结如下：\r\n\r\n- ES6 和 ES7 都是 JavaScript 的版本，其中 ES6 是第六个版本，ES7 是第七个版本。\r\n- ES6 引入了很多新特性，使得 JavaScript 更加强大、灵活、易读；ES7 新增了一些语言特性，使得 JavaScript 的语言能力进一步提升。\r\n- 目前市场上已经普遍使用 ES6 语法，而 ES7 特性的使用仍受到限制，需要通过转译工具进行转译。因此，在实际项目开发中，还需要根据需求和兼容性考虑选择使用哪种语法。","type":"text/markdown","created":"20230428085004938","creator":"oeyoews","modified":"20230428085015579","modifier":"oeyoews","tags":"ES6"},{"title":"es6-7-8-9","text":"> ECMAScript 是一种由 Ecma International 标准化的脚本语言，也就是我们常说的 JavaScript。ECMAScript 的版本从 ES1 到 ES12 不断更新和迭代，其中主要包括以下几个版本：\r\n\r\nES6：2015 年 6 月发布，引入了大量新特性和语法糖，如箭头函数、模板字符串、解构赋值、类和模块等。\r\n\r\nES7：2016 年 6 月发布，引入了少量的新特性，如 Array.prototype.includes 和指数操作符（**）等。\r\n\r\nES8：2017 年 6 月发布，引入了 Async/Await、Object.entries()、Object.values()、String padding 等。\r\n\r\nES9：2018 年 6 月发布，引入了 Rest/Spread 属性、Promise.finally()、正则表达式具名捕获等。\r\n每个新版本都会引入更多的新特性和改进，以使得 JavaScript 的开发变得更加容易和高效。虽然不是所有浏览器都支持最新的 ECMAScript 版本，但是你可以使用 Babel 等工具将现代 JavaScript 代码转换为向下兼容的代码。","type":"text/markdown","created":"20230502123203046","creator":"oeyoews","modified":"20230726045248458","modifier":"oeyoews","tags":"JavaScript"},{"title":"eslint-error","text":"如果你的文件格式是 crlf, eslint 插件 会报错\n\n```error\nThe issue \"Delete ␍\" is a linting error message that is typically seen in code editors or IDEs. It is indicating that there is an unnecessary line break (carriage return) at a specific location in your TypeScript code.\n\nIn your provided code snippet, there is no specific line mentioned, so I can't provide more information about the exact location of the error. However, the error message suggests that you should remove the line break at that particular location.\n```","type":"text/markdown","created":"20231027100700354","creator":"Lenovo","modified":"20231027100740135","modifier":"Lenovo","tags":""},{"title":"event-bubble","text":"事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。\r\n\r\n##  事件冒泡\r\n\r\nDOM 事件，也是有一个流程的。从事件触发开始到事件响应是有三个阶段。\r\n\r\n* 事件捕获阶段\r\n* 处于目标阶段\r\n* 事件冒泡阶段\r\n\r\n## event 委托\r\n\r\n简单来说，就是利用事件冒泡，将某个元素上的事件委托给他的父级。\r\n\r\n### 优点\r\n\r\n* 减少内存消耗\r\n* 动态绑定事件\r\n* 减少内存消耗，优化页面性能\r\n\r\n好的，我可以举两个代码示例，来演示事件冒泡和事件委托的应用。\r\n\r\n1. 事件冒泡示例\r\n\r\n在这个示例中，我们为一个包含多个按钮的容器元素添加了一个单击事件处理程序。当用户单击任意一个按钮时，事件将从该按钮开始冒泡，最终到达容器元素，并触发事件处理程序。然后，我们使用事件对象来获取单击按钮的 ID，以便在控制台中输出。\r\n\r\n```html\r\n<div id=\"container\">\r\n  <button id=\"btn1\">按钮1</button>\r\n  <button id=\"btn2\">按钮2</button>\r\n  <button id=\"btn3\">按钮3</button>\r\n</div>\r\n```\r\n\r\n```javascript\r\nvar container = document.getElementById('container');\r\n\r\ncontainer.addEventListener('click', function(event) {\r\n  if (event.target.tagName === 'BUTTON') {\r\n    console.log('您单击了按钮：' + event.target.id);\r\n  }\r\n});\r\n```\r\n\r\n当用户单击任意一个按钮时，事件将从该按钮开始冒泡，最终到达容器元素，并触发事件处理程序。然后，我们使用事件对象来获取单击按钮的 ID，以便在控制台中输出。\r\n\r\n2. 事件委托示例\r\n\r\n在这个示例中，我们为一个包含多个列表项的列表元素添加了一个单击事件处理程序。但是，我们并没有将事件处理程序直接绑定到每个列表项上，而是将它绑定到列表元素的父元素上。当用户单击任意一个列表项时，事件将冒泡到列表元素，并触发事件处理程序。然后，我们使用事件对象来获取单击列表项的内容，以便在控制台中输出。\r\n\r\n```html\r\n<ul id=\"list\">\r\n  <li>列表项1</li>\r\n  <li>列表项2</li>\r\n  <li>列表项3</li>\r\n</ul>\r\n```\r\n\r\n```javascript\r\nvar list = document.getElementById('list');\r\n\r\nlist.addEventListener('click', function(event) {\r\n  if (event.target.tagName === 'LI') {\r\n    console.log('您单击了列表项：' + event.target.textContent);\r\n  }\r\n});\r\n```\r\n\r\n当用户单击任意一个列表项时，事件将冒泡到列表元素，并触发事件处理程序。然后，我们使用事件对象来获取单击列表项的内容，以便在控制台中输出。\r\n\r\n希望这两个示例能够帮助您更好地理解事件冒泡和事件委托的应用。如果您有任何问题或疑问，请随时向我提问。","type":"text/markdown","created":"20230421080044107","creator":"oeyoews","modified":"20230726045248459","modifier":"oeyoews"},{"title":"event-objectParam","text":"<$tid2pdf />\r\n\r\n```js\r\n// 获取按钮元素\r\nconst myButton = document.getElementById('myButton');\r\n\r\n// 绑定点击事件\r\nmyButton.addEventListener('click', function(event) {\r\n  // 使用 event.objectParam 获取事件相关的信息\r\n  const button = event.target;\r\n  const buttonId = button.id;\r\n  const eventType = event.type;\r\n  const clientX = event.clientX;\r\n  const clientY = event.clientY;\r\n  \r\n  console.log('按钮ID：', buttonId);\r\n  console.log('事件类型：', eventType);\r\n  console.log('鼠标点击位置：', clientX, clientY);\r\n});\r\n```","type":"text/markdown","created":"20230604030141179","creator":"oeyoews","modified":"20230726045248460","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&event-objectParam","tags":"JavaScript"},{"title":"event-tw","text":"<div class=\"bg-rose-200 p-2 rounded-md\">\r\n请注意，任何以 on 为前缀的 HTML 属性都将从呈现的 HTML 内容中删除。这样做是为了防止事件处理进程（例如 “onclick”）被用作以隐秘的方式运行不受信任的 JavaScript。TiddlyWiki 的一个设计目标是，确保可运行的 JavaScript 只能通过显式的 JavaScript 模块条目，或原始标记条目进入系统。这使得在多用户环境中，过滤不安全的内容成为可能，也使得复制不受信任的维基文本示例更加安全。\r\n</div>","type":"text/markdown","created":"20230423013218843","creator":"oeyoews","modified":"20230423013626383","modifier":"oeyoews","tags":"TiddlyWiki"},{"title":"export","text":"在 JavaScript 模块中，使用 export 语句将某个变量、函数或类声明为可导出的成员。在 React 项目中也经常使用 export 来导出组件。\n\n其中，有两种常见的 export 语句形式：export default 和 export(cjs 是 exports.xxx and module.exports = xxx)。\n\n- export default\n\nexport default 语句用于导出当前模块的默认值。通常情况下，在一个文件中，只能使用一次 export default 语句。在导入具有默认导出的模块时，可以不使用花括号来指定导入的名称。\n\n例如，假设有一个名为 MyComponent 的组件，可以通过以下方式进行默认导出：\n\n```jsx\nconst MyComponent = () => {\n  return <div>Hello, World!</div>;\n};\n\nexport default MyComponent;\n```\n\n在其他文件中，可以使用如下方式进行导入：\n\n```jsx\nimport MyComponent from './path/to/MyComponent';\n```\n\n- export\n\nexport 语句用于导出模块中的特定变量、函数或类。该语句可以声明多个导出项，并且导出项必须通过花括号 {} 进行包裹。\n\n例如，假设有一个名为 myFunction 的函数和一个名为 myVariable 的变量，可以通过以下方式进行导出：\n\n```jsx\nexport const myVariable = 42;\n\nexport function myFunction() {\n  console.log('Hello, World!');\n}\n```\n\n在其他文件中，可以使用如下方式进行导入：\n\n```jsx\nimport { myVariable, myFunction } from './path/to/myModule';\n```\n\n综上所述，export default 和 export 语句的主要区别在于：\n\n- export default 只能导出一个默认值；export 关键字可以导出多个变量、函数或类。\n- 在导入时，export default 可以直接指定默认值；export 关键字必须使用花括号来指定导入的名称。\n\n开发者应根据需要和习惯选择合适的导出方式。同时，在一个项目中也可以同时使用两种方式进行模块导出，以满足不同的需求。","type":"text/markdown","created":"20230428084906683","creator":"oeyoews","modified":"20231012230209701","modifier":"Lenovo","tags":"ES6"},{"title":"export-sql-file-with-dbeaver","text":"* select db\r\n* select tool\r\n* export \r\n\r\n> need setup /usr/bin to find mysqldump","type":"text/markdown","created":"20230328094137902","creator":"oeyoews","modified":"20230328094226895","modifier":"oeyoews","tags":""},{"title":"export-tiddlers.json","text":"```plain\n tiddlywiki --render '.' 'tiddlers.json' 'text/plain' '$:/core/templates/exporters/JsonFile' 'exportFilter'\n '[!is[system]]'\n ```","type":"text/markdown","created":"20231101072557053","creator":"Lenovo","modified":"20231101072623251","modifier":"Lenovo","tags":"TiddlyWiki"},{"title":"false-convert","text":"转换规则是除了下面六个值被转为 false，其他值都视为 true。\r\n\r\n* undefined\r\n* null\r\n* false\r\n* 0\r\n* NaN\r\n* \"\"或''（空字符串）\r\n\r\n:::note\r\n注意，空数组（[]）和空对象（{}）对应的布尔值，都是 true。\r\n:::","type":"text/markdown","created":"20230620115015442","creator":"oeyoews","modified":"20230726045248460","modifier":"oeyoews","tags":"JavaScript"},{"title":"favicon.ico-icon","text":"favicon.ico 默认 32x32","type":"text/markdown","created":"20230912020012311","modified":"20230912020029544","tags":""},{"title":"fetch-api","text":"Fetch API 使用 Promise 技术来处理异步操作。Fetch API 是用于异步获取资源的新标准 API，它提供了一种更现代、更简洁、更灵活的方式来处理网络请求。\r\n\r\n在 Fetch API 中，我们可以使用全局的 fetch() 函数来发起网络请求。fetch() 函数返回一个 Promise 对象，可以在异步操作成功或失败时执行回调函数。如果请求成功，Promise 对象将会 resolve 并返回一个代表响应的 Response 对象；如果请求失败，Promise 对象将会 reject 并返回一个代表错误信息的 Error 对象。\r\n\r\n以下是一个使用 Fetch API 发起网络请求的示例：\r\n\r\n```javascript\r\nfetch('https://jsonplaceholder.typicode.com/todos/1')\r\n  .then(response => {\r\n    if (!response.ok) {\r\n      throw new Error('Network response was not ok');\r\n    }\r\n    return response.json();\r\n  })\r\n  .then(data => {\r\n    console.log(data);\r\n  })\r\n  .catch(error => {\r\n    console.error('There was a problem with the fetch operation:', error);\r\n  });\r\n```\r\n\r\n使用 fetch() 函数发起一个 GET 请求，并在成功时输出响应的 JSON 数据，失败时输出错误信息。在 then 方法中，使用 response.json() 方法将响应的 JSON 数据解析为 JavaScript 对象。如果请求失败，catch 方法会捕获错误并输出错误信息。","type":"text/markdown","created":"20230523022921612","creator":"oeyoews","modified":"20230726045248461","modifier":"oeyoews","tags":"JavaScript"},{"title":"fetch-cache","text":"要了解 HTTP 协议的缓存策略，可以查看服务器返回的 HTTP 响应头中的缓存相关字段。以下是一些常见的缓存相关的响应头字段：\n\n1. Cache-Control：该字段指定了缓存的控制策略。常见的指令有：\n   - `public`：允许任何地方的缓存（包括客户端和代理服务器）缓存该响应。\n   - `private`：只允许客户端缓存该响应，不允许代理服务器缓存。\n   - `no-cache`：需要在使用缓存之前先向服务器验证是否过期。\n   - `no-store`：禁止缓存该响应，每次都需要向服务器请求最新数据。\n   - `max-age=seconds`：指定缓存的最大有效时间，以秒为单位。\n   \n2. Expires：指定了响应的过期时间，是一个具体的日期/时间。当当前时间超过过期时间时，缓存被认为是过期的。\n\n3. ETag：指定了一个唯一标识符，用于判断资源是否发生了变化。当资源没有发生变化时，可以使用缓存副本。如果服务器返回的响应中包含此字段，则客户端可以将其发送回服务器进行验证。\n\n4. Last-Modified：指定了资源的最后修改时间。与 ETag 一样，它也用于验证资源是否发生了变化。\n\n通过查看响应头中的这些字段，可以了解 HTTP 协议的缓存策略，判断是否可以使用缓存以及何时需要重新请求最新的数据。\n\n可以使用浏览器的开发者工具（如 Chrome DevTools）来查看网络请求的响应头字段，或者在代码中使用 Fetch API 或其他 HTTP 请求库获取响应头并进行分析。\n\n---\n\n在使用 Fetch API 发起网络请求的时候，可以通过设置缓存来提高性能和用户体验。Fetch API 提供了一个 `cache` 选项，可以指定请求的缓存模式。一共有 5 种缓存模式可供选择：\n\n- `default`：默认模式，采用 HTTP 协议的缓存机制；\n- `no-store`：不允许缓存，每次请求都会向服务器发送请求；\n- `reload`：强制从服务器刷新缓存，即使本地存在缓存；\n- `no-cache`：可以使用缓存，但首先必须向服务器验证缓存是否过期；\n- `force-cache`：强制使用缓存，即使它已经过期。\n\n在使用 Fetch API 的 `fetch()` 方法时，可以通过设置 `cache` 选项来指定缓存模式。例如：\n\n```javascript\nfetch(url, {\n  cache: 'no-cache'\n})\n```\n\n在上面的示例中，我们将缓存模式设置为 `no-cache`，表示可以使用缓存，但首先必须向服务器验证缓存是否过期。如果缓存未过期，则使用缓存；如果缓存已过期，则会向服务器发送请求获取最新数据。\n\n另外，还可以使用第二个参数 `init` 中的 `headers` 选项设置缓存控制头，例如：\n\n```javascript\nfetch(url, {\n  headers: {\n    'Cache-Control': 'no-cache'\n  }\n})\n```\n\n在上面的示例中，我们使用 `Cache-Control` 头设置缓存控制，将缓存模式设置为 `no-cache`。\n\n需要注意的是，如果服务器返回了有效的缓存控制头，则 Fetch API 会自动触发相应的缓存操作，不需要进行任何额外的设置。因此，在设置缓存模式时，建议同时设置合适的缓存控制头，以便在网络请求时能够正确地处理缓存。\n\n---\n\n`cache: \"no-cache\"`和`cache: \"no-store\"`是用于控制浏览器缓存行为的两个不同选项。\n\n1. `cache: \"no-cache\"`:\n   - 当设置为`\"no-cache\"`时，浏览器会发送请求到服务器进行验证，并在缓存中存储响应。\n   - 如果服务器返回的响应状态是 200，则表示响应有效，可以使用缓存中的响应。如果响应状态是其他值（如 304），则表示响应无效，需要重新从服务器获取新的响应。\n   - 这意味着浏览器会强制进行验证，但仍然允许缓存响应。\n\n2. `cache: \"no-store\"`:\n   - 当设置为`\"no-store\"`时，浏览器不会缓存任何响应，并且每次都会向服务器发送请求获取最新的数据。\n   - 响应不会被保存在浏览器的缓存中，也不会被替换或更新。\n   - 这意味着浏览器每次都会完全忽略缓存，并始终从服务器获取最新的响应。\n\n总结：\n- `\"no-cache\"`选项允许浏览器缓存响应，但需要验证响应的有效性。\n- `\"no-store\"`选项禁止浏览器缓存响应，始终请求最新的数据。\n\n---\n\n\"fetch\" 的 \"res.headers\" 是一个包含响应头信息的 Map。这个 Map 包含了响应的各种头部字段，通常用于获取有关响应的信息，比如内容类型、响应时间等。你可以使用不同的键来访问特定的响应头字段，比如：\n\n- \"Content-Type\"：响应的内容类型。\n- \"Date\"：响应的日期和时间信息。\n- \"Server\"：响应的服务器信息。\n- ...\n\n你可以通过 JavaScript 中的代码来访问这些响应头字段，例如：\n\n```javascript\nfetch('https://example.com')\n  .then(response => {\n    const contentType = response.headers.get('Content-Type');\n    const date = response.headers.get('Date');\n    const server = response.headers.get('Server');\n    \n    // 进行你的操作\n  })\n  .catch(error => {\n    console.error('发生错误：', error);\n  });\n```","type":"text/markdown","created":"20231103042151151","creator":"Lenovo","modified":"20231103043330889","modifier":"Lenovo","tags":"JavaScript"},{"title":"fetchDataBug","text":"{{fetchData}}\n\n这段代码可能涉及跨域问题。跨域是指在浏览器中，从一个源（origin）的网页尝试去请求另一个源的资源。在这种情况下，您的代码尝试从不同的源（'https://tiddlyhost.com'）获取数据。\n\n浏览器通常会执行同源策略（Same-Origin Policy），这意味着默认情况下，您的 JavaScript 代码不能从一个源直接请求另一个源的数据，这是出于安全考虑。这将导致跨域请求被拒绝。\n\n要解决跨域问题，您可以考虑以下方法之一：\n\n1. 使用服务器代理：您可以在自己的服务器上创建一个代理，然后从该代理服务器请求数据。这样，浏览器将只与您的服务器通信，而不会受到同源策略的限制。\n\n2. 跨域资源共享（CORS）：如果目标服务器支持 CORS，您可以在服务器上配置 CORS 规则，以允许特定源（或所有源）的请求。这需要在目标服务器上进行配置。\n\n3. JSONP：如果目标服务器支持 JSONP（JSON with Padding），您可以使用 JSONP 来获取数据。JSONP 是一种通过动态创建`<script>`标签来加载数据的技术，不受同源策略的限制。\n\n4. 使用代理服务：一些在线代理服务允许您通过它们来获取跨域数据，然后将数据返回给您的页面。这可以是一个快速解决方案，但需要谨慎使用，因为代理服务器可能会访问您的数据。\n\n选择哪种方法取决于您的具体需求和目标服务器是否支持相应的方法。确保在进行跨域请求时考虑安全性和合法性，以防止潜在的风险。","type":"text/markdown","created":"20231018234717114","creator":"Lenovo","modified":"20231018234739220","modifier":"Lenovo","tags":""},{"title":"figure","text":"`<figure>` 是一个 HTML 元素，它用于将图像、图表、照片、代码片段等媒体元素与其说明文本联系在一起。当您需要在网页中插入某个媒体元素时，可以使用 `<figure>` 元素来定义包含该元素的容器，并使用 `<figcaption>` 元素来添加与之相关的文本说明。\r\n\r\n以下是一个示例代码：\r\n\r\n```html\r\n<figure>\r\n  <img src=\"image.jpg\" alt=\"这是一张图片\">\r\n  <figcaption>这是一张漂亮的图片</figcaption>\r\n</figure>\r\n```\r\n\r\n在上面的代码中，我们使用 `<figure>` 元素来定义一个包含图像和说明文本的容器，并使用 `<figcaption>` 元素来添加与图像相关的文本说明。`<img>` 元素用于插入要显示的图像，并使用 `alt` 属性提供了一个替代文本，以便在无法加载图像时显示。\r\n\r\n同时需要注意的是，`<figure>` 和 `<figcaption>` 这两个元素通常是成对使用的，用于创建一个完整的媒体元素和说明文本的组合。`<figure>` 元素可以包含多个不同类型的内容，例如图像、音频、视频等，而 `<figcaption>` 元素则用于添加与之相关的文本说明。","type":"text/markdown","created":"20230503122345026","creator":"oeyoews","modified":"20230503122409419","modifier":"oeyoews","tags":"HTML"},{"title":"file-selector","text":"浏览器出于安全考虑通常不允许 JavaScript 访问文件的绝对路径","type":"text/markdown","created":"20230908153328783","creator":"oeyoews","modified":"20230908153335574","modifier":"oeyoews","tags":""},{"title":"filter","text":"`Array.filter()` 是 JavaScript 数组提供的一个高阶函数，用于筛选数组中满足条件的元素，并返回一个新的、由满足条件的元素组成的数组。\r\n\r\n`Array.filter()` 使用一个回调函数作为参数，该回调函数接受三个参数：当前正在遍历的元素、当前元素的索引和正在遍历的数组本身。回调函数应返回一个布尔值，决定是否保留当前元素在最终的结果数组中。\r\n\r\n语法结构如下：\r\n```javascript\r\nconst newArray = array.filter((element, index, arr) => {\r\n  // 进行条件判断，返回布尔值\r\n});\r\n```\r\n\r\n- `element`：当前正在遍历的元素。\r\n- `index`：当前元素的索引（可选）。\r\n- `arr`：正在遍历的数组（可选）。\r\n\r\n例如，假设我们有一个数字数组，要筛选出其中的偶数：\r\n\r\n```javascript\r\nconst numbers = [1, 2, 3, 4, 5, 6];\r\n\r\nconst evenNumbers = numbers.filter((number) => {\r\n  return number % 2 === 0;\r\n});\r\n\r\nconsole.log(evenNumbers); // 输出：[2, 4, 6]\r\n```\r\n\r\n在上述例子中，回调函数 `number % 2 === 0` 用于判断元素是否为偶数，满足条件的元素将被保留在 `evenNumbers` 数组中。\r\n\r\n需要注意的是，`Array.filter()` 不会修改原始数组，而是返回一个新数组。如果不满足筛选条件，元素将被忽略。如果所有元素都不满足条件，将返回一个空数组。\r\n\r\n`Array.filter()` 是一种非常常用和灵活的数组操作方法，可以根据自己的需要编写不同的筛选条件来满足特定的需求。","type":"text/markdown","created":"20230722182023656","creator":"oeyoews","modified":"20230726045248462","modifier":"oeyoews","tags":"JavaScript"},{"title":"filter-backdrop-filter","text":"`backdrop-filter` 和 `filter` 都是 CSS 中用于添加图像效果的属性，但它们有不同的作用和用途：\r\n\r\n1. **`filter` 属性**：\r\n\r\n   - **作用**：`filter` 属性用于在元素上应用图像效果，通常是在元素及其内容上应用效果。它可以影响元素内的所有内容，包括文本、图像等。\r\n   - **效果**：`filter` 属性可以用于应用诸如模糊、饱和度、对比度、亮度、色彩反转等图像效果。常见的值包括 `blur()`（模糊）、`brightness()`（亮度）、`contrast()`（对比度）等。\r\n\r\n   示例：\r\n   ```css\r\n   .element {\r\n     filter: blur(5px) brightness(150%);\r\n   }\r\n   ```\r\n\r\n2. **`backdrop-filter` 属性**：\r\n\r\n   - **作用**：`backdrop-filter` 属性也用于应用图像效果，但它通常用于背景元素，如容器或卡片。它的作用是在元素的背景上应用效果，而不影响元素内部的内容。\r\n   - **效果**：与 `filter` 类似，`backdrop-filter` 也可以应用模糊、饱和度、对比度等效果。但与 `filter` 不同，它仅影响背景，背景会在元素内容之后应用效果。\r\n\r\n   示例：\r\n   ```css\r\n   .container {\r\n     backdrop-filter: blur(10px) saturate(200%);\r\n   }\r\n   ```\r\n\r\n总结来说，`filter` 主要用于元素及其内容的图像效果，而 `backdrop-filter` 主要用于元素的背景图像效果。你可以根据需要选择使用哪种属性来实现所需的效果。请注意，这些属性在不同浏览器中的支持程度可能有所不同，因此在使用时要考虑兼容性。","type":"text/markdown","created":"20230919115216813","modified":"20230919115238169","tags":"Tailwindcss CSS"},{"title":"filter-refresh","text":"tw 的 filter 导致页面渲染太频繁了, 由于使用 tiddler 作为存储状态, 即使是一个 submenu 的变化, 都会引起刷新","type":"text/markdown","created":"20230929153649088","creator":"oeyoews","modified":"20230929153755761","modifier":"oeyoews","tags":"Plugins"},{"title":"FilterTiddlers","text":"```js\r\ntw.wiki.filterTiddlers('[tag[React]]')\r\n```\r\n\r\n```js\r\n$tw.wiki.allTitles()\r\n```\r\n\r\n```js\r\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget,\r\n\tLinkWidget = require(\"$:/core/modules/widgets/link.js\").link,\r\n\tButtonWidget = require(\"$:/core/modules/widgets/button.js\").button,\r\n\tElementWidget = require(\"$:/core/modules/widgets/element.js\").element;\r\n```","type":"text/markdown","created":"20230613013446036","creator":"oeyoews","modified":"20230726045248463","modifier":"oeyoews","tags":"TiddlyWiki Plugins"},{"title":"find-method","text":"`Array.prototype.find()` 方法是 JavaScript 数组的一个内置方法，用于在数组中查找满足给定条件的第一个元素，并返回该元素。它的语法如下：\r\n\r\n```javascript\r\narray.find(callback(element[, index[, array]])[, thisArg])\r\n```\r\n\r\n参数说明：\r\n- `callback`：回调函数，用来测试每个元素是否满足某个条件。该函数接收三个参数：\r\n  - `element`：当前正在被测试的数组元素。\r\n  - `index`（可选）：当前被测试元素的索引。\r\n  - `array`（可选）：调用 `find` 方法的数组。\r\n- `thisArg`（可选）：执行回调函数时使用的 `this` 值。\r\n\r\n返回值：\r\n- 如果找到满足条件的元素，则返回该元素。\r\n- 如果没有找到满足条件的元素，则返回 `undefined`。\r\n\r\n示例代码：\r\n\r\n```javascript\r\nconst numbers = [1, 2, 3, 4, 5];\r\n\r\n// 查找第一个大于 3 的数\r\nconst result = numbers.find((num) => num > 3);\r\nconsole.log(result); // 输出: 4\r\n\r\n// 查找第一个索引为偶数的数\r\nconst evenIndexNum = numbers.find((num, index) => index % 2 === 0);\r\nconsole.log(evenIndexNum); // 输出: 1\r\n\r\n// 在对象数组中查找 name 属性为 \"Alice\" 的对象\r\nconst users = [\r\n  { name: \"Alice\", age: 25 },\r\n  { name: \"Bob\", age: 30 },\r\n  { name: \"Charlie\", age: 35 },\r\n];\r\nconst user = users.find((user) => user.name === \"Alice\");\r\nconsole.log(user); // 输出: { name: \"Alice\", age: 25 }\r\n```\r\n\r\n`find()` 方法在找到符合条件的元素后会停止搜索，不会继续遍历整个数组。如果需要查找所有满足条件的元素，可以使用 `filter()` 方法。","type":"text/markdown","created":"20230721155835445","creator":"oeyoews","modified":"20230726045248463","modifier":"oeyoews","tags":"JavaScript"},{"title":"findport","text":"```js\nimport net from 'net';\n\n/**\n * find a free port \n * 由于端口号使用环境变量配置，避免pm2后台运行的tw实例和 dev环境下端口冲突的情况， 并且同时可以运行多个实例\n * @note: only works on linux\n * @param {number} [startingPort=8000]\n * @returns {Promise<number>} port number\n */\nexport default function findPort(startingPort = 8000) {\n  startingPort = Number(startingPort);\n  return new Promise((resolve, reject) => {\n    const server = net.createServer();\n\n    server.on('error', (err) => {\n      if (err.code === 'EADDRINUSE') {\n        findPort(startingPort + 1)\n          .then((port) => resolve(port))\n          .catch(reject);\n      } else {\n        reject(err);\n      }\n    });\n\n    server.listen(startingPort, () => {\n      server.close(() => {\n        resolve(startingPort);\n      });\n    });\n  });\n}\n```","type":"text/markdown","created":"20231019233757733","creator":"Lenovo","modified":"20231019233810453","modifier":"Lenovo","tags":""},{"title":"firefox-pwa","text":"firefox 不支持 pwa installation","type":"text/markdown","created":"20231001124625761","creator":"oeyoews","modified":"20231001124703808","modifier":"oeyoews","tags":"thoughts"},{"title":"firefox-smoothscroll","text":"firefox 不支持 smoothscroll, 但是上面显示的是开启了的","type":"text/markdown","created":"20231003021743838","creator":"oeyoews","modified":"20231018062534894","modifier":"Lenovo","tags":"browser"},{"title":"first-letter","text":"<p class=\"\r\n  first-letter:text-4xl first-letter:font-bold\r\n  first-letter:mr-3 first-letter:float-left\r\n\">\r\n  策划蝴蝶 m demo dem o Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  that says \"New York Public Library\"? Well that may not mean anything to you,\r\n  but that means a lot to me. One whole hell of a lot.\r\n</p>\r\n\r\n<p class=\"\r\n  first-letter:text-4xl first-letter:font-bold\r\n  first-letter:mr-3 first-letter:float-left\r\n\">\r\n  策划蝴蝶 m demo dem o Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  Well, let me tell you something, funny boy. Y'know that little stamp, the one\r\n  that says \"New York Public Library\"? Well that may not mean anything to you,\r\n  but that means a lot to me. One whole hell of a lot.\r\n</p>","type":"text/markdown","created":"20230711023859596","creator":"oeyoews","modified":"20230726045248464","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"flex-col","text":"`flex-col`是 Tailwind CSS 中的一个类名，用于创建一个 Flex 容器，并将其中的元素垂直堆叠（按列排列）。\r\n\r\n具体来说，`flex-col`类名表示将元素的主轴方向设置为垂直方向。默认情况下，Flex 容器的主轴方向是水平方向。通过添加`flex-col`类名，您可以改变主轴方向为垂直方向，并使其中的元素按列排列。\r\n\r\n当您将`flex-col`类名应用于一个元素时，该元素及其子元素将以列的方式从上到下排列。这意味着元素将按照文档流从上到下依次排列，而不是水平方向上的行排列。\r\n\r\n下面是一个示例，展示如何使用`flex-col`类名创建一个垂直堆叠的 Flex 容器：\r\n\r\n```html\r\n<div class=\"flex flex-col\">\r\n  <div>元素1</div>\r\n  <div>元素2</div>\r\n  <div>元素3</div>\r\n</div>\r\n```\r\n\r\n在上述示例中，`flex-col`类名应用于外部的`<div>`元素，它成为了一个垂直堆叠的 Flex 容器。其中的子元素将按照从上到下的顺序排列。\r\n\r\n通过使用`flex-col`类名，您可以更改 Flex 容器的主轴方向，以实现垂直排列的布局效果。","type":"text/markdown","created":"20230612045112586","creator":"oeyoews","modified":"20230726045248465","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"flex-wrap","text":"CSS 的 flex-wrap 属性指定 flex 元素单行显示还是多行显示。如果允许换行，这个属性允许你控制行的堆叠方向。","type":"text/markdown","created":"20231027053132943","creator":"Lenovo","modified":"20231027053157242","modifier":"Lenovo","tags":"CSS","url":"https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap"},{"title":"flex-wrap-between","text":"<div><blockquote class=\"mb-4 border-l-[3px] px-4 py-3\" style=\"border-left-color: #0fc27e;background-color: rgba(100, 211, 169, 0.15);\"><p class=\"mb-2\">以前啊，我们都向往着，可以拥有更好的未来；现在啊，我们回头看，曾经的岁月竟然就是我们的巅峰了。</p><div class=\"flex flex-wrap text-sm text-base-content/60 md:justify-between\"><div class=\"mb-2 w-full md:mb-0 md:w-auto\"><span class=\"mr-2\">发布于</span>28 天前</div><div class=\"w-full text-right md:ml-auto md:w-auto\"><div>出自“你也走了很远的路吧”</div></div></div></blockquote></div>","type":"text/markdown","created":"20231027075046903","creator":"Lenovo","modified":"20231027075134326","modifier":"Lenovo","tags":"Tailwindcss"},{"title":"form","text":"HTML 中的`<form>`元素用于创建一个包含交互式表单的区域，用户可以在该表单中输入数据并将其提交给服务器进行处理。`<form>`元素是 HTML 中最重要的表单元素之一，它允许用户与网页进行交互，发送数据并执行各种操作。\r\n\r\n以下是`<form>`元素的一般结构：\r\n\r\n```html\r\n<form action=\"处理表单的URL\" method=\"提交方法\">\r\n  <!-- 表单内容 -->\r\n</form>\r\n```\r\n\r\n`<form>`元素有两个重要的属性：\r\n\r\n- `action`：指定表单数据提交的 URL。当用户提交表单时，数据将被发送到该 URL 进行处理。这通常是服务器端脚本的 URL，可以在该脚本中对表单数据进行处理、验证或保存。例如，`action=\"process-form.php\"`将表单数据提交到名为\"process-form.php\"的服务器端脚本进行处理。\r\n\r\n- `method`：指定提交表单数据的 HTTP 方法。常见的方法有\"GET\"和\"POST\"。\"GET\"方法将表单数据附加在 URL 的末尾并发送给服务器。这对于请求数据或执行查询非常有用。\"POST\"方法将表单数据作为 HTTP 请求的一部分发送给服务器，并且不会在 URL 中可见。这对于提交敏感或较大量的数据更为常见。\r\n\r\n`<form>`元素内可以包含各种表单元素，例如输入字段、复选框、单选按钮、文本区域等。这些表单元素将用于收集用户输入的数据。\r\n\r\n以下是一个包含常见表单元素的示例：\r\n\r\n```html\r\n<form action=\"process-form.php\" method=\"POST\">\r\n  <label for=\"name\">姓名：</label>\r\n  <input type=\"text\" id=\"name\" name=\"name\" required>\r\n\r\n  <label for=\"email\">邮箱：</label>\r\n  <input type=\"email\" id=\"email\" name=\"email\" required>\r\n\r\n  <label for=\"message\">留言：</label>\r\n  <textarea id=\"message\" name=\"message\" rows=\"4\" cols=\"50\"></textarea>\r\n\r\n  <input type=\"submit\" value=\"提交\">\r\n</form>\r\n```\r\n\r\n在这个示例中，当用户点击提交按钮时，表单数据将被发送到\"process-form.php\"进行处理。表单包含了一个文本输入字段（姓名）、电子邮件输入字段、一个文本区域（留言）以及一个提交按钮。","type":"text/markdown","created":"20230626022731213","creator":"oeyoews","modified":"20230726045248466","modifier":"oeyoews","tags":"HTML"},{"title":"form-disabled-readonly","text":"如果 form 里面有 disable, 则 form 的 submit 全部不能用, 使用 readonly 代替\r\n\r\n如果给 button 加一个 listener, 你会发现, 回车的时候, button 的点击事件也被触发了(仅仅只会触发第一个捕获到的 submit 事件 btn1)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width\" />\r\n    <title>Index 17</title>\r\n  </head>\r\n  <body>\r\n    <form id=\"form\" type=\"submit\">\r\n      <button type=\"submit\" readonly=\"readonly\">点击</button>\r\n      <input type=\"text\" value=\"\" name=\"message\" />\r\n    </form>\r\n  </body>\r\n  <script charset=\"utf-8\">\r\n    const button = document.querySelector(\"button\");\r\n    button.addEventListener(\"click\", function () {\r\n      console.log(\"点击\");\r\n    });\r\n    var form = document.querySelector(\"#form\");\r\n    form.addEventListener(\"submit\", function (event) {\r\n      event.preventDefault();\r\n      console.log(\"提交\");\r\n    });\r\n  </script>\r\n</html>\r\n```\r\n\r\n```html \r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width\" />\r\n    <title>Index 17</title>\r\n  </head>\r\n  <body>\r\n    <form id=\"form\" type=\"submit\">\r\n      <input type=\"text\" value=\"\" name=\"message\" />\r\n      <button id=\"btn2\" type=\"submit\">点击</button>\r\n      <button id=\"btn1\" type=\"submit\">点击</button>\r\n    </form>\r\n  </body>\r\n  <script charset=\"utf-8\">\r\n    const button = document.querySelector(\"#btn1\");\r\n    button.addEventListener(\"click\", function () {\r\n      console.log(\"点击 btn1\");\r\n    });\r\n    const anotherbutton = document.querySelector(\"#btn2\");\r\n    anotherbutton.addEventListener(\"click\", function () {\r\n      console.log(\"点击 btn2\");\r\n    });\r\n    var form = document.querySelector(\"#form\");\r\n    form.addEventListener(\"submit\", function (event) {\r\n      event.preventDefault();\r\n      console.log(\"提交\");\r\n    });\r\n  </script>\r\n</html>\r\n```","type":"text/markdown","created":"20230908093847496","creator":"oeyoews","modified":"20230908095150286","modifier":"oeyoews","tags":"JavaScript HTML"},{"title":"form-submit","text":"```html\r\n<!DOCTYPE html>\r\n<html lang=\"es\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n    <title>Index 19</title>\r\n  </head>\r\n  <body>\r\n    <form id=\"userForm\">\r\n      <input type=\"text\" name=\"name\" />\r\n      <input type=\"submit\" />\r\n    </form>\r\n    <script charset=\"utf-8\">\r\n      document\r\n        .querySelector(\"#userForm\")\r\n        .addEventListener(\"submit\", function (e) {\r\n          e.preventDefault();\r\n          console.log(\"hi\");\r\n        });\r\n    </script>\r\n  </body>\r\n</html>\r\n```","type":"text/markdown","created":"20230719114544033","creator":"oeyoews","modified":"20230726045248467","modifier":"oeyoews","tags":"HTML"},{"title":"freepik-images","text":"<https://www.freepik.com/free-photos-vectors/background>","type":"text/markdown","created":"20230412012102830","creator":"oeyoews","modified":"20230412012111962","modifier":"oeyoews","tags":""},{"title":"full-type-support-with-plain-javascript","text":"## 使用纯 JavaScript 获得完整的类型支持\n\n* 这听起来是不是很熟悉：你想写一个小脚本——无论是用于网络、命令行工具还是其他任何东西——你从 JavaScript 开始……直到你想起编写没有类型的代码是多么痛苦。因此，您将文件从 重命名.js 为.ts… 并意识到您已经打开了一罐蠕虫。\n\n* 如果您正在为网站或图书馆编写代码，那么您需要进行编译步骤。如果你正在构建一个 CLI 脚本，你可以求助于 Deno（它支持开箱即用的 TypeScript），但是你需要设置你的 IDE 来理解 Deno API，而且混合和匹配 Deno 和节点并不总是那么容易。\n\n* 一旦一切都在本地运行，您需要考虑如何分发您的代码。你检查你的编译.js 文件吗？您是否创建了一个 CI 管道来自动编译您的.ts 文件？如果您正在编写一个库，您如何发布您的库以便其他项目可以使用它？\n\n## 你实际上并不需要 TypeScript\n\n> 问题是您无需编写 TypeScript 即可获得静态类型分析！\n\n* 通过使用 JSDoc，您可以在 JavaScript 中获得 TypeScript 的所有好处\n\n* TypeScript 提供的是静态类型系统。这意味着类型信息对运行代码没有影响。当你的 TypeScript 被执行时，所有的类型信息都完全丢失了（这就是为什么你不能在不编写类型保护的情况下测试变量是否属于某种类型的原因）。\n\n* 这也意味着 TypeScript 只是提供给 TypeScript 分析器的附加类型信息，对运行代码的 JavaScript 引擎没有任何意义。当您将 TypeScript 编译为 JavaScript 时，它基本上只是从您的代码中删除所有类型信息，因此它再次成为有效的 JavaScript 代码。\n\n## JSDoc\n\n在 25 年前 JavaScript 诞生的三年后，JSDoc 被引入作为一种注释 JavaScript 代码的方式。它是一种形式化的标记语言，允许 IDE 在开发人员看到功能时为他们提供额外的上下文。\n\n大多数语言中都存在类似的注释标记，我相信您已经知道了。这是它的样子：\n\n```js\n/**\n * This is the JSDOC block. IDEs will show this text when you hover the\n * printName function.\n *\n * @param {string} name\n */\nfunction printName(name) {\n  console.log(name)\n}\n```\n\n很少有人知道，JSDoc 是您充分利用 TypeScript 所需要的全部。TypeScript 分析器理解用 JSDoc 编写的类型，并为您提供与.ts 文件相同的静态分析。\n\nJSDoc 中类型的语法\n我不会在这里提供语法的完整文档。最重要的是你知道，几乎所有你可以在.ts 文件中做的事情，你都可以用 JSDoc 做。但这里有几个例子：\n\n具有本机类型的函数参数：\n\n```js\n/**\n * @param {string} a\n * @param {number} b\n */\nfunction foo(a, b) {}\n使用 TypeScript 开箱即用的类型：\n\n/**\n * @param {HTMLElement} element\n * @param {Window} window\n */\nfunction foo(element, window) {}\n\n/** @type {number[]} */\nlet years\n定义对象字面量和函数：\n\n/** @type {{ name: string; age: number }} */\nlet person\n\n/** @type {(s: string, b: boolean) => void} */\nlet myCallback\n*.d.ts从文件导入类型：\n\n/** @param {import('./types').User} user */\nconst deleteUser = (user) => {}\n定义一个类型供以后使用：\n\n/**\n * @typedef {object} Color\n * @property {number} chroma\n * @property {number} hue\n */\n\n/** @type {Color[]} */\nconst colors = [\n  { chroma: 0.2, hue: 262 },\n  { chroma: 0.2, hue: 28.3 },\n]\n有关详尽列表，请参阅官方TypeScript JSDoc 文档。\n```\n\n如果您有复杂的类型，您仍然可以创作您的*.d.ts 文件并将它们导入您的 JSDoc 注释中。\n\ntsconfig.json 请注意，您仍然需要为打字稿设置您的项目（和 IDE），并且您需要使用编译器选项创建一个文件 allowJs 并将 checkJs 其设置为 true：\n\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"allowJs\": true,\n    \"checkJs\": true\n    // ...\n  }\n}\n```\n什么时候写 TypeScript\n尽管完全使用 JSDoc 进行类型声明是可能的，但这并不是最方便的。TypeScript 语法更好，重复更少。\n\nTypeScript 团队创建了一个“类型作为注释”的 ECMAScript 提案，允许您编写 TypeScript 并在 JavaScript 引擎中运行它而无需修改（JavaScript 引擎会将这些类型注释视为注释。）\n\n但在这个提案被接受之前，我们一直坚持使用 JSDoc 或 TypeScript 工具链的决定。\n\n所以现在我的建议是：当你处理一个无论如何都有编译步骤的项目时，使用 TypeScript 没有任何缺点。这包括您想要优化生产脚本的典型网站。\n\n但如果您不需要编译步骤，那么坚持使用 JSDoc 类型注释可能更容易。这方面的例子是库和简单的脚本。\n\n> ref: https://www.pausly.app/blog/full-type-support-with-plain-javascript","type":"text/markdown","created":"20230604141122805","creator":"oeyoews","modified":"20231017085922159","modifier":"Lenovo","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&full-type-support-with-plain-javascript","tags":"JavaScript"},{"title":"fullscreen","text":"在 Web 开发中，浏览器不允许页面自动全屏，这是为了保证用户体验和安全性。如果网站可以在未经用户授权的情况下自动全屏，那么恶意网站就有可能利用这个漏洞对用户进行攻击（如欺诈、诱导下载等），从而危害用户的利益。\r\n\r\n因此，浏览器对于自动全屏行为采取了一系列防护措施，在浏览器中无法通过代码实现页面自动全屏。如果您希望让用户进入全屏模式，应该通过用户手动操作（如点击按钮、执行特定操作等）触发 Fullscreen API（全屏 API），以获取用户的明确授权。\r\n\r\n需要注意的是，即使用户已经进入全屏模式，浏览器也会在用户滑动页面等操作时自动退出全屏。这是浏览器的默认行为，无法通过代码控制。\r\n\r\n---\r\n在 Web 开发中，元素全屏有两种：内部全屏和外部全屏。\r\n\r\n内部全屏\r\n内部全屏是指将某个元素全屏显示，此时元素内的其他元素也会随之全屏。这种方式常用于视频播放器、幻灯片等场景，用户只需看到特定的内容而不会被其他 UI 元素干扰。\r\n\r\n外部全屏\r\n外部全屏是指将某个元素及其外部区域全屏显示，此时元素内的其他元素不会全屏显示。这种方式适用于需要展示较大的元素（如地图、图片等）并且需要让用户看到周围的环境。\r\n\r\n通过 Fullscreen API（全屏 API）可以实现以上两种类型的元素全屏，具体实现方式请参考我之前的回答。\r\n\r\n需要注意的是，使用全屏效果应该谨慎，应根据具体情况选择合适的全屏方式。同时，为了提高用户体验，最好能够给用户提供明显的退出全屏按钮，方便用户随时退出全屏模式。","type":"text/markdown","created":"20230430140643824","creator":"oeyoews","modified":"20230430140704138","modifier":"oeyoews","tags":""},{"title":"fullscreen-browsers","text":"```javascript\r\n// ==UserScript==\r\n// @name         Disable F Key in Input Fields and Toggle Full Screen\r\n// @namespace    http://tampermonkey.net/\r\n// @version      0.1\r\n// @description  Disables the F key in all input fields on all websites and toggles full screen mode when pressing the F key outside of input fields.\r\n// @author       oeyoews\r\n// @match        *://*/*\r\n// @grant        none\r\n// ==/UserScript==\r\n\r\n(function() {\r\n    'use strict';\r\n\r\n    document.addEventListener('keydown', function(e) {\r\n        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {\r\n            return;\r\n        }\r\n        if (e.key === 'F') {\r\n            e.preventDefault();\r\n            if (document.fullscreenElement) {\r\n                document.exitFullscreen();\r\n            } else {\r\n                document.documentElement.requestFullscreen();\r\n            }\r\n        }\r\n    });\r\n})();\r\n```\r\n\r\n```javascript\r\n(function() {\r\n    'use strict';\r\n\r\n    let altKeyPressed = false;\r\n\r\n    document.addEventListener('keydown', function(e) {\r\n        if (e.key === 'Alt') {\r\n            altKeyPressed = true;\r\n        }\r\n        if (e.keyCode === 70 && altKeyPressed) {\r\n            e.preventDefault();\r\n            if (document.fullscreenElement) {\r\n                document.exitFullscreen();\r\n            } else {\r\n                document.documentElement.requestFullscreen();\r\n            }\r\n        }\r\n    });\r\n\r\n    document.addEventListener('keyup', function(e) {\r\n        if (e.key === 'Alt') {\r\n            altKeyPressed = false;\r\n        }\r\n    });\r\n})();\r\n```","type":"text/markdown","created":"20230424161844327","creator":"oeyoews","modified":"20230429080021953","modifier":"oeyoews","tags":"JavaScript"},{"title":"fullstack-framework","text":"Next.js 之于 React 就像 Nuxt.js 之于 Vue。 \r\n\r\nNuxt.js 和 Next.js 都是针对其相应的主流前端框架（Vue 和 React）的服务端渲染解决方案。它们都提供了一些常见的功能，如代码分割、自动预取和服务器端呈现等，以简化复杂的开发任务并提高性能。\r\n\r\n同时，Next.js 和 Nuxt.js 都不是必须使用的，您可以使用原始的 React 或 Vue 来构建应用程序。但是，如果您需要更好的 SEO、更快的首次加载时间或更好的用户体验，则可能需要考虑使用 Next.js 或 Nuxt.js 等服务端渲染解决方案。","type":"text/markdown","created":"20230504012943989","creator":"oeyoews","modified":"20230504013001780","modifier":"oeyoews","tags":"React"},{"title":"gallary-fit","text":"<div class=\"mx-auto max-w-5xl w-full columns-2 space-y-2\">\r\n\t<img src=\"https://images.unsplash.com/photo-1690673821592-91154209cd27?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxlZGl0b3JpYWwtZmVlZHwxOXx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=600&q=60\" class=\"rounded\"/>\r\n\t\r\n<img src=\"https://plus.unsplash.com/premium_photo-1674062990194-2f720a6c6b3a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxlZGl0b3JpYWwtZmVlZHwxMnx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=600&q=60\" />\r\n<img src=\"https://images.unsplash.com/photo-1505118380757-91f5f5632de0?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8c2VhfGVufDB8fDB8fHww&auto=format&fit=crop&w=600&q=60\" />\r\n<img src=\"https://images.unsplash.com/photo-1457195740896-7f345efef228?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTB8fHNlYXxlbnwwfHwwfHx8MA%3D%3D&auto=format&fit=crop&w=600&q=60\" />\r\n</div>","type":"text/markdown","created":"20230808022244447","creator":"oeyoews","modified":"20230825151708820","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"gallery","text":"<$gallery />","type":"text/markdown","created":"20231020044740770","creator":"Lenovo","modified":"20231102042045647","modifier":"Lenovo","tags":""},{"title":"generate-vscode-snippets","text":"https://snippet-generator.app/","type":"text/markdown","created":"20230901052412549","creator":"oeyoews","modified":"20230901052425876","modifier":"oeyoews","tags":""},{"title":"get-current-title","text":"```js\r\nthis.getVariable('currentTiddler');\r\n```","type":"text/markdown","created":"20230929153525630","creator":"oeyoews","modified":"20230929153642962","modifier":"oeyoews","tags":"Plugins"},{"title":"get-data","text":"> 获取数据\r\n\r\n```js\r\n/*\r\nGet the content of a tiddler as a JavaScript object. How this is done depends on the type of the tiddler:\r\n\r\napplication/json: the tiddler JSON is parsed into an object\r\napplication/x-tiddler-dictionary: the tiddler is parsed as sequence of name:value pairs\r\n\r\nOther types currently just return null.\r\n\r\ntitleOrTiddler: string tiddler title or a tiddler object\r\ndefaultData: default data to be returned if the tiddler is missing or doesn't contain data\r\n\r\nNote that the same value is returned for repeated calls for the same tiddler data. The value is frozen to prevent modification; otherwise modifications would be visible to all callers\r\n*/\r\nexports.getTiddlerDataCached = function(titleOrTiddler,defaultData) {\r\n\tvar self = this,\r\n\t\ttiddler = titleOrTiddler;\r\n\tif(!(tiddler instanceof $tw.Tiddler)) {\r\n\t\ttiddler = this.getTiddler(tiddler);\r\n\t}\r\n\tif(tiddler) {\r\n\t\treturn this.getCacheForTiddler(tiddler.fields.title,\"data\",function() {\r\n\t\t\t// Return the frozen value\r\n\t\t\tvar value = self.getTiddlerData(tiddler.fields.title,undefined);\r\n\t\t\t$tw.utils.deepFreeze(value);\r\n\t\t\treturn value;\r\n\t\t}) || defaultData;\r\n\t} else {\r\n\t\treturn defaultData;\r\n\t}\r\n};\r\n\r\n/*\r\nAlternative, uncached version of getTiddlerDataCached(). The return value can be mutated freely and reused\r\n*/\r\nexports.getTiddlerData = function(titleOrTiddler,defaultData) {\r\n\tvar tiddler = titleOrTiddler,\r\n\t\tdata;\r\n\tif(!(tiddler instanceof $tw.Tiddler)) {\r\n\t\ttiddler = this.getTiddler(tiddler);\r\n\t}\r\n\tif(tiddler && tiddler.fields.text) {\r\n\t\tswitch(tiddler.fields.type) {\r\n\t\t\tcase \"application/json\":\r\n\t\t\t\t// JSON tiddler\r\n\t\t\t\treturn $tw.utils.parseJSONSafe(tiddler.fields.text,defaultData);\r\n\t\t\tcase \"application/x-tiddler-dictionary\":\r\n\t\t\t\treturn $tw.utils.parseFields(tiddler.fields.text);\r\n\t\t}\r\n\t}\r\n\treturn defaultData;\r\n};\r\n```","type":"text/markdown","created":"20230929074946530","creator":"oeyoews","modified":"20230929075021366","modifier":"oeyoews","tags":"Plugins"},{"title":"get-github-user-info","text":"https://api.github.com/users/oeyoews","type":"text/markdown","created":"20230614022529006","creator":"oeyoews","modified":"20230726045248471","modifier":"oeyoews"},{"title":"get-port","text":"get-port 和 get-port-please 都是 Node.js 中的模块，用于获取可用的端口号。它们的主要区别在于 get-port-please 是 get-port 的扩展，提供了额外的功能和选项。\n\nget-port 可以自动查找当前系统中未使用的端口号，并返回一个 Promise 对象，该对象的解析值为可用的端口号。使用 get-port，你可以轻松地获取一个可用的端口号，而无需手动查找。\n\nget-port-please 基于 get-port，提供了额外的功能，例如：\n\n1. 可以指定端口号范围，只在指定的端口范围内查找可用端口号。\n\n2. 可以指定要跳过的端口号列表，这些端口号将从查找中排除。\n\n3. 可以选择使用 IPv4 或 IPv6 地址来查找可用端口号。\n\n4. 可以指定最大尝试次数和等待时间，以控制查找可用端口号的时间。\n\n总之，get-port-please 提供了更多的灵活性和选项，使得端口号的查找更加方便和可控。但如果你只需要简单地获取一个可用的端口号，那么使用 get-port 就足够了。","type":"text/markdown","created":"20231030022218860","creator":"Lenovo","modified":"20231030022228494","modifier":"Lenovo","tags":"JavaScript"},{"title":"getData-getText","text":"```js\r\n  const emojis = $tw.wiki.getTiddlerData(\r\n    '$:/plugins/oeyoews/neotw-emoji-picker/emojis.json',\r\n  );\r\n```\r\n\r\n:::\r\n```js \r\n$tw.getTiddlerText('')\r\n```\r\n:::","type":"text/markdown","created":"20230616115549649","creator":"oeyoews","modified":"20230726045248471","modifier":"oeyoews","tags":"Plugins TiddlyWiki"},{"title":"GFM","text":"* <https://github.github.com/gfm/>","type":"text/markdown","created":"20230318031058445","creator":"oeyoews","modified":"20230318031122089","modifier":"oeyoews","tags":""},{"title":"gh-page-cache","text":"* gh-page 浏览器缓存更像是服务端缓存, 并且 assign domain, 很慢, 建议使用 vercel","type":"text/markdown","created":"20231026042040753","creator":"Lenovo","modified":"20231026042130521","modifier":"Lenovo","tags":""},{"title":"git-https-ssh","text":"<$iconify icon=\"simple-icons:git\" /> Git 中的 HTTPS 和 SSH 是两种不同的协议，用于与远程存储库进行通信。它们都允许您将代码上传到和下载代码从远程存储库，但有一些重要的区别：\n\n1. 认证方式：\n   - HTTPS：使用 HTTPS 时，您需要提供用户名和密码来验证您的身份。这意味着您需要在每次与远程存储库通信时输入凭据，除非您启用了凭据缓存工具。\n   - SSH：SSH 使用密钥来进行身份验证。您生成一对密钥，将公钥添加到您的远程存储库账户，而私钥留存在您的本地计算机上。这样，每次与远程存储库通信时，您的私钥将用于验证您的身份，无需输入密码。\n\n2. 安全性：\n   - HTTPS：HTTPS 通常需要输入密码，因此可能会受到密码猜测或暴力破解的威胁。但是，它通过 TLS/SSL 提供了加密的通信。\n   - SSH：SSH 使用公钥加密来验证身份，因此在这方面更安全。私钥应保持机密，以防止未经授权的访问。\n\n3. 配置和使用：\n   - HTTPS：HTTPS 通常更容易设置，因为它不涉及生成和管理密钥对。只需提供用户名和密码即可使用。\n   - SSH：SSH 需要一些额外的配置，包括生成密钥对和将公钥添加到您的远程存储库账户中。但一旦设置好，它通常更方便和安全。\n\n总的来说，选择使用 HTTPS 还是 SSH 取决于您的需求和安全性偏好。如果您更关心安全性，建议使用 SSH。如果您更喜欢简单的配置和使用方式，可以选择 HTTPS。","type":"text/markdown","created":"20231010050748986","creator":"Lenovo","modified":"20231018062602920","modifier":"Lenovo","tags":"前端"},{"title":"github-push","text":"use ssh(需要密钥)比密码快 ","type":"text/markdown","created":"20231009164532356","creator":"Lenovo","modified":"20231009164612151","modifier":"Lenovo","tags":"git"},{"title":"github-rename-repo","text":"* 如果重命名, 所有旧的链接会重定向新的地址","type":"text/markdown","created":"20230830064840777","creator":"oeyoews","modified":"20230830064929263","modifier":"oeyoews","tags":""},{"title":"global-order","text":"global 属于 load-modules 里面 [[startup-order.svg]]","type":"text/markdown","created":"20230923124138472","creator":"oeyoews","modified":"20230923124238687","modifier":"oeyoews","tags":"TiddlyWiki Plugins"},{"title":"gnome-kernel-bug","text":"> 最近总是会卡死，怀疑是 gnome 的锅， 暂时没时间排查了， 要么降级到 5.15 or plasma, 要么直接 win\r\n\r\n> 一般是内核或者硬件的锅\r\n","type":"text/markdown","created":"20231003110613678","creator":"oeyoews","modified":"20231003110914682","modifier":"oeyoews","tags":"gnome"},{"title":"gnome-terminal","text":"gnome-shell terminal not support literal feature","type":"text/markdown","created":"20230418021651982","creator":"oeyoews","modified":"20230418021710390","modifier":"oeyoews","tags":""},{"title":"google-chrome-bug","text":"* google chrome have some cache bug for password","type":"text/markdown","created":"20230323043917159","creator":"oeyoews","modified":"20230323043945204","modifier":"oeyoews","tags":""},{"title":"google-updated","text":"> Skipping service worker no-op fetch handlers.\r\n\r\n* google-chrome 112 之后， 似乎很多站点都能进行安装了\r\n","type":"text/markdown","created":"20230409112902800","creator":"oeyoews","modified":"20230409113319821","modifier":"oeyoews","tags":""},{"title":"Gource","text":"Gource is an open-source software version control visualization tool that provides a visual representation of the development activity within a software project. It takes the repository history and produces an animated tree-like structure that displays the files being modified, added, or removed over time.\r\n\r\nGource supports various version control systems such as Git, Mercurial, and Subversion. It uses the repository data to create a visualization where each file is represented as a node, and the nodes are connected based on their relationships and changes over time. The visualization is typically displayed as a video or can be rendered to an image sequence.\r\n\r\nThe nodes in the Gource visualization typically represent files, and their size and color can be used to indicate the number of changes, the number of lines of code, or other metrics. Developers' avatars can also be included, and their movements show their contributions to the project.\r\n\r\nGource provides a visually appealing way to explore the evolution of a software project, identify active areas of development, and understand the collaboration patterns among developers. It can be useful for presentations, demonstrating progress, or simply as a way to visualize the history of a project.\r\n\r\nTo use Gource, you would typically need to have it installed on your computer and have the repository you want to visualize locally. You can then run Gource with the appropriate parameters, such as specifying the repository location, customizing the visualization options, and outputting the result as a video or image sequence.","type":"text/markdown","created":"20230613012513219","creator":"oeyoews","modified":"20230726045248471","modifier":"oeyoews"},{"title":"gradients-png","text":"<https://gradienthunt.com/popular>","type":"text/markdown","created":"20230429023750288","creator":"oeyoews","modified":"20230429023807379","modifier":"oeyoews","tags":"Sites"},{"title":"grayscale","text":"灰度（Grayscale）是一种视觉效果，通常指的是一个图像、设计或界面元素只使用灰色色调，而没有彩色。在灰度图像中，每个像素的亮度由黑色到白色之间的不同灰度值来表示，通常使用灰度值的百分比来表示亮度。\r\n\r\n灰度与灰色调有所区别，灰色调是指一组不同的灰色色调，每个色调的颜色值略有不同，可以用于设置背景颜色、文本颜色和边框颜色等，而灰度则是指只使用灰色色调来呈现视觉效果。\r\n\r\n在设计中，使用灰度可以帮助设计师和开发者更好地把握视觉效果和设计感，特别是在需要突出文本或其他界面元素的情况下，使用灰度可以更好地突出重点。同时，灰度图像和界面元素也有一种简洁、干净的美感，可以提高用户的阅读体验和视觉享受。\r\n\r\n总之，灰度和灰色调都是视觉设计中常用的效果，它们在不同的设计场景和需求中有不同的应用和表现。","type":"text/markdown","created":"20230608044342126","creator":"oeyoews","modified":"20230726045248472","modifier":"oeyoews"},{"title":"grid-layout","text":"Grid 是 CSS 中的一种布局方式，可以将页面划分为行和列的网格，让我们更方便地进行网页布局。Grid 布局可以将一个网格容器（grid container）中的内容划分为多个网格单元（grid items），每个网格单元可以跨越多个行和列。\r\n\r\nGrid 布局由以下几个概念组成：\r\n\r\n网格容器（grid container）：包含网格项目的容器，可以通过设置 display 属性为 grid 或 inline-grid 来创建。\r\n\r\n网格项目（grid item）：Grid 布局中的每个元素都被视为一个网格项目，可以通过将元素放置在网格容器中来创建。\r\n\r\n网格线（grid line）：划分网格的线条，可以是水平线或垂直线，每个网格单元有四条网格线，分别为上、下、左、右。\r\n\r\n网格轨道（grid track）：两个相邻的网格线之间的空间，可以是行轨道或列轨道。\r\n\r\n网格区域（grid area）：由四条网格线所围成的矩形区域，可以跨越多个行和列。\r\n\r\n通过设置网格容器的属性，我们可以控制网格的大小、间距、对齐等。例如，下面的 CSS 代码可以创建一个包含 4 个网格项的网格容器：\r\n\r\n```css\r\n.container {\r\n  display: grid;\r\n  grid-template-columns: 1fr 1fr;\r\n  grid-template-rows: 100px 100px;\r\n  grid-gap: 10px;\r\n}\r\n```\r\n在上面的代码中，我们使用了 grid-template-columns 和 grid-template-rows 属性来定义网格的列数和行数，并使用 grid-gap 属性来设置网格之间的间距。这样，容器中的内容就会被划分为 4 个网格单元，每个网格单元都有固定的大小和位置。我们可以使用 grid-column 和 grid-row 属性来控制网格单元占据的行和列，也可以使用 grid-area 属性来定义网格区域。","type":"text/markdown","created":"20230426012434581","creator":"oeyoews","modified":"20230426012503719","modifier":"oeyoews","tags":"CSS"},{"title":"group-usage","text":"<a href=\"#\" class=\"group block max-w-xs mx-auto rounded-lg p-6 bg-white ring-1 ring-slate-900/5 shadow-lg space-y-3 hover:bg-sky-500 hover:ring-sky-500\">\r\n  <div class=\"flex items-center space-x-3\">\r\n    <svg class=\"h-6 w-6 stroke-sky-500 group-hover:stroke-white\" fill=\"none\" viewBox=\"0 0 24 24\"><!-- ... --></svg>\r\n    <h3 class=\"text-slate-900 group-hover:text-white text-sm font-semibold\">New project</h3>\r\n  </div>\r\n  <p class=\"text-slate-500 group-hover:text-white text-sm\">Create a new project from a variety of starting templates.</p>\r\n</a>","type":"text/markdown","created":"20230725065159373","creator":"oeyoews","modified":"20230726045248472","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"handle-handler","text":"在 React 中，'handle'和'handler'是两个常用的命名惯例。\r\n\r\n'handle'通常被用作函数命名前缀，以表示此函数是用于处理某个事件或操作的回调函数。例如，一个名为 handleClick 的函数通常会在用户点击某个元素时被调用。\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\nfunction MyComponent() {\r\n  const handleClick = () => {\r\n    console.log('Button clicked');\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={handleClick}>Click Me</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n上面的示例中，handleClick 函数是响应用户点击按钮时调用的回调函数。\r\n\r\n而'handler'则通常指代一个对象或类的方法成员，用于处理某个任务或操作。例如，一个名为 submitHandler 的方法可能会在表单提交时被调用。\r\n\r\n```jsx\r\nimport React, { Component } from 'react';\r\n\r\nclass MyComponent extends Component {\r\n  submitHandler = (event) => {\r\n    event.preventDefault();\r\n    console.log('Form submitted');\r\n  };\r\n  \r\n  render() {\r\n    return (\r\n      <form onSubmit={this.submitHandler}>\r\n        <button type=\"submit\">Submit</button>\r\n      </form>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n上面的示例中，submitHandler 方法是 MyComponent 类的一个成员，用于在表单提交时避免默认行为，并输出日志消息。\r\n\r\n因此，'handle'和'handler'的区别主要在于使用上下文和语法，它们都是开发者中较为常见的代码规范之一。开发者应该在编写回调函数或处理程序时遵循这些规范，以提高代码的可读性和可维护性。","type":"text/markdown","created":"20230428083242299","creator":"oeyoews","modified":"20230428083316084","modifier":"oeyoews","tags":"React"},{"title":"handler","text":"在 React 中，一个事件处理函数（handler）是一个由程序员编写的函数，用于响应 React 组件中发生的事件，例如按钮点击、输入框变化等。\r\n\r\n当用户与组件进行交互时，React 会调用相应事件的处理函数，让应用程序可以根据用户的操作来更新组件状态、页面布局等。\r\n\r\n在 React 应用程序中，事件处理函数通常被作为组件的方法定义，然后在组件中通过绑定事件监听器的方式来关联到相应的 DOM 元素。例如，在 React 中定义一个处理按钮点击事件的函数如下：\r\n\r\n```jsx\r\nclass MyComponent extends React.Component {\r\n  handleClick() {\r\n    // 处理点击事件的代码\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <button onClick={this.handleClick}>点击我</button>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n在这个例子中，`handleClick` 方法定义了处理按钮点击事件的代码，然后在 `render` 方法中通过 `onClick` 属性将它绑定到按钮上。\r\n\r\n当用户点击按钮时，React 将自动调用 `handleClick` 方法，使应用程序能够响应相应的事件并执行相应的操作。\r\n\r\n总之，在 React 中，事件处理函数是一种由程序员编写的函数，用于响应组件中发生的事件，并通过绑定事件监听器的方式将它们关联到相应的 DOM 元素上。","type":"text/markdown","created":"20230428063441502","creator":"oeyoews","modified":"20230428063453986","modifier":"oeyoews","tags":"React"},{"title":"hayo","text":"<https://www.hayo.com/>","type":"text/markdown","created":"20230418081820862","creator":"oeyoews","modified":"20230418081833283","modifier":"oeyoews","tags":""},{"title":"heart-joh","text":"<svg width=\"48\" height=\"40.32\" viewBox=\"0 0 50 42\" fill=\"none\" style=\"transform: rotate(0deg);\"><defs><linearGradient id=\"active-gradient-snow\" x1=\"25\" y1=\"42\" x2=\"26.3796\" y2=\"0.0453673\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"hsl(353deg, 100%, 52%)\"></stop><stop offset=\"1\" stop-color=\"hsl(313deg, 100%, 52%)\"></stop></linearGradient><linearGradient id=\"inactive-gradient-snow\" x1=\"15\" y1=\"41\" x2=\"42\" y2=\"-1.5\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#666\" stop-opacity=\"0.4\"></stop><stop offset=\"1\" stop-color=\"#AAA\" stop-opacity=\"0.4\"></stop></linearGradient></defs><mask id=\"like-button-mask-snow\" mask-type=\"alpha\" maskUnits=\"userSpaceOnUse\" x=\"0\" y=\"0\" width=\"50\" height=\"42\"><path d=\"M13.2537 0.0255029C23.4033 0.0255029 25.0273 10.5191 25.0273 10.5191C25.0273 10.5191 26.6512 -0.60088 37.6129 0.0255029C44.3441 0.410148 48.7484 6.32169 48.9804 12.1981C49.7924 32.7656 28.7678 41.5 25.0273 41.5C21.2868 41.5 -0.549833 32.3459 1.07416 12.1981C1.54782 6.32169 6.29929 0.0255029 13.2537 0.0255029Z\" fill=\"#000000\"></path></mask><mask id=\"active-gradient-mask-snow\" mask-type=\"alpha\" maskUnits=\"userSpaceOnUse\" x=\"0\" y=\"0\" width=\"50\" height=\"42\"><polygon points=\"\r\n                0,42\r\n                50,42\r\n                50,42\r\n                0,42\r\n              \" fill=\"#000000\"></polygon></mask><g mask=\"url(#like-button-mask-snow)\"><path d=\"M13.2537 0.0255029C23.4033 0.0255029 25.0273 10.5191 25.0273 10.5191C25.0273 10.5191 26.6512 -0.60088 37.6129 0.0255029C44.3441 0.410148 48.7484 6.32169 48.9804 12.1981C49.7924 32.7656 28.7678 41.5 25.0273 41.5C21.2868 41.5 -0.549833 32.3459 1.07416 12.1981C1.54782 6.32169 6.29929 0.0255029 13.2537 0.0255029Z\" fill=\"url(#inactive-gradient-snow)\"></path><g mask=\"url(#active-gradient-mask-snow)\"><path d=\"M13.2537 0.0255029C23.4033 0.0255029 25.0273 10.5191 25.0273 10.5191C25.0273 10.5191 26.6512 -0.60088 37.6129 0.0255029C44.3441 0.410148 48.7484 6.32169 48.9804 12.1981C49.7924 32.7656 28.7678 41.5 25.0273 41.5C21.2868 41.5 -0.549833 32.3459 1.07416 12.1981C1.54782 6.32169 6.29929 0.0255029 13.2537 0.0255029Z\" fill=\"url(#active-gradient-snow)\"></path></g><g style=\"opacity: 1; transform: translate(0px, 0px);\"><circle cx=\"15\" cy=\"22\" r=\"2\" fill=\"#000000\" fill-opacity=\"0.4\"></circle><circle cx=\"35\" cy=\"22\" r=\"2\" fill=\"#000000\" fill-opacity=\"0.4\"></circle></g><g style=\"opacity: 0;\"><path d=\"M 13 23 Q 15 19, 17 23 \" stroke=\"#000000\" stroke-opacity=\"0.4\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"></path><path d=\"M 33 23 Q 35 19, 37 23 \" stroke=\"#000000\" stroke-opacity=\"0.4\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"></path></g><g><mask id=\"tongue-mask\" mask-type=\"alpha\" maskUnits=\"userSpaceOnUse\" x=\"20\" y=\"27\" width=\"11\" height=\"6\"><path d=\"M28.3333 27H21.6666C21.6666 27 20.0001 27 20 29C19.9999 31 22.3875 33 25 33C27.6125 33 30 31 30 29C30 27 28.3333 27 28.3333 27Z\" fill=\"#000000\" fill-opacity=\"0.4\"></path></mask><g mask=\"url(#tongue-mask)\" style=\"opacity: 0;\"><path d=\"M28.3333 27H21.6666C21.6666 27 20.0001 27 20 29C19.9999 31 22.3875 33 25 33C27.6125 33 30 31 30 29C30 27 28.3333 27 28.3333 27Z\" fill=\"#000000\" fill-opacity=\"1\"></path><circle cx=\"25\" cy=\"35\" r=\"5\" fill=\"#DB2C49\" fill-opacity=\"0.5\"></circle></g><path d=\"\r\n            M 20 30\r\n            Q 25 33.6 30 30\r\n          \" stroke=\"#000000\" stroke-opacity=\"0.4\" stroke-linecap=\"round\" style=\"opacity: 1;\"></path></g><g><path d=\"M53.5 18.5L47 5C47 5 53.5 31.9722 24.5 36C-4.5 40.0278 1 1.5 1 1.5L-6.5 25L8.00002 44.5L15.5 52L39 49L53.5 18.5Z\" fill=\"black\" fill-opacity=\"0.1\"></path><path d=\"M6.14471 8.44525C6.64924 7.12038 7.41962 5.99208 8.36394 5.15003C9.30652 4.30953 10.3901 3.78182 11.5089 3.58622\" stroke=\"white\" stroke-opacity=\"0.45\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path><path d=\"M31.7084 5.95975C32.7822 4.70067 34.1021 3.81419 35.484 3.37609\" stroke=\"white\" stroke-opacity=\"0.45\" stroke-width=\"3\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path></g></g></svg>\r\n","type":"text/markdown","created":"20230410124321204","creator":"oeyoews","modified":"20230410124339406","modifier":"oeyoews","tags":""},{"title":"heatmap","text":"<div class=\"hidden md:block\">\n<$echarts $tiddler=\"$:/plugins/Gk0Wk/echarts/addons/GitHubHeatMap.js\" $theme=\"auto\"/>\n</div>","type":"text/markdown","created":"20231010085652870","creator":"Lenovo","modified":"20231021151230948","modifier":"Lenovo","tags":""},{"title":"hericons","text":"<https://heroicons.com/>","type":"text/markdown","created":"20230504081056502","creator":"oeyoews","modified":"20230504081104851","modifier":"oeyoews","tags":"React"},{"title":"hero-icons","text":"<https://heroicons.com/>","type":"text/markdown","created":"20230411020828724","creator":"oeyoews","modified":"20230411020838163","modifier":"oeyoews","tags":""},{"title":"hitokoto","text":"<$ht />","type":"text/markdown","caption":"一言","created":"20231027055629865","creator":"Lenovo","modified":"20231105060416414","modifier":"Lenovo","tags":"$:/tags/SideBar"},{"title":"hmr","text":"hot module replacement","type":"text/markdown","created":"20230408061106561","creator":"oeyoews","modified":"20230408061116373","modifier":"oeyoews","tags":""},{"title":"hooks","text":"useState 被称为 React Hooks 中的一员，是因为它是 React 16.8 版本中推出的其中一种钩子函数。React Hooks 提供了一种全新的编写 React 组件的方式，它可以使代码更加简洁、易于理解和维护。在使用 Hooks 的过程中，开发者可以直接在函数组件中使用状态（useState）、效应（useEffect）和上下文（useContext），而无需再编写类组件。这种方式大大降低了 React 开发的学习成本，同时也可以提高代码的可读性和可维护性。\r\n\r\n之前，React 组件通常只能使用类组件来管理状态。类组件虽然功能强大，但它往往需要在类中定义许多方法，并且容易产生问题，导致代码复杂难以维护。Hooks 是 React 团队为了解决这些问题而推出的一种新的解决方案。Hooks 可以将组件逻辑拆分为可复用的代码段，并且让代码更易于测试和重构。而 useState 则是最基本、也是最常用的一个 Hook，它被广泛地应用于 React 函数式组件中，用于管理组件内部的状态。\r\n\r\n总之，通过 Hooks，React 提供了一种更加优雅、灵活的编写组件的方式，而 useState 则是 React Hooks 中最基本和常见的一种 Hook。\r\n\r\n除了 `useState`，React Hooks 还提供了其他常用的钩子函数，包括 `useEffect` 和 `useContext`。\r\n\r\n## useEffect\r\n\r\n有些组件需要在挂载、卸载或更新时执行一些副作用操作（比如调用接口请求数据或者修改 DOM）。`useEffect` 就是用来管理这些副作用的钩子函数。它在每次渲染后都会执行，并且可以返回一个清除副作用的函数，以避免内存泄漏。\r\n\r\n使用方式：\r\n\r\n```jsx\r\nimport React, { useEffect } from 'react';\r\n\r\nfunction MyComponent() {\r\n  useEffect(\r\n    () => {\r\n      // 执行副作用操作\r\n      return () => {\r\n        // 清除副作用操作\r\n      };\r\n    },\r\n    [\r\n      /* 依赖项列表 */\r\n    ],\r\n  );\r\n\r\n  return <div>...</div>;\r\n}\r\n```\r\n\r\n在这个例子中，我们通过 `useEffect` 来执行一些副作用操作。可以在钩子函数中进行接口调用、DOM 操作等非纯函数的操作。在副作用函数中返回另一个函数，它将在下一次渲染之前运行，以便清理任何不再需要的资源。`useEffect` 的第二个参数是一个数组，它用于指定哪些变量发生改变时需要重新执行副作用函数。如果数组为空，那么它只会在挂载和卸载后执行一次。如果没有传递第二个参数，则每次渲染后都会执行副作用函数。\r\n\r\n## useContext\r\n\r\n`useContext` 允许在组件树中跨层级传递数据而不必一级一级地手动传递 props。它是一个接收 React 上下文对象（通过 `React.createContext()` 创建）并返回当前上下文值的钩子函数。\r\n\r\n使用方式：\r\n\r\n```jsx\r\nimport React, { useContext } from 'react';\r\n\r\nconst MyContext = React.createContext(/* 默认值 */);\r\n\r\nfunction MyComponent() {\r\n  const value = useContext(MyContext);\r\n  return <div>{value}</div>;\r\n}\r\n```\r\n\r\n在这个例子中，我们创建了一个上下文对象 `MyContext`，并在组件中调用 `useContext` 来获取当前上下文的值。如果没有找到上下文提供者（即该组件的父组件未提供该上下文），则默认值将被返回。在使用这种方式时，需要保证上下文提供者和依赖于上下文的消费者组件处于同一个组件树中，才能使用上下文来进行数据交换。\r\n","type":"text/markdown","created":"20230428052241902","creator":"oeyoews","modified":"20230726045248473","modifier":"oeyoews","tags":"React"},{"title":"how-to-use-tiddlywiki@oeyoews","text":":::abstract\n🛤️ 不同群体, 不同背景, 不同需求..., 注定了笔记软件的选择和使用是多样化的, 也注定会有观点的争论不休 ... (更新中)\n:::\n\n\n* __操作系统__:  <$iconify icon=\"logos:linux-tux\" /> + <$iconify icon=\"devicon:windows11-wordmark\" />\n\n* __启动方式__: <$iconify icon=\"logos:pm2\" /> + <$iconify icon=\"logos:nodejs\" /> + <$iconify icon=\"logos:docker\" />\n\n\n## 如何记录并管理笔记的 ?\n\n{{如何管理笔记}}\n\n:::note\n个人的需求总是在不断变化的, 如果 Tiddlywiki 现有的功能不够好或者没有, 就自己写一个嘛, 全 AI 时代写什么都快, 又不费事, 目前主要使用 Javascript 写插件(wikitext 没有代码高亮等功能, 写插件能不用就不用)\n:::\n\n## Tiddlywiki 高级使用技巧\n\n- 待整理 ...\n\n## 我接触 Tiddlywiki 的过程\n\n:::note\n1. 初识 Tiddlywiki\n* 在我正式使用 Tiddlywiki 之后, 我想起在几年以前见过 Tiddlywiki, 那时一个不知名的网站, 网站具体的内容完全没有了印象, 当时那个网站当时带给我的差评却令我非常深刻, 古老的褐色界面, 说是上古时代的产物也不为过, 极其小的按钮 UI, 虽然有点新奇, 但很快失去了兴趣, 我也不知道这个网站是 Tiddlywiki 做的, 当时也没有深究\n:::\n\n:::tip- 深入了解\n* 后来也不知道是在什么情况下看到了太微的中文教程官网, 简短看了一下主界面的说明,似懂非懂;\n* 最令我震撼的是接下来的实操, 仅一个 html 界面, 就代替了一个笔记软件, 这是最让我暗自高兴的; 心底直呼 NB; \n* 后来对太微的了解愈发深入, 我开始抛弃了单文件的方式(单文件大概折腾使用了一个月), 转向了管理粒度更细的 Nodejs 版本; 也曾去搜过视频教程, 大多质量堪忧, 后来有了一些使用经验后, 就开始读官方文档(这是个好东西), 后来文档也满足不了我的需求, 就开始一边读 tw 的源码, 一边写插件.\n* 再后来, 2022 年末,Chatgpt 出现了, 以前想要写的功能借助 Chatgpt 一一实现; 使用也渐入佳境\n:::\n\n## 使用太微的程度\n\n全键盘流\n\n## 我是如何~~折腾~~学习 Tiddlywiki 的\n\ntiddlywiki 目前来说并不完美,相比产品二字, 他更适合称为程序,更适合修修补补,不断打磨成自己顺手的工具\n\n\n:::tip 结语\n如果想要得心应手, 有行云流水的那种体验, 必须需要付出时间精力, 或早或晚, 不存在一看就会的美事, 但不要迷失在配置的路上, 工作流是慢慢形成的, 配置是为工作效率服务的\n:::","type":"text/markdown","created":"20230611123805993","creator":"oeyoews","description":"Personal Tiddlywiki Introduce","modified":"20231020103334926","modifier":"Lenovo","name":"🤔 Thinking","publish":"article","tags":"TiddlyWiki"},{"title":"href","text":"href: hyperlink","type":"text/markdown","created":"20230419084430436","creator":"oeyoews","modified":"20230419084443902","modifier":"oeyoews","tags":""},{"title":"html-appleevents","text":"```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width\" />\r\n    <title>Index</title>\r\n  </head>\r\n  <body>\r\n    <!-- https://codepen.io/jh3y/pen/gOZWKeM -->\r\n    <script charset=\"utf-8\">\r\n      const button = document.createElement(\"button\");\r\n      button.setAttribute(\"aria-pressed\", \"false\");\r\n      button.classList.add(\"border-none\", \"rounded\");\r\n      const div = document.createElement(\"div\");\r\n      div.setAttribute(\"class\", \"track\");\r\n      const img = new Image();\r\n      div.appendChild(img);\r\n      button.appendChild(div);\r\n      img.src =\r\n        \"https://assets.codepen.io/605876/transparent-sprite-apple.png?format=webp\";\r\n      document.body.appendChild(button);\r\n\r\n      const TOGGLE_LIKE = () => {\r\n        button.setAttribute(\r\n          \"aria-pressed\",\r\n          button.matches(\"[aria-pressed=false]\") ? true : false\r\n        );\r\n      };\r\n\r\n      button.addEventListener(\"click\", TOGGLE_LIKE);\r\n    </script>\r\n\r\n    <style type=\"text/css\" media=\"screen\">\r\n      :root {\r\n        --speed: 1s;\r\n        --frames: 60;\r\n        --size: 96px;\r\n      }\r\n\r\n      button {\r\n        width: var(--size);\r\n        height: var(--size);\r\n        aspect-ratio: 1;\r\n        scale: 1;\r\n        background: transparent;\r\n        cursor: pointer;\r\n      }\r\n\r\n      button:is(:hover, :focus-visible) {\r\n        background: hsl(0 0% 95%);\r\n      }\r\n\r\n      button img {\r\n        height: 100%;\r\n        width: 100%;\r\n        object-fit: cover;\r\n        object-position: 0 0;\r\n      }\r\n\r\n      button[aria-pressed=\"true\"] img {\r\n        animation: sprite var(--speed) var(--timing-function, ease) forwards;\r\n      }\r\n\r\n      @keyframes sprite {\r\n        to {\r\n          object-position: 100% 0;\r\n        }\r\n      }\r\n\r\n      .track__holder {\r\n        position: fixed;\r\n        top: 50%;\r\n        left: 50%;\r\n        width: var(--size);\r\n        aspect-ratio: 1;\r\n        z-index: -1;\r\n        translate: -50% -50%;\r\n        opacity: 0;\r\n        transition: opacity 0.2s;\r\n      }\r\n\r\n      :root:has(#show:checked) .track__holder {\r\n        opacity: 0.5;\r\n      }\r\n\r\n      .track {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n      }\r\n\r\n      .track img {\r\n        height: var(--size);\r\n      }\r\n\r\n      button[aria-pressed=\"true\"] ~ .track__holder .track {\r\n        translate: calc(-100% + var(--size)) 0;\r\n        transition: translate var(--speed) var(--timing-function, ease);\r\n      }\r\n\r\n      :root :is(.track, img) {\r\n        --timing-function: steps(var(--frames));\r\n      }\r\n    </style>\r\n  </body>\r\n</html>\r\n```","type":"text/markdown","created":"20230913110511559","modified":"20230913110547404","tags":"HTML"},{"title":"HTTPS","text":"HyperText Transfer Protocol Secure","type":"text/markdown","created":"20230624033709111","creator":"oeyoews","modified":"20230726045248486","modifier":"oeyoews"},{"title":"husky-usage","text":"* if you use gitua(git add . && git commit -m \"xxx\") this pre-commit will not work (maybe this bug), and this hook execute need time(I cannot bear that for personal projects)","type":"text/markdown","created":"20230402175632696","creator":"oeyoews","modified":"20230402175907715","modifier":"oeyoews","tags":""},{"title":"iframe-pic-in-pic","text":"iframe 不能使用画中画, 但是 ios 系统自动支持","type":"text/markdown","created":"20230929144158285","creator":"oeyoews","modified":"20230929144239426","modifier":"oeyoews","tags":""},{"title":"IIFE","text":" immediately invoked function expression ","type":"text/markdown","created":"20230420051600580","creator":"oeyoews","modified":"20230420051606325","modifier":"oeyoews","tags":""},{"title":"image-alt-width","text":"img 设置 alt 为空时, 如果 src 无效, 整个 image 元素的 widget 就是 0, 所以会看不到,图片加载失败的样子, 但是如果设置了 width, 就可以看到","type":"text/markdown","created":"20231102041518224","creator":"Lenovo","modified":"20231102041639853","modifier":"Lenovo","tags":"CSS"},{"title":"image-example","text":"<https://pixabay.com/zh/>","type":"text/markdown","created":"20230408121508400","creator":"oeyoews","modified":"20230408121517975","modifier":"oeyoews","tags":""},{"title":"imguar-for-flameshot","text":"[img width=256 [https://i.imgur.com/jyyxjye.png]]\n\n:::bug\nimgur 网站和图片都不能访问的时候, 浏览器里面的图片仍然可以访问(缓存已经清除), 内存缓存/磁盘缓存\n:::\n\n```imgur api\n313baf0c7b4d3ff\n```\n\nrelate issus: https://github.com/flameshot-org/flameshot/issues/2893\n\n* flameshot 默认会提供一个 imgur 的 api, 建议使用自己的 api, 但是 imgur 本身总是会宕机是主要的问题\n* try to use webp not png for flameshot\n\n:::warning\n```plain\n{\"data\":{\"error\":\"Imgur is temporarily over capacity. Please try again later.\"},\"success\":false,\"status\":403}\n```\n经常出现这个问题, 有时候切换节点也不起作用;\n:::\n\n:::bug\nflameshot on windows shortcut cannot work\n:::","type":"text/markdown","created":"20230408112508904","creator":"oeyoews","modified":"20231012113656832","modifier":"Lenovo","publish":"public","tags":""},{"title":"import-react","text":"* if you not use jsx, React not necessary imported if you dont use it","type":"text/markdown","created":"20230407065541846","creator":"oeyoews","modified":"20230407065619470","modifier":"oeyoews","tags":""},{"title":"in-hasOwnProperty","text":"在 JavaScript 中，除了使用`hasOwnProperty`方法来检查对象是否具有特定的自有属性外，还可以使用`in`运算符来检查对象是否具有某个属性，包括自有属性和继承属性。\r\n\r\n下面是使用`in`运算符的示例：\r\n\r\n```javascript\r\nconst object1 = {\r\n  property1: 42,\r\n};\r\n\r\nconsole.log('property1' in object1);\r\n// 输出：true\r\n\r\nconsole.log('toString' in object1);\r\n// 输出：true，因为toString是从Object原型继承而来的方法\r\n\r\nconsole.log('hasOwnProperty' in object1);\r\n// 输出：false，因为hasOwnProperty是从Object原型继承而来的方法\r\n```\r\n\r\n在上述示例中，我们使用`in`运算符来检查对象`object1`是否具有指定的属性。如果对象拥有该属性（不论是自有属性还是继承属性），则返回`true`，否则返回`false`。\r\n\r\n请注意，在使用`in`运算符时，如果属性存在于对象的原型链上，也会返回`true`。这就是为什么`'toString' in object1`返回`true`，因为`toString`方法是从`Object`原型继承而来的。相比之下，`hasOwnProperty`方法是`Object`自身的方法，而不是从原型继承而来的，因此`'hasOwnProperty' in object1`返回`false`。\r\n\r\n与`in`运算符不同，`hasOwnProperty`方法只检查对象是否具有自有属性，不会检查继承属性。","type":"text/markdown","created":"20230624144117469","creator":"oeyoews","modified":"20230726045248487","modifier":"oeyoews","tags":"JavaScript"},{"title":"in-operator","text":"\"in\" 在 JavaScript 中是一个运算符，用于检查一个对象是否包含某个属性。它的语法是：\r\n\r\n```javascript\r\n属性名 in 对象\r\n```\r\n\r\n例如，你可以使用它来检查一个对象是否包含特定的属性，如下所示：\r\n\r\n```javascript\r\nvar person = {name: \"John\", age: 30};\r\n\r\nif (\"name\" in person) {\r\n  console.log(\"person 对象包含 name 属性\");\r\n} else {\r\n  console.log(\"person 对象不包含 name 属性\");\r\n}\r\n```\r\n\r\n这段代码会输出 \"person 对象包含 name 属性\"，因为 `person` 对象包含一个名为 \"name\" 的属性。如果属性不存在，它将返回 `false`。这个运算符通常用于遍历对象的属性或检查特定属性是否存在。","type":"text/markdown","created":"20230907132851928","creator":"oeyoews","modified":"20230907132902212","modifier":"oeyoews","tags":"JavaScript"},{"title":"index.d.ts","text":"`index.d.ts`是 TypeScript 中一个特殊的声明文件，它用于描述 JavaScript 模块、类和函数的类型定义和类型推断信息。在 TypeScript 中，`.d.ts`后缀通常表示声明文件。\r\n\r\n当 TypeScript 编译器遇到一个 JavaScript 模块时，如果没有相应的类型定义文件，它可能无法进行类型检查和推断。这就需要开发人员手动编写类型定义文件来告诉编译器如何处理这些模块。而`index.d.ts`文件则是一种通用的命名规范，用于为 JavaScript 模块提供类型定义。\r\n\r\n例如，假设我们有一个名为`example.js`的 JavaScript 模块，其中包含以下代码：\r\n\r\n```javascript\r\n// example.js\r\nexport function add(a, b) {\r\n  return a + b;\r\n}\r\n```\r\n\r\n如果我们要在 TypeScript 中使用`example.js`模块，并希望进行类型检查和推断，我们可以创建一个名为`index.d.ts`的声明文件，以描述该模块导出的函数的类型：\r\n\r\n```typescript\r\n// index.d.ts\r\nexport function add(a: number, b: number): number;\r\n```\r\n\r\n在这个示例中，`index.d.ts`文件将`add`函数的参数和返回值类型定义为数字类型，这样 TypeScript 编译器就可以在使用`example.js`模块时自动进行类型检查和推断。\r\n\r\n总之，`index.d.ts`文件是 TypeScript 用于描述 JavaScript 模块、类、函数等类型的声明文件，它可以帮助 TypeScript 编译器进行类型检查和推断，并提高代码的可读性和可维护性。","type":"text/markdown","created":"20230505093222397","creator":"oeyoews","modified":"20230505093236956","modifier":"oeyoews","tags":"React"},{"title":"indexof","text":"indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。\n如果没有找到匹配的字符串则返回 -1。","type":"text/markdown","created":"20231009125938718","creator":"Lenovo","modified":"20231009125948291","modifier":"Lenovo","tags":"JavaScript"},{"title":"init-tiddlywiki-folder","text":"```plain\r\ntiddlywiki <wikifolder> --init <editionName>","type":"text/markdown","created":"20230319040244043","creator":"oeyoews","modified":"20230319040317489","modifier":"oeyoews","tags":""},{"title":"input-bug-on-office-365","text":"* 在 office 365 input chinese, this text will missing\r\n\r\n> solution: reset your input method, such fcitx5","type":"text/markdown","created":"20230412130253174","creator":"oeyoews","modified":"20230412130358038","modifier":"oeyoews","tags":""},{"title":"install-neovim-from-source","text":"https://github.com/neovim/neovim/wiki/Installing-Neovim#install-from-source","type":"text/markdown","created":"20230621020308513","creator":"oeyoews","modified":"20230726045248488","modifier":"oeyoews","tags":"Neovim"},{"title":"instance","text":"`instanceof` 是 JavaScript 中的运算符，用于检测一个对象是否是某个构造函数的实例。\r\n\r\n语法格式：`object instanceof constructor`\r\n\r\n其中，`object` 是要检测的对象，`constructor` 是构造函数。该运算符返回一个布尔值，如果 `object` 是 `constructor` 的实例，则返回 `true`，否则返回 `false`。\r\n\r\n例如：\r\n\r\n```javascript\r\nfunction Person(name) {\r\n  this.name = name;\r\n}\r\n\r\nconst person = new Person('Alice');\r\n\r\nconsole.log(person instanceof Person); // true\r\nconsole.log(person instanceof Object); // true\r\nconsole.log({} instanceof Object); // true\r\nconsole.log([] instanceof Object); // true\r\nconsole.log([] instanceof Array); // true\r\nconsole.log({} instanceof Array); // false\r\n```\r\n\r\n在上面的代码中，`person` 是 `Person` 的实例，因此 `person instanceof Person` 返回 `true`。同时，由于所有对象都是 `Object` 的实例，因此 `person` 也是 `Object` 的实例，`{}，[]` 也是 `Object` 的实例。`[]` 是 `Array` 的实例，因此 `[] instanceof Array` 返回 `true`，而 `{}` 不是 `Array` 的实例，因此 `{} instanceof Array` 返回 `false`。\r\n\r\n需要注意的是，`instanceof` 运算符的判断是基于原型链的。也就是说，如果 `constructor` 的原型链上有一个对象与 `object` 的原型链上的任意一个对象相等，那么 `object` 就被认为是 `constructor` 的实例。因此，如果 `constructor` 是一个自定义的构造函数，需要确保它的原型链被正确地设置。\r\n\r\n此外，如果 `constructor` 不是一个函数，`instanceof` 运算符会抛出一个 `TypeError` 异常。因此，在使用 `instanceof` 运算符时，需要确保 `constructor` 是一个函数。","type":"text/markdown","created":"20230530103539715","creator":"oeyoews","modified":"20230726045248488","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&instance","tags":"JavaScript"},{"title":"instapaper","text":"pure reader asist rss","type":"text/markdown","created":"20230330084029915","creator":"oeyoews","modified":"20230331131818224","modifier":"oeyoews","publish":"public","tags":""},{"title":"interface-type","text":":::abstract\n用 interface 描述**数据结构**，用 type 描述**类型关系**\n\n type 具有更多高级的类型功能，而 interface 更专注于对象形状的定义。\n:::\n\n在 TypeScript 中，`interface` 和 `type` 是用于描述对象形状的两种方式，它们有一些相似之处，但也有一些不同之处。\n\n### Interface（接口）\n\n`interface` 是一种创建命名对象类型的方式。使用 `interface` 关键字可以定义一个对象的属性、方法以及其相关的类型注解。例如：\n\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n  sayHello: () => void;\n}\n```\n\n在上面的例子中，我们定义了一个 `Person` 接口，它描述了一个具有 `name`、`age` 属性和 `sayHello` 方法的对象。通过接口，我们可以指定每个属性的名称和类型，并定义方法的签名。\n\n### Type（类型别名）\n\n`type` 别名是一种为类型提供别名的方式。使用 `type` 关键字可以创建新的类型，它可以是基本类型、联合类型、交叉类型或者其他复杂类型。例如：\n\n```typescript\ntype Point = {\n  x: number;\n  y: number;\n};\n```\n\n在上面的例子中，我们使用 `type` 创建了一个新的类型别名 `Point`，用于定义具有 `x` 和 `y` 属性的对象。\n\n### 相似之处\n\n`interface` 和 `type` 在很多方面相似，它们都可以用来描述对象形状，并且可以扩展或实现其他接口或类型。此外，它们也都可以被用作泛型约束。\n\n### 不同之处\n\n虽然 `interface` 和 `type` 在大多数情况下可以互换使用，但它们之间也有一些不同之处。\n\n- `interface` 可以被合并（通过相同名称的多个接口进行扩展），而 `type` 则会报错。这使得 `interface` 更适合用于声明类的形状和合并来自多个地方的定义。\n- `type` 可以使用联合类型、交叉类型和映射类型等更高级的类型操作，而 `interface` 相对较简单。\n- 对于函数类型的描述，`interface` 可以使用 `extends` 关键字进行扩展，而 `type` 使用 `=` 进行赋值。这使得 `interface` 更适合描述可被扩展的函数类型。\n\n总的来说，`interface` 适用于声明对象的形状和类的合并，而 `type` 则更适用于复杂的类型操作和描述函数类型。","type":"text/markdown","created":"20230724153542249","creator":"oeyoews","modified":"20231026053148634","modifier":"Lenovo","tags":"TypeScript"},{"title":"ios-music","text":"ios 添加自定义铃声还要下载库乐队， 还有很多操作步骤好麻烦","type":"text/markdown","created":"20231003033929876","creator":"oeyoews","modified":"20231003034015814","modifier":"oeyoews","tags":""},{"title":"IPC","text":"进程间通信（Interprocess Communication，简称 IPC）是指在计算机系统中，不同的进程之间进行数据交换、信息传递和协调工作的机制和技术。当一个计算机系统中有多个并发运行的进程或线程时，它们可能需要相互通信以共享数据、协调任务和实现同步。\r\n\r\nIPC 提供了一组标准化的方法和协议，使得进程可以安全、可靠地进行通信。以下是一些常见的 IPC 方法和技术：\r\n\r\n1. 管道（Pipes）：管道是一种最简单的 IPC 方法，它可以在父进程和子进程之间传递数据。管道有两种类型：无名管道（只能在具有亲缘关系的进程之间使用）和命名管道（允许不同进程之间的通信）。\r\n\r\n2. 共享内存（Shared Memory）：共享内存是一种高效的 IPC 方法，它允许多个进程共享同一块内存区域。进程可以直接读写这块内存，而不需要进行数据拷贝。然而，由于共享内存涉及到进程间的数据一致性和同步问题，因此需要额外的同步机制，如信号量或互斥锁。\r\n\r\n3. 消息队列（Message Queues）：消息队列是一种通过在进程之间传递消息实现通信的机制。每个消息都有一个特定的类型和优先级，并且可以按顺序处理。消息队列提供了一种可靠的方式来发送和接收异步消息。\r\n\r\n4. 套接字（Sockets）：套接字是一种用于网络通信的通用 IPC 方法。它可以在同一台计算机上的不同进程之间或不同计算机上的进程之间进行通信。套接字提供了一种灵活的方式来实现进程间的数据交换和网络通信。\r\n\r\n除了上述方法，还有其他一些 IPC 技术，如信号（Signals）、信号量（Semaphores）、共享文件（Shared Files）等，它们在不同的场景和需求下都有各自的优势和适用性。\r\n\r\n通过使用合适的 IPC 方法，进程可以进行有效的通信和协作，从而实现复杂的任务和系统功能。","type":"text/markdown","created":"20230621102747252","creator":"oeyoews","modified":"20230726045248493","modifier":"oeyoews"},{"title":"iphone-typec","text":"<$video url=\"https://player.bilibili.com/player.html?aid=703761593&bvid=BV1rm4y157qC&cid=1289761628&p=1\" />","type":"text/markdown","created":"20231018075346826","creator":"Lenovo","modified":"20231018081123717","modifier":"Lenovo","tags":""},{"title":"JavaScript","text":":::note javascript\nJavaScript 是一种高级、解释型、动态类型的编程语言，广泛用于前端开发、后端开发以及其他领域，具有面向对象的特性，可以与 HTML 和 CSS 交互，用于实现交互式网页和应用程序.\n:::\n\n\n{{||tagTableTemplate}}","type":"text/markdown","created":"20230501065625958","creator":"oeyoews","icon":"js.png","modified":"20231018062205277","modifier":"Lenovo","page-icon":"skill-icons:javascript","tags":""},{"title":"JavaScript 数字排序问题及解决方案：补零排序","text":"这是因为默认情况下，JavaScript 对数字类型的排序是按照字符串排序的方式进行的。也就是说，它会将数字转换为字符串，然后按照字符串的顺序进行排序。\n\n在字符串排序中，字符串是按照字符的 Unicode 编码值进行排序的。因此，如果数字的位数不同，它们在转换为字符串时长度也不同，就会出现上述的排序问题。\n\n例如，对于数字 1、11 和 2，它们转换为字符串后的长度分别是 1、2 和 1，因此它们在排序时的顺序是 1、11、2，而不是我们期望的 1、2、11。\n\n为了解决这个问题，我们可以在数字前面补零，使它们在转换为字符串后具有相同的长度。这样，在字符串排序时就能够按照我们期望的顺序进行排序。\n\n例如，对于数字 1、11 和 2，我们可以将它们分别转换为字符串 '001'、'011' 和 '002'，这样它们在字符串排序时的顺序就是我们期望的 1、2、11。\n\n因此，在代码中我们需要使用`.padStart()`方法来将数字补足为相同的长度，以便进行正确的排序。","type":"text/markdown","created":"20231026001848500","creator":"Lenovo","modified":"20231026001939174","modifier":"Lenovo","tags":""},{"title":"Journal","text":":::abstract\nDaily Journal\n:::\n\n\n{{ ||tagTableTemplate }}","type":"text/markdown","created":"20230501105846310","creator":"oeyoews","icon":"Journal.png","modified":"20231018045650138","modifier":"Lenovo","page-icon":"fluent-emoji:ledger","tags":"","template":"tagTableTemplate"},{"title":"jq-min-json","text":"```bash\r\njq -c . input.json > output.json\r\n```","type":"text/markdown","created":"20230615054226071","creator":"oeyoews","modified":"20230726045248494","modifier":"oeyoews"},{"title":"js-await","text":"{{||headerTemplate}}\n`await` 关键字是 ECMAScript 2017 中引入的一个语法特性，用于等待异步操作的完成并返回结果。它只能出现在 `async` 函数中，而且只能在异步的 Promise 对象前使用。\n\n当 `await` 后面跟着一个 Promise 对象时，它会暂停当前 async 函数的执行，并等待 Promise 对象的解决（即状态变为 fulfilled 或 rejected）。在接收到 Promise 对象的解决后，`await` 表达式会返回 Promise 对象的解决值。\n\n如果 Promise 对象的状态变为 rejected，那么会抛出一个异常，在 async 函数内部可以使用 try/catch 语句来捕获这个异常。\n\n以下是一个使用 `await` 的例子：\n\n```javascript\nasync function example() {\n  console.log('开始');\n  \n  // 等待异步操作完成并返回结果\n  const result = await someAsyncFunction();\n  console.log(result);\n  \n  console.log('结束');\n}\n\nexample(); // 调用 async 函数\n```\n\n在上面的例子中，`await someAsyncFunction()` 会阻塞代码执行，直到 `someAsyncFunction()` 异步操作完成，并且返回结果。当 Promise 解决后，该表达式会返回解决值，赋给 `result` 变量。\n\n需要注意的是，只有当使用 `async` 函数时，才能使用 `await`。如果你在非 `async` 函数中使用 `await`，代码会抛出语法错误。","type":"text/markdown","created":"20231019134255048","creator":"Lenovo","modified":"20231019134334942","modifier":"Lenovo","tags":"","url":"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await"},{"title":"js-books","text":"* https://books.goalkicker.com/JavaScriptBook/\r\n* [Js](https://wangdoc.com/javascript/)\r\n* [Es6](https://es6.ruanyifeng.com/#README)","type":"text/markdown","created":"20221123051923031","creator":"oeyoews","modified":"20230726045248494","modifier":"oeyoews","publish":"public"},{"title":"js-boolean","text":"if(link) 表示当 link 存在且不是空字符串、false、0、null、undefined 等 Falsy 值时，if 条件判断为真。如果 link 是一个 Truthy 值，则 if 语句块中的代码会被执行。","type":"text/markdown","created":"20230429114253181","creator":"oeyoews","modified":"20231019012929063","modifier":"Lenovo","tags":"JavaScript"},{"title":"js-error-example01","text":"```js\r\nconst demo = {\r\n  version: 1,\r\n  log: function () {\r\n    console.log(this.version);\r\n  },\r\n};\r\n\r\nconst { log } = demo;\r\nlog()\r\n```\r\n\r\n在这个代码片段中，首先定义了一个名为 `demo` 的对象，它包含一个 `version` 属性和一个名为 `log` 的方法。`log` 方法使用 `console.log` 函数输出当前对象的 `version` 属性。\r\n\r\n接下来，使用对象解构将 `demo` 对象中的 `log` 方法分配给变量 `log`。然后，调用 `log()` 方法，但是此时 `log` 方法已经脱离了原来的对象，因此它的 `this` 指向已经发生了变化。\r\n\r\n在 JavaScript 中，函数的 `this` 值是在函数被调用时确定的，它的值取决于函数的调用方式和上下文。在这个例子中，当 `log()` 方法被调用时，它已经被解构到了全局作用域中，因此它的 `this` 值将指向全局对象（在浏览器中通常是 `window` 对象）。\r\n\r\n由于全局对象没有 `version` 属性，因此当 `log()` 方法被调用时，会在控制台中输出 `undefined`。要正确地输出 `version` 属性，可以使用 `Function.prototype.bind()` 方法将 `log` 方法绑定到原始的 `demo` 对象上，如下所示：\r\n\r\n```javascript\r\nconst { log } = demo;\r\nconst boundLog = log.bind(demo);\r\nboundLog(); // 输出：1\r\n``` \r\n\r\n这样，`log` 方法就会在 `demo` 对象的上下文中被调用，它的 `this` 值将指向 `demo` 对象，从而正确地输出 `version` 属性。","type":"text/markdown","created":"20230607033803481","creator":"oeyoews","modified":"20230726045248495","modifier":"oeyoews","tags":"JavaScript"},{"title":"js-event","text":"JavaScript 中的 \"event\" 是指代表事件的对象。当用户与网页交互时，比如点击鼠标、按下键盘、滚动页面等等，就会触发一些事件。这些事件都有对应的事件处理函数，可以通过 JavaScript 来绑定和调用。\r\n\r\n在事件处理函数中，我们可以使用 \"event\" 对象来获取事件的相关信息，比如事件类型、触发元素、鼠标位置等等。例如：\r\n\r\n```javascript\r\ndocument.addEventListener('click', function(event) {\r\n  console.log('You clicked on element:', event.target);\r\n  console.log('Mouse position:', event.pageX, event.pageY);\r\n});\r\n```\r\n\r\n上述代码中，我们使用 addEventListener 方法为文档添加了一个 \"click\" 事件处理函数。在函数中，我们可以通过 \"event\" 对象获取到被点击的元素（即 \"target\" 属性），以及鼠标点击的位置（即 \"pageX\" 和 \"pageY\" 属性）。\r\n\r\n需要注意的是，不同的浏览器在 \"event\" 对象的属性和方法方面可能存在差异，需要进行一定的兼容性处理。","type":"text/markdown","created":"20230420124935291","creator":"oeyoews","modified":"20230420125029413","modifier":"oeyoews","tags":""},{"title":"js-false","text":"<$image source=\"https://images.unsplash.com/photo-1542319465-7a87c5f95757?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w0NTAyMTB8MHwxfHNlYXJjaHwxNHx8ZmFsc2V8ZW58MHwwfHx8MTY4NTExODA3NHww&ixlib=rb-4.0.3&q=80&w=1080\" alt=\"Unsplash Image\"/>\r\n\r\n在 JavaScript 中会被判断为 `false` 的有以下几种情况：\r\n\r\n1. `false`：布尔值 `false`。\r\n2. `null`：表示一个空对象指针。\r\n3. `undefined`：表示一个未定义的值。\r\n4. `0`：数值 `0`。\r\n5. `NaN`：表示非数字（Not-a-Number）值。例如 `0/0` 或者 `parseInt(\"abc\")`。\r\n6. 空字符串 `\"\"`：表示一个空字符串。\r\n\r\n这些情况都可以用于条件语句中作为 `false` 的值。相应地，除了这些值以外的所有值都会被视为 `true`。例如，非空字符串、非零数值、非空对象等都会被视为 `true`。\r\n\r\n在条件语句中，可以使用 `!` 运算符来判断一个值是否为 `false`，例如：\r\n\r\n```javascript\r\nconst x = 0;\r\n// -- 得正\r\nif (!x) {\r\n  console.log(\"x is false\");\r\n} else {\r\n  console.log(\"x is true\");\r\n}\r\n```\r\n\r\n在上面的代码中，由于 `x` 的值为 `0`，因此它会被判断为 `false`，因此条件语句会输出 `\"x is false\"`。","type":"text/markdown","created":"20230526161905269","creator":"oeyoews","modified":"20230913091808499","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&js-false","tags":"JavaScript"},{"title":"js-info","text":"https://javascript.info/js-animation?map","type":"text/markdown","created":"20230915154736041","modified":"20230915154745816","tags":"JavaScript"},{"title":"js-methods","text":"以下是 JavaScript 中需要掌握的高频方法：\r\n\r\n1. DOM 操作：获取、创建、修改、删除 DOM 元素\r\n2. 事件处理：绑定、解绑事件、事件冒泡、阻止默认事件\r\n3. 数组操作：遍历、筛选、排序、去重、合并、转换等\r\n4. 字符串处理：截取、拼接、替换、正则匹配等\r\n5. Ajax 请求：发送、接收、处理请求结果等\r\n6. 函数操作：声明、调用、参数传递、闭包、高阶函数等\r\n7. 异常处理：try-catch 语句、抛出异常等\r\n8. 定时器：setTimeout、setInterval 等\r\n9. JSON 操作：解析、转换、序列化等\r\n10. 模块化：使用模块化规范、模块的导入和导出等。\r\n\r\n1. DOM 操作：\r\n\r\n获取元素：\r\n\r\n```plain\r\nlet element = document.querySelector('#id');\r\nlet elements = document.querySelectorAll('.class');\r\n```\r\n\r\n创建元素：\r\n\r\n```plain\r\nlet element = document.createElement('div');\r\n```\r\n\r\n修改元素：\r\n\r\n```plain\r\nelement.innerHTML = 'new content';\r\nelement.setAttribute('class', 'newClass');\r\n```\r\n\r\n删除元素：\r\n\r\n```plain\r\nelement.parentNode.removeChild(element);\r\n```\r\n\r\n2. 事件处理：\r\n\r\n绑定事件：\r\n\r\n```plain\r\nelement.addEventListener('click', function(event){\r\n  // 点击事件处理逻辑\r\n});\r\n```\r\n\r\n解绑事件：\r\n\r\n```plain\r\nelement.removeEventListener('click', function(event){\r\n  // 点击事件处理逻辑\r\n});\r\n```\r\n\r\n阻止默认事件：\r\n\r\n```plain\r\nevent.preventDefault();\r\n```\r\n\r\n3. 数组操作：\r\n\r\n遍历数组：\r\n\r\n```plain\r\nlet arr = [1, 2, 3];\r\narr.forEach(function(item){\r\n  console.log(item);\r\n});\r\n```\r\n\r\n筛选数组：\r\n\r\n```plain\r\nlet arr = [1, 2, 3];\r\nlet newArr = arr.filter(function(item){\r\n  return item > 1;\r\n});\r\n```\r\n\r\n排序数组：\r\n\r\n```plain\r\nlet arr = [3, 1, 2];\r\narr.sort(function(a, b){\r\n  return a - b;\r\n});\r\n```\r\n\r\n去重数组：\r\n\r\n```plain\r\nlet arr = [1, 2, 3, 2, 1];\r\nlet newArr = Array.from(new Set(arr));\r\n```\r\n\r\n4. 字符串处理：\r\n\r\n截取字符串：\r\n\r\n```plain\r\nlet str = 'hello world';\r\nlet newStr = str.slice(0, 5);\r\n```\r\n\r\n拼接字符串：\r\n\r\n```plain\r\nlet str1 = 'hello';\r\nlet str2 = 'world';\r\nlet newStr = str1 + ' ' + str2;\r\n```\r\n\r\n替换字符串：\r\n\r\n```plain\r\nlet str = 'hello world';\r\nlet newStr = str.replace('world', 'javascript');\r\n```\r\n\r\n正则匹配：\r\n\r\n```plain\r\nlet str = 'hello world';\r\nlet reg = /world/;\r\nlet result = reg.test(str);\r\n```\r\n\r\n5. Ajax 请求：\r\n\r\n发送请求：\r\n\r\n```plain\r\nlet xhr = new XMLHttpRequest();\r\nxhr.open('GET', 'url');\r\nxhr.send();\r\n```\r\n\r\n接收处理请求结果：\r\n\r\n```plain\r\nxhr.onload = function(){\r\n  console.log(xhr.responseText);\r\n};\r\n```\r\n\r\n6. 函数操作：\r\n\r\n声明函数：\r\n\r\n```plain\r\nfunction add(a, b){\r\n  return a + b;\r\n}\r\n```\r\n\r\n调用函数：\r\n\r\n```plain\r\nlet sum = add(1, 2);\r\n```\r\n\r\n参数传递：\r\n\r\n```plain\r\nfunction modifyObj(obj){\r\n  obj.name = 'new name';\r\n}\r\n\r\nlet obj = {name: 'old name'};\r\nmodifyObj(obj);\r\nconsole.log(obj.name); // 输出 'new name'\r\n```\r\n\r\n闭包：\r\n\r\n```plain\r\nfunction createCounter(){\r\n  let count = 0;\r\n  return function(){\r\n    count++;\r\n    console.log(count);\r\n  };\r\n}\r\n\r\nlet counter = createCounter();\r\ncounter(); // 输出 1\r\ncounter(); // 输出 2\r\n```\r\n\r\n高阶函数：\r\n\r\n```plain\r\nfunction add(a, b){\r\n  return a + b;\r\n}\r\n\r\nfunction calculate(func, a, b){\r\n  return func(a, b);\r\n}\r\n\r\nlet sum = calculate(add, 1, 2);\r\n```\r\n\r\n7. 异常处理：\r\n\r\n```plain\r\ntry {\r\n  // 可能出现异常的代码\r\n} catch(error) {\r\n  // 异常处理逻辑\r\n}\r\n```\r\n\r\n抛出异常：\r\n\r\n```plain\r\nthrow new Error('error message');\r\n```\r\n\r\n8. 定时器：\r\n\r\n```plain\r\nlet timer = setTimeout(function(){\r\n  console.log('timer');\r\n}, 1000);\r\n\r\nclearTimeout(timer);\r\n```\r\n\r\n9. JSON 操作：\r\n\r\n解析 JSON：\r\n\r\n```plain\r\nlet str = '{\"name\": \"alice\", \"age\": 18}';\r\nlet obj = JSON.parse(str);\r\n```\r\n\r\n序列化 JSON：\r\n\r\n```plain\r\nlet obj = {name: 'alice', age: 18};\r\nlet str = JSON.stringify(obj);\r\n```\r\n\r\n10. 模块化：\r\n\r\n导入模块：\r\n\r\n```plain\r\nimport {add} from './module';\r\n```\r\n\r\n导出模块：\r\n\r\n```plain\r\nexport function add(a, b){\r\n  return a + b;\r\n}\r\n```\r\n\r\n11. Promise\r\n\r\nPromise 是一种异步编程的解决方案，它可以用来解决回调地狱的问题，提高代码的可读性和可维护性。\r\n\r\n创建 Promise 对象：\r\n\r\n```plain\r\nlet promise = new Promise(function(resolve, reject){\r\n  // 异步操作\r\n  if(/* 操作成功 */){\r\n    resolve(result);\r\n  }else{\r\n    reject(error);\r\n  }\r\n});\r\n```\r\n\r\n使用 then 方法处理 Promise：\r\n\r\n```plain\r\npromise.then(function(result){\r\n  // 操作成功的处理逻辑\r\n}, function(error){\r\n  // 操作失败的处理逻辑\r\n});\r\n```\r\n\r\n使用 catch 方法处理 Promise：\r\n\r\n```plain\r\npromise.catch(function(error){\r\n  // 操作失败的处理逻辑\r\n});\r\n```\r\n\r\n12. async/await\r\n\r\nasync/await 是 ES2017 中新增的异步编程解决方案，它基于 Promise 实现，可以进一步简化异步代码的编写。\r\n\r\n使用 async 声明异步函数：\r\n\r\n```plain\r\nasync function fetchData(){\r\n  // 异步操作\r\n  return result;\r\n}\r\n```\r\n\r\n使用 await 等待异步操作完成：\r\n\r\n```plain\r\nlet result = await fetchData();\r\n```\r\n\r\n使用 try-catch 处理异步操作的异常：\r\n\r\n```plain\r\ntry{\r\n  let result = await fetchData();\r\n}catch(error){\r\n  // 异常处理逻辑\r\n}\r\n```\r\n\r\n13. ES6 中的新特性\r\n\r\nES6 是 JavaScript 中一个重要的版本，它引入了许多新的特性，包括箭头函数、模板字符串、解构赋值、let/const 关键字、类、模块化等等。\r\n\r\n箭头函数：\r\n\r\n```plain\r\nlet add = (a, b) => a + b;\r\n```\r\n\r\n模板字符串：\r\n\r\n```plain\r\nlet name = 'alice';\r\nlet str = `hello ${name}`;\r\n```\r\n\r\n解构赋值：\r\n\r\n```plain\r\nlet [a, b] = [1, 2];\r\n```\r\n\r\nlet/const 关键字：\r\n\r\n```plain\r\nlet name = 'alice';\r\nconst PI = 3.14;\r\n```\r\n\r\n类：\r\n\r\n```plain\r\nclass Person{\r\n  constructor(name){\r\n    this.name = name;\r\n  }\r\n\r\n  sayHello(){\r\n    console.log(`hello ${this.name}`);\r\n  }\r\n}\r\n\r\nlet person = new Person('alice');\r\nperson.sayHello();\r\n```\r\n\r\n模块化：\r\n\r\n```plain\r\nexport function add(a, b){\r\n  return a + b;\r\n}\r\n\r\nimport {add} from './module';\r\n```\r\n\r\n1. 数组的常用方法：`push`、`pop`、`shift`、`unshift`、`slice`、`splice`、`concat`、`join`、`map`、`reduce`、`filter`、`sort`、`reverse` 等。\r\n\r\n2. 对象的常用方法：`Object.keys`、`Object.values`、`Object.entries`、`Object.assign`、`JSON.stringify`、`JSON.parse` 等。\r\n\r\n3. 字符串的常用方法：`charAt`、`charCodeAt`、`indexOf`、`lastIndexOf`、`substr`、`substring`、`slice`、`split`、`replace`、`match` 等。\r\n\r\n4. 函数的常用方法：`bind`、`call`、`apply`、`setTimeout`、`setInterval`、`Promise`、`async/await`、`try/catch` 等。\r\n\r\n5. DOM 操作的常用方法：`getElementById`、`querySelector`、`querySelectorAll`、`createElement`、`appendChild`、`removeChild`、`setAttribute`、`getAttribute`、`classList` 等。\r\n\r\n6. 事件的常用方法：`addEventListener`、`removeEventListener`、`preventDefault`、`stopPropagation` 等。\r\n\r\n7. 正则表达式的常用方法：`test`、`exec`、`match`、`replace`、`search` 等。\r\n\r\n8. 数学计算的常用方法：`Math.round`、`Math.ceil`、`Math.floor`、`Math.abs`、`Math.max`、`Math.min`、`Math.random` 等。\r\n\r\n以上是 JavaScript 中需要掌握的高频方法，掌握这些方法可以提高编码效率，同时也有助于更好地理解 JavaScript 的语法和运行机制。\r\n","type":"text/markdown","created":"20230522111923713","creator":"oeyoews","modified":"20230726045248499","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&js-methods","tags":"JavaScript"},{"title":"JSX","text":"JSX 是 React 中用于描述用户界面的一种语言，它类似于 XML，但具有更强的表达能力和灵活性。在 JSX 中，我们可以通过使用花括号（{}）来插入 JavaScript 表达式，从而实现动态生成用户界面。\r\n\r\nJSX 表达式可以在花括号内包含任何有效的 JavaScript 表达式，例如变量、函数调用、运算符等，例如：\r\n\r\n```jsx\r\nconst name = 'John';\r\nconst element = <h1>Hello, {name}!</h1>;\r\n在上面的代码中，我们定义了一个名为name的变量，然后使用花括号将其插入到了一个JSX元素中。在这个JSX元素中，花括号内的表达式会被求值，并将结果作为文本节点插入到元素中。\r\n```\r\n\r\n我们也可以在 JSX 中使用条件语句、循环语句等 JavaScript 语言特性，例如：\r\n\r\n```plain\r\nconst isLoggedIn = true;\r\nconst element = (\r\n  <div>\r\n    {isLoggedIn ? (\r\n      <p>Welcome back!</p>\r\n    ) : (\r\n      <p>Please log in.</p>\r\n    )}\r\n  </div>\r\n);\r\n```\r\n在上面的代码中，我们使用了条件运算符（?:）来根据用户是否登录来动态生成不同的 JSX 元素。如果用户已经登录，我们会显示一条欢迎消息，否则会显示一条提示消息。\r\n\r\n总之，JSX 表达式可以帮助我们在 React 中动态生成用户界面，使得我们可以更加灵活地控制界面的生成和样式。\r\n\r\n```jsx\r\nconst header = (\r\n  <header>\r\n    <h1>Mozilla Developer Network</h1>\r\n  </header>\r\n);\r\n```\r\n备注： 上一个代码段中的括号并非 JSX 的一部分，它对您的应用程序没有任何影响，括号只是用来向您（和您的计算机）表明其中的多行代码属于同一个表达式 (译者注：原文表述实在有点啰嗦)。因此上面的代码等同于：\r\n\r\n```jsx\r\nconst header = <header>\r\n    <h1>Mozilla Developer Network</h1>\r\n</header>\r\n```\r\n这看起来多少有点不适感，因为表达式前面的 <header> 标记没有缩进与其对应的结束标记相同的位置。","type":"text/markdown","created":"20230426034339651","creator":"oeyoews","modified":"20230426034624587","modifier":"oeyoews","tags":"React"},{"title":"jsx-mdx","text":"是的，JS 和 JSX 文件与 MD 和 MDX 文件类似。MD 是指 Markdown 文件，是一种轻量级标记语言，用于编写纯文本格式的文档和内容。MDX 是指 Markdown + JSX 文件，是一种扩展了 Markdown 的语法，允许您在 Markdown 中嵌入 JSX 代码并创建 React 组件。\r\n\r\n类似地，JS 和 JSX 文件也是两种不同类型的文件，使用不同的文件扩展名（`.js` 和 `.jsx`），并具有不同的语法和功能。JS 文件通常用于编写标准的 JavaScript 代码，而 JSX 文件则允许您在 JavaScript 中编写带有 JSX 语法的 React 组件。\r\n\r\n与此类似，MD 和 MDX 文件也具有不同的后缀名（`.md` 和 `.mdx`），并且具有不同的语法和功能。MD 文件通常用于编写文档、博客文章或其他纯文本内容，而 MDX 文件则允许您在 Markdown 中嵌入 JSX 代码，并将其转换为 React 组件。\r\n\r\n总之，JS/JSX 和 MD/MDX 文件是在不同上下文中使用的不同文件类型，但它们都具有对应关系，并且充分利用了各自的语法和技术。\r\n\r\n<$tid2png />\r\n<$tid2pdf />\r\n\r\n## preview\r\n\r\n<$tid2png preview=\"true\"/>","type":"text/markdown","created":"20230504143404212","creator":"oeyoews","modified":"20230506051355848","modifier":"oeyoews","tags":"React"},{"title":"js默认导出","text":"```js\r\n// mjs\r\nexport default {\r\n  a: 1,\r\n};\r\n\r\nimport aa from \"./d.mjs\";\r\nconsole.log(aa.a);\r\n\r\n```\r\n\r\n```js\r\n// cjs\r\nmodule.exports = {\r\n  a: 1,\r\n};\r\n\r\nconst ab = require('./d.js')\r\nconsole.log(ab.a);\r\n```","type":"text/markdown","created":"20230902091224994","creator":"oeyoews","modified":"20230902091419244","modifier":"oeyoews","tags":"JavaScript"},{"title":"jwt","text":"json web token","type":"text/markdown","created":"20230408083504206","creator":"oeyoews","modified":"20230408083511108","modifier":"oeyoews","tags":""},{"title":"kernel-error","text":"```error\r\nkernel: i915 0000:00:02.0: [drm] *ERROR* rcs0 reset request timed out: {request: 00000001, RESET_CTL: 00000001}\r\n```\r\n\r\nhttps://forum.manjaro.org/t/system-crash-due-to-i915-bios/71356/2\r\n\r\nhttps://wiki.archlinux.org/title/Kernel_parameters#GRUB","type":"text/markdown","created":"20231003080353545","creator":"oeyoews","modified":"20231003080719852","modifier":"oeyoews","tags":"gnome"},{"title":"keyboard-not-working","text":"https://wiki.archlinux.org/title/Laptop/Lenovo\r\n\r\n```plain \r\ni8042.dumbkbd\r\n```\r\n\r\n```plain\r\nsudo dmesg | grep i8042\r\n```\r\n\r\n> add i8042.dumbkbd, capslock light not working, i8042.nopnp capslock light work, but the keyboard not working on boot, maybe some seconds will be fine(press f5 f6 f2 f3)\r\n\r\n\r\n\r\nhttps://wiki.archlinux.org/title/Lenovo_Yoga_14s_2021\r\n\r\nhttps://github.com/yescallop/atkbd-nogetid#user-content-fn-82GH.1-d1dcc385cc23baa2f41a44f2a12f2346\r\nhttps://bbs.archlinuxcn.org/viewtopic.php?id=13313","type":"text/markdown","created":"20231003080944540","creator":"oeyoews","modified":"20231003083417949","modifier":"oeyoews","tags":"gnome"},{"title":"keyboards-conflict","text":"screenity conflict for neotw tiddlywiki shortcuts","type":"text/markdown","created":"20230423114034908","creator":"oeyoews","modified":"20230423114105446","modifier":"oeyoews","tags":""},{"title":"landing-page","text":"```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Tailwind CSS Landing Page</title>\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n    <script>\n      tailwind.config = { corePlugins: { preflight: false } };\n    </script>\n  </head>\n\n  <body class=\"m-0\">\n    <nav class=\"bg-gray-900 h-16\">\n      <div class=\"px-4\">\n        <div class=\"flex justify-between\">\n          <div class=\"text-white font-bold text-xl py-3\">Neotw</div>\n          <ul class=\"flex space-x-4\">\n            <li>\n              <a href=\"#\" class=\"text-gray-300 hover:text-white no-underline\"\n                >Home</a\n              >\n            </li>\n            <li>\n              <a href=\"#\" class=\"text-gray-300 hover:text-white no-underline\"\n                >About</a\n              >\n            </li>\n            <li>\n              <a href=\"#\" class=\"text-gray-300 hover:text-white no-underline\"\n                >Services</a\n              >\n            </li>\n            <li>\n              <a href=\"#\" class=\"text-gray-300 hover:text-white no-underline\"\n                >Contact</a\n              >\n            </li>\n          </ul>\n        </div>\n      </div>\n    </nav>\n\n    <div\n      class=\"min-h-screen flex flex-col justify-center items-center bg-[#F5F5EE]\"\n    >\n      <h1 class=\"text-4xl font-bold mb-4\">Welcome to Our Landing Page</h1>\n      <p class=\"text-gray-600 text-lg mb-8\">\n        Thank you for visiting our website.\n      </p>\n      <a\n        href=\"#\"\n        class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded no-underline\"\n      >\n        Get Started\n      </a>\n    </div>\n  </body>\n</html>\n```","type":"text/markdown","created":"20230628134307234","creator":"oeyoews","modified":"20231021014140652","modifier":"Lenovo","tags":"Tailwindcss"},{"title":"layout","text":"Flex 和 Grid 都是 CSS 布局模块，它们都提供了强大的布局功能，并且都能用于响应式设计。但是它们的工作方式略有不同，具体区别如下：\r\n\r\n弹性布局（Flex）：Flex 布局通过指定 flex 容器和 flex 项目来实现布局。容器可以设置 flex-direction、justify-content、align-items 等属性来控制子元素的位置和排列方式。Flex 可以实现自适应布局，适用于快速搭建简单响应式布局。\r\n\r\n网格布局（Grid）：Grid 布局通过定义网格容器和网格项目来实现布局。容器中的网格项可以分为行和列，并且可以指定宽度、高度、间距等属性。Grid 可以实现复杂布局，适用于构建复杂的网站和应用。\r\n\r\n兼容性问题：由于 Flex 比 Grid 先出现，所以 Flex 兼容性更好，在 IE10+ 和现代浏览器中都支持；而 Grid 则需要 IE11+ 和现代浏览器的支持。\r\n\r\n应用场景不同：Flex 适用于一维自适应布局，例如导航栏、列表等；而 Grid 适用于多维自适应布局，例如网格、表格等。\r\n\r\n总的来说，两种布局方式都有各自的优点和缺点，应该根据实际情况选择合适的布局方式。如果只需要简单的布局，可以使用 Flex 布局；如果想要实现复杂的布局，则可以使用 Grid 布局。","type":"text/markdown","created":"20230430125655295","creator":"oeyoews","modified":"20230430125705743","modifier":"oeyoews","tags":"CSS"},{"title":"learn-faster-how","text":"* <https://www.joshwcomeau.com/blog/how-to-learn-stuff-quickly/>","type":"text/markdown","created":"20230401123410570","creator":"oeyoews","modified":"20230401123425498","modifier":"oeyoews","tags":""},{"title":"learn-umi01","text":"* umi 不支持选择目录, 只能手动选择(我的 umi 文件散落在根目录撒一地 :cry:)\r\n* umi 自己又重新封装了一层配置(感觉是缝合的, 其中有点向 nextjs 的那套风格), 文档很乱不规范, 我还是回去接着写 nextjs 吧","type":"text/markdown","created":"20230831041640982","creator":"oeyoews","modified":"20230901030956674","modifier":"oeyoews","tags":"umi"},{"title":"learn-x-in-y-minutes-javascript","text":"```js\n// 注释方式和C很像，这是单行注释\n/* 这是多行\n   注释 */\n\n// 语句可以以分号结束\ndoStuff();\n\n// ... 但是分号也可以省略，每当遇到一个新行时，分号会自动插入（除了一些特殊情况）。\ndoStuff()\n\n// 因为这些特殊情况会导致意外的结果，所以我们在这里保留分号。\n```\n\n## 数字、字符串与操作符\n\n```js\n///////////////////////////////////\n\n// Javascript 只有一种数字类型(即 64位 IEEE 754 双精度浮点 double)。\n// double 有 52 位表示尾数，足以精确存储大到 9✕10¹⁵ 的整数。\n3; // = 3\n1.5; // = 1.5\n\n// 所有基本的算数运算都如你预期。\n1 + 1; // = 2\n0.1 + 0.2; // = 0.30000000000000004\n8 - 1; // = 7\n10 * 2; // = 20\n35 / 5; // = 7\n\n// 包括无法整除的除法。\n5 / 2; // = 2.5\n\n// 位运算也和其他语言一样；当你对浮点数进行位运算时，\n// 浮点数会转换为*至多* 32 位的无符号整数。\n1 << 2; // = 4\n\n// 括号可以决定优先级。\n(1 + 3) * 2; // = 8\n\n// 有三种非数字的数字类型\nInfinity; // 1/0 的结果\n-Infinity; // -1/0 的结果\nNaN; // 0/0 的结果\n\n// 也有布尔值。\ntrue;\nfalse;\n\n// 可以通过单引号或双引号来构造字符串。\n'abc';\n\"Hello, world\";\n\n// 用！来取非\n!true; // = false\n!false; // = true\n\n// 相等 ===\n1 === 1; // = true\n2 === 1; // = false\n\n// 不等 !=\n1 !== 1; // = false\n2 !== 1; // = true\n\n// 更多的比较操作符 \n1 < 10; // = true\n1 > 10; // = false\n2 <= 2; // = true\n2 >= 2; // = true\n\n// 字符串用+连接\n\"Hello \" + \"world!\"; // = \"Hello world!\"\n\n// 字符串也可以用 < 、> 来比较\n\"a\" < \"b\"; // = true\n\n// 使用“==”比较时会进行类型转换...\n\"5\" == 5; // = true\nnull == undefined; // = true\n\n// ...除非你是用 ===\n\"5\" === 5; // = false\nnull === undefined; // = false \n\n// ...但会导致奇怪的行为\n13 + !0; // 14\n\"13\" + !0; // '13true'\n\n// 你可以用`charAt`来得到字符串中的字符\n\"This is a string\".charAt(0);  // = 'T'\n\n// ...或使用 `substring` 来获取更大的部分。\n\"Hello world\".substring(0, 5); // = \"Hello\"\n\n// `length` 是一个属性，所以不要使用 ().\n\"Hello\".length; // = 5\n\n// 还有两个特殊的值：`null`和`undefined`\nnull;      // 用来表示刻意设置的空值\nundefined; // 用来表示还没有设置的值(尽管`undefined`自身实际是一个值)\n\n// false, null, undefined, NaN, 0 和 \"\" 都是假的；其他的都视作逻辑真\n// 注意 0 是逻辑假而  \"0\"是逻辑真，尽管 0 == \"0\"。\n```\n\n## 变量、数组和对象\n\n```js\n///////////////////////////////////\n\n// 变量需要用`var`关键字声明。Javascript是动态类型语言，\n// 所以你无需指定类型。 赋值需要用 `=` \nvar someVar = 5;\n\n// 如果你在声明时没有加var关键字，你也不会得到错误...\nsomeOtherVar = 10;\n\n// ...但是此时这个变量就会在全局作用域被创建，而非你定义的当前作用域\n\n// 没有被赋值的变量都会被设置为undefined\nvar someThirdVar; // = undefined\n\n// 对变量进行数学运算有一些简写法：\nsomeVar += 5; // 等价于 someVar = someVar + 5; someVar 现在是 10 \nsomeVar *= 10; // 现在 someVar 是 100\n\n// 自增和自减也有简写\nsomeVar++; // someVar 是 101\nsomeVar--; // 回到 100\n\n// 数组是任意类型组成的有序列表\nvar myArray = [\"Hello\", 45, true];\n\n// 数组的元素可以用方括号下标来访问。\n// 数组的索引从0开始。\nmyArray[1]; // = 45\n\n// 数组是可变的，并拥有变量 length。\nmyArray.push(\"World\");\nmyArray.length; // = 4\n\n// 在指定下标添加/修改\nmyArray[3] = \"Hello\";\n\n// javascript中的对象相当于其他语言中的“字典”或“映射”：是键-值对的无序集合。\nvar myObj = {key1: \"Hello\", key2: \"World\"};\n\n// 键是字符串，但如果键本身是合法的js标识符，则引号并非是必须的。\n// 值可以是任意类型。\nvar myObj = {myKey: \"myValue\", \"my other key\": 4};\n\n// 对象属性的访问可以通过下标\nmyObj[\"my other key\"]; // = 4\n\n// ... 或者也可以用 . ，如果属性是合法的标识符\nmyObj.myKey; // = \"myValue\"\n\n// 对象是可变的；值也可以被更改或增加新的键\nmyObj.myThirdKey = true;\n\n// 如果你想要获取一个还没有被定义的值，那么会返回undefined\nmyObj.myFourthKey; // = undefined\n```\n\n## 逻辑与控制结构\n\n```js\n///////////////////////////////////\n\n// 本节介绍的语法与Java的语法几乎完全相同\n\n// `if`语句和其他语言中一样。\nvar count = 1;\nif (count == 3){\n    // count 是 3 时执行\n} else if (count == 4){\n    // count 是 4 时执行\n} else {\n    // 其他情况下执行 \n}\n\n// while循环\nwhile (true) {\n    // 无限循环\n}\n\n// Do-while 和 While 循环很像 ，但前者会至少执行一次\nvar input;\ndo {\n    input = getInput();\n} while (!isValid(input))\n\n// `for`循环和C、Java中的一样：\n// 初始化; 继续执行的条件; 迭代。\nfor (var i = 0; i < 5; i++){\n    // 遍历5次\n}\n\n// && 是逻辑与, || 是逻辑或\nif (house.size == \"big\" && house.colour == \"blue\"){\n    house.contains = \"bear\";\n}\nif (colour == \"red\" || colour == \"blue\"){\n    // colour是red或者blue时执行\n}\n\n// && 和 || 是“短路”语句，它在设定初始化值时特别有用 \nvar name = otherName || \"default\";\n\n// `switch`语句使用`===`检查相等性。\n// 在每一个case结束时使用 'break'\n// 否则其后的case语句也将被执行。 \ngrade = 'B';\nswitch (grade) {\n  case 'A':\n    console.log(\"Great job\");\n    break;\n  case 'B':\n    console.log(\"OK job\");\n    break;\n  case 'C':\n    console.log(\"You can do better\");\n    break;\n  default:\n    console.log(\"Oy vey\");\n    break;\n}\n```\n\n## 函数、作用域、闭包\n\n```js\n///////////////////////////////////\n\n// JavaScript 函数由`function`关键字定义\nfunction myFunction(thing){\n    return thing.toUpperCase();\n}\nmyFunction(\"foo\"); // = \"FOO\"\n\n// 注意被返回的值必须开始于`return`关键字的那一行，\n// 否则由于自动的分号补齐，你将返回`undefined`。\n// 在使用Allman风格的时候要注意.\nfunction myFunction()\n{\n    return // <- 分号自动插在这里\n    {\n        thisIsAn: 'object literal'\n    }\n}\nmyFunction(); // = undefined\n\n// javascript中函数是一等对象，所以函数也能够赋给一个变量，\n// 并且被作为参数传递 —— 比如一个事件处理函数：\nfunction myFunction(){\n    // 这段代码将在5秒钟后被调用\n}\nsetTimeout(myFunction, 5000);\n// 注意：setTimeout不是js语言的一部分，而是由浏览器和Node.js提供的。\n\n// 函数对象甚至不需要声明名称 —— 你可以直接把一个函数定义写到另一个函数的参数中\nsetTimeout(function(){\n    // 这段代码将在5秒钟后被调用\n}, 5000);\n\n// JavaScript 有函数作用域；函数有其自己的作用域而其他的代码块则没有。\nif (true){\n    var i = 5;\n}\ni; // = 5 - 并非我们在其他语言中所期望得到的undefined\n\n// 这就导致了人们经常使用的“立即执行匿名函数”的模式，\n// 这样可以避免一些临时变量扩散到全局作用域去。\n(function(){\n    var temporary = 5;\n    // 我们可以访问修改全局对象（\"global object\"）来访问全局作用域，\n    // 在web浏览器中是`window`这个对象。 \n    // 在其他环境如Node.js中这个对象的名字可能会不同。\n    window.permanent = 10;\n})();\ntemporary; // 抛出引用异常ReferenceError\npermanent; // = 10\n\n// javascript最强大的功能之一就是闭包。\n// 如果一个函数在另一个函数中定义，那么这个内部函数就拥有外部函数的所有变量的访问权，\n// 即使在外部函数结束之后。\nfunction sayHelloInFiveSeconds(name){\n    var prompt = \"Hello, \" + name + \"!\";\n    // 内部函数默认是放在局部作用域的，\n    // 就像是用`var`声明的。\n    function inner(){\n        alert(prompt);\n    }\n    setTimeout(inner, 5000);\n    // setTimeout是异步的，所以 sayHelloInFiveSeconds 函数会立即退出，\n    // 而 setTimeout 会在后面调用inner\n    // 然而，由于inner是由sayHelloInFiveSeconds“闭合包含”的，\n    // 所以inner在其最终被调用时仍然能够访问`prompt`变量。\n}\nsayHelloInFiveSeconds(\"Adam\"); // 会在5秒后弹出 \"Hello, Adam!\"\n```\n\n## 对象、构造函数与原型\n\n```js\n///////////////////////////////////\n\n//  对象可以包含方法。\nvar myObj = {\n    myFunc: function(){\n        return \"Hello world!\";\n    }\n};\nmyObj.myFunc(); // = \"Hello world!\"\n\n// 当对象中的函数被调用时，这个函数可以通过`this`关键字访问其依附的这个对象。\nmyObj = {\n    myString: \"Hello world!\",\n    myFunc: function(){\n        return this.myString;\n    }\n};\nmyObj.myFunc(); // = \"Hello world!\"\n\n// 但这个函数访问的其实是其运行时环境，而非定义时环境，即取决于函数是如何调用的。\n// 所以如果函数被调用时不在这个对象的上下文中，就不会运行成功了。\nvar myFunc = myObj.myFunc;\nmyFunc(); // = undefined\n\n// 相应的，一个函数也可以被指定为一个对象的方法，并且可以通过`this`访问\n// 这个对象的成员，即使在函数被定义时并没有依附在对象上。\nvar myOtherFunc = function(){\n    return this.myString.toUpperCase();\n}\nmyObj.myOtherFunc = myOtherFunc;\nmyObj.myOtherFunc(); // = \"HELLO WORLD!\"\n\n// 当我们通过`call`或者`apply`调用函数的时候，也可以为其指定一个执行上下文。\nvar anotherFunc = function(s){\n    return this.myString + s;\n}\nanotherFunc.call(myObj, \" And Hello Moon!\"); // = \"Hello World! And Hello Moon!\"\n\n// `apply`函数几乎完全一样，只是要求一个array来传递参数列表。\nanotherFunc.apply(myObj, [\" And Hello Sun!\"]); // = \"Hello World! And Hello Sun!\"\n\n// 当一个函数接受一系列参数，而你想传入一个array时特别有用。\nMath.min(42, 6, 27); // = 6\nMath.min([42, 6, 27]); // = NaN (uh-oh!)\nMath.min.apply(Math, [42, 6, 27]); // = 6\n\n// 但是`call`和`apply`只是临时的。如果我们希望函数附着在对象上，可以使用`bind`。\nvar boundFunc = anotherFunc.bind(myObj);\nboundFunc(\" And Hello Saturn!\"); // = \"Hello World! And Hello Saturn!\"\n\n// `bind` 也可以用来部分应用一个函数（柯里化）。\nvar product = function(a, b){ return a * b; }\nvar doubler = product.bind(this, 2);\ndoubler(8); // = 16\n\n// 当你通过`new`关键字调用一个函数时，就会创建一个对象，\n// 而且可以通过this关键字访问该函数。\n// 设计为这样调用的函数就叫做构造函数。\nvar MyConstructor = function(){\n    this.myNumber = 5;\n}\nmyNewObj = new MyConstructor(); // = {myNumber: 5}\nmyNewObj.myNumber; // = 5\n\n// 每一个js对象都有一个‘原型’。当你要访问一个实际对象中没有定义的一个属性时，\n// 解释器就回去找这个对象的原型。\n\n// 一些JS实现会让你通过`__proto__`属性访问一个对象的原型。\n// 这虽然对理解原型很有用，但是它并不是标准的一部分；\n// 我们后面会介绍使用原型的标准方式。\nvar myObj = {\n    myString: \"Hello world!\"\n};\nvar myPrototype = {\n    meaningOfLife: 42,\n    myFunc: function(){\n        return this.myString.toLowerCase()\n    }\n};\n\nmyObj.__proto__ = myPrototype;\nmyObj.meaningOfLife; // = 42\n\n// 函数也可以工作。\nmyObj.myFunc() // = \"hello world!\"\n\n// 当然，如果你要访问的成员在原型当中也没有定义的话，解释器就会去找原型的原型，以此类推。\nmyPrototype.__proto__ = {\n    myBoolean: true\n};\nmyObj.myBoolean; // = true\n\n// 这其中并没有对象的拷贝；每个对象实际上是持有原型对象的引用。\n// 这意味着当我们改变对象的原型时，会影响到其他以这个原型为原型的对象。\nmyPrototype.meaningOfLife = 43;\nmyObj.meaningOfLife; // = 43\n\n// 我们知道 `__proto__` 并非标准规定，实际上也没有标准办法来修改一个已存在对象的原型。\n// 然而，我们有两种方式为指定原型创建一个新的对象。\n\n// 第一种方式是 Object.create，这个方法是在最近才被添加到Js中的，\n// 因此并不是所有的JS实现都有这个方法\nvar myObj = Object.create(myPrototype);\nmyObj.meaningOfLife; // = 43\n\n// 第二种方式可以在任意版本中使用，不过必须通过构造函数。\n// 构造函数有一个属性prototype。但是它 *不是* 构造函数本身的原型；相反，\n// 是通过构造函数和new关键字创建的新对象的原型。\nMyConstructor.prototype = {\n    myNumber: 5,\n    getMyNumber: function(){\n        return this.myNumber;\n    }\n};\nvar myNewObj2 = new MyConstructor();\nmyNewObj2.getMyNumber(); // = 5\nmyNewObj2.myNumber = 6\nmyNewObj2.getMyNumber(); // = 6\n\n// 字符串和数字等内置类型也有通过构造函数来创建的包装类型\nvar myNumber = 12;\nvar myNumberObj = new Number(12);\nmyNumber == myNumberObj; // = true\n\n// 但是它们并非严格等价\ntypeof myNumber; // = 'number'\ntypeof myNumberObj; // = 'object'\nmyNumber === myNumberObj; // = false\nif (0){\n    // 这段代码不会执行，因为0代表假\n}\n\n// 不过，包装类型和内置类型共享一个原型，\n// 所以你实际可以给内置类型也增加一些功能，例如对string：\nString.prototype.firstCharacter = function(){\n    return this.charAt(0);\n}\n\"abc\".firstCharacter(); // = \"a\"\n\n// 这个技巧经常用在“代码填充”中，来为老版本的javascript子集增加新版本js的特性，\n// 这样就可以在老的浏览器中使用新功能了。\n\n// 比如，我们知道Object.create并没有在所有的版本中都实现，\n// 但是我们仍然可以通过“代码填充”来实现兼容：\nif (Object.create === undefined){ // 如果存在则不覆盖\n    Object.create = function(proto){\n        // 用正确的原型来创建一个临时构造函数\n        var Constructor = function(){};\n        Constructor.prototype = proto;\n        // 之后用它来创建一个新的对象\n        return new Constructor();\n    }\n}\n```","type":"text/markdown","created":"20230606152640462","creator":"oeyoews","modified":"20231017090030530","modifier":"Lenovo","publish":"article","tags":"JavaScript"},{"title":"lf-crlf-on-windows","text":"```bash\ngit config --global core.autocrlf false\n```","type":"text/markdown","created":"20231009093819597","creator":"Lenovo","modified":"20231009093850961","modifier":"Lenovo","tags":""},{"title":"library.template.html","text":"* 注意这个 recipes 的路径不会动态生成\n\n```html\n\\rules only filteredtranscludeinline transcludeinline\n<!doctype html>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" />\n<meta name=\"application-name\" content=\"TiddlyWiki Plugin Library\" />\n<meta name=\"application-version\" content=\"v0.0.0\" />\n<meta name=\"copyright\" content=\"Copyright 2015 Jeremy Ruston\" />\n<link id=\"faviconLink\" rel=\"shortcut icon\" href=\"favicon.ico\">\n<title>Plugin Library</title>\n<script>\n{{$:/plugins/tiddlywiki/pluginlibrary/asset-list-json}}\n{{$:/plugins/tiddlywiki/pluginlibrary/libraryserver.js}}\n</script>\n</head>\n<body>\n\n<h1>HelloThere</h1>\n\n<p>This is the TiddlyWiki plugin library. It is not intended to be opened directly in the browser.</p>\n\n<p>See <a href=\"https://tiddlywiki.com/\" target=\"_blank\">https://tiddlywiki.com/</a> for details of how to install plugins.</p>\n\n<h2 id=\"pluginlist\">Plugin List</h2>\n\n<script>\nconst pluginListNode = document.createElement('div');\nassetList.forEach( ({title}) => {\n  const li = document.createElement('li');\n  const name = title.replace('$:/plugins/oeyoews/', '');\n  li.textContent = name;\n//   const a = document.createElement('a');\n  // TODO\n// a.href='#'\n//   a.href = `./recipes/library/tiddlers/${encodeURIComponent(title)}.json`;\n//   a.target = \"_blank\";\n//   a.textContent = name;\n  pluginListNode.append(li);\n});document.body.append(pluginListNode)\n</script>\n\n</body>\n</html>\n```","type":"text/markdown","created":"20231015125919186","creator":"Lenovo","modified":"20231024094420139","modifier":"Lenovo"},{"title":"link-icons","text":"<svg stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" viewBox=\"0 0 512 512\" height=\"1em\" width=\"1em\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg>\r\n\r\n<svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>\r\n\r\n<svg stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" viewBox=\"0 0 16 16\" height=\"1em\" width=\"1em\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.354 5.5H4a3 3 0 0 0 0 6h3a3 3 0 0 0 2.83-4H9c-.086 0-.17.01-.25.031A2 2 0 0 1 7 10.5H4a2 2 0 1 1 0-4h1.535c.218-.376.495-.714.82-1z\"></path><path d=\"M9 5.5a3 3 0 0 0-2.83 4h1.098A2 2 0 0 1 9 6.5h3a2 2 0 1 1 0 4h-1.535a4.02 4.02 0 0 1-.82 1H12a3 3 0 1 0 0-6H9z\"></path></svg>\r\n\r\n<svg stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" viewBox=\"0 0 24 24\" height=\"1em\" width=\"1em\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8.465 11.293c1.133-1.133 3.109-1.133 4.242 0l.707.707 1.414-1.414-.707-.707c-.943-.944-2.199-1.465-3.535-1.465s-2.592.521-3.535 1.465L4.929 12a5.008 5.008 0 0 0 0 7.071 4.983 4.983 0 0 0 3.535 1.462A4.982 4.982 0 0 0 12 19.071l.707-.707-1.414-1.414-.707.707a3.007 3.007 0 0 1-4.243 0 3.005 3.005 0 0 1 0-4.243l2.122-2.121z\"></path><path d=\"m12 4.929-.707.707 1.414 1.414.707-.707a3.007 3.007 0 0 1 4.243 0 3.005 3.005 0 0 1 0 4.243l-2.122 2.121c-1.133 1.133-3.109 1.133-4.242 0L10.586 12l-1.414 1.414.707.707c.943.944 2.199 1.465 3.535 1.465s2.592-.521 3.535-1.465L19.071 12a5.008 5.008 0 0 0 0-7.071 5.006 5.006 0 0 0-7.071 0z\"></path></svg>","type":"text/markdown","created":"20230406030155335","creator":"oeyoews","modified":"20230406030515847","modifier":"oeyoews","tags":""},{"title":"links-diff","text":"硬链接和软链接是两种不同类型的链接方式，它们有以下几个区别：\r\n\r\n1. 根据文件系统支持的不同，硬链接只能链接到同一个文件系统中的文件，而软链接可以链接到不同文件系统中的文件。\r\n\r\n2. 硬链接创建的链接文件与被链接文件共享相同的 inode 和文件内容，即它们实际上是同一个文件的不同名称。软链接创建的链接文件只包含指向被链接文件的路径信息，它们是两个不同的文件。\r\n\r\n3. 当删除被链接文件时，硬链接仍然能够访问和使用文件内容，因为它们共享相同的 inode。而软链接会失效，无法访问被链接文件。\r\n\r\n4. 硬链接没有文件大小的概念，因为它们共享相同的文件内容。软链接具有自己的文件大小，它只是一个指向被链接文件的路径。\r\n\r\n5. 硬链接可以通过文件名或者路径直接访问，而软链接需要通过软链接文件的路径访问。\r\n\r\n总的来说，硬链接是实际的文件副本，而软链接只是一个指向原始文件的路径。硬链接的文件操作不会影响其他链接文件，而软链接的文件操作会影响到被链接文件。\r\n\r\n硬链接和直接复制有以下几个区别：\r\n\r\n1. 存储空间占用：硬链接不会占用额外的存储空间，因为它们只是共享相同的文件内容和 inode。而直接复制会创建一个完全相同的文件副本，占用额外的存储空间。\r\n\r\n2. 文件关联性：硬链接是与原始文件关联的，它们实际上是同一个文件。如果修改其中一个链接文件，其他链接文件也会受到影响。而直接复制是创建一个独立的副本，与原始文件没有关联，修改一个文件不会影响其他文件。\r\n\r\n3. 文件访问方式：硬链接可以通过任何一个链接文件的路径访问和操作。而直接复制会创建一个独立的文件，需要通过该文件的路径访问和操作。\r\n\r\n4. 删除行为：当删除一个硬链接时，它只会减少一个链接，不会影响其他链接文件和原始文件。而直接复制的副本文件可以独立删除，不会影响原始文件和其他文件。\r\n\r\n总的来说，硬链接是与原始文件关联的，共享相同的文件内容和 inode，不占用额外的存储空间。直接复制创建了一个独立的副本文件，占用额外的存储空间，与原始文件没有关联。\r\n\r\n在 Linux 中，可以使用`ls -l`命令来查看文件的硬链接数量。命令的输出结果中的第一个字段表示硬链接数量。\r\n\r\n例如，要查看文件`example.txt`的硬链接数量，可以运行以下命令：\r\n\r\n```plain\r\nls -l example.txt\r\n```\r\n\r\n输出结果中的第一个字段即为硬链接数量。如果该文件没有任何硬链接，则硬链接数量为 1（因为至少有一个链接指向原始文件本身）。如果有多个硬链接，则硬链接数量会大于 1。\r\n\r\n在 Linux 中，目录\".\"表示当前目录，\"..\"表示上级目录。它们也有对应的数字表示。\r\n\r\n在 ls 命令的长格式输出（使用`ls -l`）中，第一列的第一个字符表示文件类型，其中\"d\"表示目录。接下来的九个字符表示文件的权限，分为三组，每组三个字符。第二组三个字符表示文件所有者的权限，第三组三个字符表示文件所属组的权限，最后一组三个字符表示其他用户的权限。\r\n\r\n在第一组三个字符中，如果第一个字符是\"r\"，则表示当前目录\".\"对所有者具有读权限；如果是\"-\"，则表示没有读权限。第二个字符同样表示写权限，第三个字符表示执行权限。\r\n\r\n同样，在第二组三个字符中，如果第一个字符是\"r\"，则表示上级目录\"..\"对所有者具有读权限；如果是\"-\"，则表示没有读权限。第二个字符同样表示写权限，第三个字符表示执行权限。\r\n\r\n这些数字是根据字符权限的组合来计算的，\"r\"表示 4，\"w\"表示 2，\"x\"表示 1。所以，如果某个字符有对应的权限，就将其对应的数字加起来。\r\n\r\n因此，如果你看到某个目录的权限为\"drwxr-xr-x\"，其中第二组的三个字符表示对于所有者来说，当前目录\".\"具有读、写、执行权限，所以它对应的数字是 7；而第三组的三个字符表示对于所属组和其他用户来说，上级目录\"..\"具有读和执行权限，所以它们对应的数字是 5。","type":"text/markdown","tags":""},{"title":"links-gallery","text":"<$list-links />","type":"text/markdown","created":"20231021010328616","creator":"Lenovo","modified":"20231022112940627","modifier":"Lenovo","tags":"$:/tags/SideBar"},{"title":"list-all-empty-folders","text":"```bash\nfind . -type d -empty\n```","type":"text/markdown","created":"20230319020047637","creator":"oeyoews","modified":"20231021022206914","modifier":"Lenovo","tags":""},{"title":"list-available-font","text":"```bash\r\nfc-list | grep -i maple\r\n```","type":"text/markdown","created":"20231001144254814","creator":"oeyoews","modified":"20231001144355309","modifier":"oeyoews","tags":""},{"title":"list-widget","text":"https://bramchen.github.io/tw5-docs/zh-Hans/#ListWidget","type":"text/markdown","created":"20231017234620931","creator":"Lenovo","modified":"20231017234640143","modifier":"Lenovo","tags":"TiddlyWiki"},{"title":"listener-multi","text":"if add mulit same listener, this will execute theme orderly","type":"text/markdown","created":"20231002163212340","creator":"oeyoews","modified":"20231002163256754","modifier":"oeyoews","tags":"JavaScript"},{"title":"listener-once","text":"如果您想要在 HTML 元素上添加只监听一次的事件处理程序，可以使用 `addEventListener()` 方法的 `{once: true}` 选项。这个选项允许您在元素上添加一个只触发一次的事件监听器。\r\n\r\n以下是一个使用 `{once: true}` 选项的示例：\r\n\r\n```html\r\n<button id=\"myButton\">点击我</button>\r\n\r\n<script>\r\nconst button = document.getElementById('myButton');\r\n\r\nfunction handleClick() {\r\n  console.log('按钮被点击了');\r\n}\r\n\r\nbutton.addEventListener('click', handleClick, {once: true});\r\n</script>\r\n```\r\n\r\n在上述示例中，我们首先获取了一个 `<button>` 元素，并为其添加了一个点击事件监听器 `handleClick`。通过将 `{once: true}` 对象作为第三个参数传递给 `addEventListener` 方法，我们指示浏览器只触发该事件监听器一次。当用户单击按钮时，将执行 `handleClick` 函数并记录一条消息。\r\n\r\n请注意，`{once: true}` 选项仅适用于当前添加的事件监听器。如果需要在将来再次添加一个只监听一次的事件监听器，您将需要重新使用 `{once: true}` 选项。","type":"text/markdown","created":"20231002164609607","creator":"oeyoews","modified":"20231002164621621","modifier":"oeyoews","tags":"JavaScript"},{"title":"listent-different-sounds","text":"* <https://github.com/rafaelmardojai/blanket>","type":"text/markdown","created":"20230327170427807","creator":"oeyoews","modified":"20230327170442176","modifier":"oeyoews","tags":""},{"title":"llm","text":"large language model","type":"text/markdown","created":"20230418110526439","creator":"oeyoews","modified":"20230418110536993","modifier":"oeyoews","tags":""},{"title":"load-animation","text":"<div class=\"shadow rounded-md p-4 max-w-sm w-full mx-auto\" data-loading>\r\n  <div class=\"animate-pulse flex space-x-4\">\r\n    <div class=\"rounded-full bg-slate-200 h-10 w-10\"></div>\r\n    <div class=\"flex-1 space-y-6 py-1\">\r\n      <div class=\"h-2 bg-slate-200 rounded\"></div>\r\n      <div class=\"space-y-3\">\r\n        <div class=\"grid grid-cols-3 gap-4\">\r\n          <div class=\"h-2 bg-slate-200 rounded col-span-2\"></div>\r\n          <div class=\"h-2 bg-slate-200 rounded col-span-1\"></div>\r\n        </div>\r\n        <div class=\"h-2 bg-slate-200 rounded\"></div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>","type":"text/markdown","created":"20230429043648795","creator":"oeyoews","modified":"20230429043945037","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"localstorage","text":"## Several Storage\r\n\r\n* local storage\r\n* seeeion storage\r\n* indexeddb\r\n* web sql\r\n* cookies\r\n* etc\r\n\r\n<hr>\r\n\r\nlocalStorage 最主要的特点是：\r\n\r\n* 在同源的所有标签页和窗口之间共享数据。\r\n* 数据不会过期。它在浏览器重启甚至系统重启后仍然存在。\r\n\r\n```html\r\n<textarea\r\n  style=\"width: 200px; height: 60px\"\r\n  id=\"area\"\r\n  placeholder=\"Write here\"\r\n></textarea>\r\n<br />\r\n<button onclick=\"localStorage.removeItem('area');area.value=''\">Clear</button>\r\n```\r\n\r\n```js\r\n  area.value = localStorage.getItem(\"area\");\r\n  area.oninput = () => {\r\n    localStorage.setItem(\"area\", area.value);\r\n  };\r\n```","type":"text/markdown","created":"20230411074523912","creator":"oeyoews","modified":"20230726045248509","modifier":"oeyoews"},{"title":"localStorage-listener","text":"在 Web 应用中，有多种方法可以实现数据共享。其中一种方式是使用`localStorage`来存储和读取数据，以便多个页面之间可以共享相同的数据。\r\n\r\n使用`localStorage`进行数据共享，有以下几个步骤：\r\n\r\n1. 在一个页面中使用`localStorage.setItem()`方法将要共享的数据存储到`localStorage`中。\r\n2. 在另一个页面中使用`localStorage.getItem()`方法获取保存在`localStorage`中的数据。\r\n3. 在每个页面中使用`window.addEventListener()`方法监听`storage`事件。\r\n4. 当`storage`事件被触发时，使用`localStorage.getItem()`方法获取更新后的最新数据。\r\n\r\n以下是一个简单示例，演示如何在两个页面之间共享数据：\r\n\r\n```plain\r\n// 页面1\r\n// 存储数据\r\nlocalStorage.setItem('name', '张三');\r\n\r\n// 页面2\r\n// 获取数据\r\nconst name = localStorage.getItem('name');\r\nconsole.log(name); // 输出：'张三'\r\n\r\n// 监听 storage 事件\r\nwindow.addEventListener('storage', function(event) {\r\n  if (event.key === 'name') {\r\n    console.log('共享的数据已更新为：' + event.newValue);\r\n  }\r\n});\r\n```\r\n\r\n上述代码在页面 1 中存储了一个名为`name`的数据，然后在页面 2 中通过`localStorage.getItem()`方法获取存储在`localStorage`中的`name`数据。此外，在页面 2 中使用`window.addEventListener()`方法监听`storage`事件，以便在该数据发生更改时获取通知。当在页面 1 中更改`name`数据时，将触发`storage`事件，在页面 2 中会输出提示消息。\r\n\r\n需要注意的是，由于`localStorage`在同一个域名下的所有页面之间共享，因此，这种数据共享方式受到同源策略的限制，无法实现跨域数据共享。同时，为了避免数据冲突，在使用`localStorage`共享数据时，应该根据数据的使用场景和业务需求，制定良好的数据处理规则，避免不同页面之间的数据误操作。","type":"text/markdown","created":"20231002060625732","creator":"oeyoews","modified":"20231002060646179","modifier":"oeyoews","tags":"JavaScript"},{"title":"lodash","text":"Lodash 是一个流行的 JavaScript 实用工具库，提供了许多常见的函数和方法，可以帮助我们更加方便地操作数值、字符串、对象、数组等各种数据类型。Lodash 已经被广泛应用于 Web 开发、移动端开发、服务器端开发等多个领域。\r\n\r\n以下是几个 Lodash 中常用的方法：\r\n\r\n1. map：循环遍历数组或对象，并对其中的每个元素进行处理，返回处理后的新数组或对象。\r\n\r\n```javascript\r\n_.map([1, 2, 3], function(n) { return n * 2; });\r\n// => [2, 4, 6]\r\n```\r\n\r\n2. filter：过滤出符合条件的数组元素，并返回一个新的数组。\r\n\r\n```javascript\r\n_.filter([1, 2, 3, 4, 5, 6], function(n) { return n % 2 == 0; });\r\n// => [2, 4, 6]\r\n```\r\n\r\n3. reduce：对数组中的元素进行累加处理，并返回结果。\r\n\r\n```javascript\r\n_.reduce([1, 2, 3], function(sum, n) { return sum + n; }, 0);\r\n// => 6\r\n```\r\n\r\n4. find：查找符合条件的第一个数组元素，并返回该元素。\r\n\r\n```javascript\r\nvar users = [\r\n  { 'user': 'barney',  'age': 36, 'active': true },\r\n  { 'user': 'fred',    'age': 40, 'active': false },\r\n  { 'user': 'pebbles', 'age': 1,  'active': true }\r\n];\r\n\r\n_.find(users, function(o) { return o.age < 40; });\r\n// => { 'user': 'barney', 'age': 36, 'active': true }\r\n```\r\n\r\n以上是 Lodash 中的几个常用方法，Lodash 还提供了许多其他实用的函数和方法，可以根据需要使用。","type":"text/markdown","created":"20230503024016290","creator":"oeyoews","modified":"20230503024030308","modifier":"oeyoews","tags":"JavaScript"},{"title":"Map","text":":::abstract\n一击命中\n:::\n\nmap 是什么呢？在 JavaScript 中，map 是一种数据结构，用于存储键值对的集合。与普通的对象不同，map 的键可以是任意类型的值，包括基本类型和对象等。map 的键值对可以使用 set()方法添加，使用 get()方法获取。map 还有一些常用的方法，包括 has()判断是否存在某个键、delete()删除某个键值对、clear()清空所有的键值对等。下面是一个使用 map 的示例：\n\n```javascript\nconst myMap = new Map(); // 创建一个空的map\n\n// 使用set()方法添加键值对\nmyMap.set('name', '张三');\nmyMap.set('age', 18);\nmyMap.set({x: 1, y: 2}, '一个对象');\n\n// 使用get()方法获取键对应的值\nconsole.log(myMap.get('name')); // 输出：张三\nconsole.log(myMap.get('age')); // 输出：18\nconsole.log(myMap.get({x: 1, y: 2})); // 输出：undefined（注意这里的对象不是同一个对象）\n\n// 使用has()方法判断是否存在某个键\nconsole.log(myMap.has('name')); // 输出：true\nconsole.log(myMap.has('gender')); // 输出：false\n\n// 使用delete()方法删除某个键值对\nmyMap.delete('age');\nconsole.log(myMap); // 输出：Map(2) { 'name' => '张三', { x: 1, y: 2 } => '一个对象' }\n\n// 使用clear()方法清空所有的键值对\nmyMap.clear();\nconsole.log(myMap); // 输出：Map(0) {}\n```\n\nmap 是一种非常有用的数据结构，可以用于解决很多问题，比如需要存储键值对的场景、需要按照某种顺序存储元素的场景等.\n\n键的唯一性：在 Map 中，每个键都是唯一的，不会出现重复的键。这意味着你可以使用任意类型的值作为键，并确保键的唯一性。\n\n保持插入顺序：与普通的对象不同，Map 会维护插入键值对的顺序。这意味着当你迭代 Map 时，键值对的顺序与插入顺序保持一致。\n\n支持任意类型的键：在 Map 中，你可以使用任意类型的值作为键，包括字符串、数字、布尔值、对象或其他 Map。这使得 Map 对象非常灵活，适用于各种场景。\n\n可以快速地查找、插入和删除：Map 提供了一系列方法来操作键值对，包括 get() 获取值、set() 设置值、has() 判断键是否存在、delete() 删除指定的键值对等等。这些方法的时间复杂度通常是 O(1)，因此在大多数情况下，操作 Map 的效率非常高。\n\n可以使用迭代器遍历：Map 支持迭代器，可以使用 for...of 循环或 forEach() 方法来遍历键值对。这使得处理和操作 Map 中的数据变得非常方便。","type":"text/markdown","created":"20230527134522636","creator":"oeyoews","modified":"20231028001527916","modifier":"Lenovo","tags":"JavaScript"},{"title":"maple-hand","text":"maple hand","type":"text/markdown","created":"20230418020812656","creator":"oeyoews","modified":"20230418020825469","modifier":"oeyoews","tags":""},{"title":"margin-order","text":"* top right bottom left(clock)","type":"text/markdown","created":"20230320142410777","creator":"oeyoews","modified":"20230320142427677","modifier":"oeyoews","tags":""},{"title":"Markdown","text":"Markdown 是一种轻量级的标记语言，用于简单、易读易写的文本格式化。它具有简洁明了的语法，可以快速转换为 HTML 或其他格式，并广泛用于编写文档、博客、注释和文本编辑器中。Markdown 使得文本排版变得简单直观，使用者可以通过简单的符号和结构来标记标题、列表、链接、代码块等，以达到格式化和呈现内容的目的。","type":"text/markdown","created":"20230611095609502","creator":"oeyoews","modified":"20230726045248510","modifier":"oeyoews"},{"title":"Markdown-Abbr-Extensions","text":"## Tiddlywiki 相关术语解释\r\n\r\n* Tiddlywiki\r\n* 太微\r\n* 太记\r\n* ...\r\n\r\n*[Tiddlywiki]: TiddlyWiki is a unique non-linear personal web notebook that allows users to create, organize, and share content in a highly flexible and customizable manner. It is an open-source wiki software written in JavaScript and designed to run entirely in the web browser. TiddlyWiki is known for its simplicity, portability, and powerful features.\r\n*[太微]: Chinese Name of Tiddlywiki\r\n*[太记]: About TidGi is an privatcy-in-mind, automated, auto-git-backup, freely-deployed Tiddlywiki knowledge management Desktop note app, with local REST API. \r\n\r\n*[...]: Coming","type":"text/markdown","created":"20230612012307399","creator":"oeyoews","modified":"20230726045248510","modifier":"oeyoews"},{"title":"markdown-parser","text":"markdown 本身为了简化，支持的功能不多，但是在不同的规范下写出的扩展，可以让 markdown 功能相对较多，因此也就出现了每个 markdown 编辑器支持不同程度的上的扩展，比如 mermaid，markdown 自然是不带 mermaid 解析的，代码块高亮一般是有 highlight.js 实现的，与此同时也在一定程度上导致 markdown 有一定的割裂，并且在一定程度上依赖相关的 app，就像 edge chrome， firefox 一样， 每个浏览器都对各种特性有着自己的兼容度，并没有完全统一，因此造成了开发者要不断进行浏览器兼容的工作，很是让人头疼","type":"text/markdown","created":"20231009125450153","creator":"Lenovo","modified":"20231009125459358","modifier":"Lenovo","tags":"markdown"},{"title":"markdown-resume","text":"* <http://cv.ftqq.com/?fr=github#>","type":"text/markdown","created":"20230330054016526","creator":"oeyoews","modified":"20230330054028655","modifier":"oeyoews","tags":""},{"title":"markdown注释","text":"```plain\r\n[//]: # xxx\r\n```\r\n\r\n但是不通用(maybe), 在 tw 里面, 需要去掉#","type":"text/markdown","created":"20230828090513183","creator":"oeyoews","modified":"20230828090657213","modifier":"oeyoews","tags":""},{"title":"memos-docker-compose","text":"\r\n```bash\r\ndocker-compose up -d  #docker-compose.yml`\r\n```\r\n\r\n\r\n```yml\r\nversion: \"3.0\"\r\nservices:\r\n  memos:\r\n    image: neosmemo/memos:latest\r\n    container_name: memos\r\n    volumes:\r\n      - ~/.memos/:/var/opt/memos\r\n    ports:\r\n      - 5230:5230\r\n```","type":"text/markdown","created":"20230209155025075","creator":"oeyoews","modified":"20230331131833810","modifier":"oeyoews","publish":"public","tags":""},{"title":"MethodChaining","text":"方法链（Method Chaining）是一种编程技术，它允许在一个对象上连续地调用多个方法，而不需要每次调用都使用一个中间变量保存对象的引用。通过方法链，可以在一行代码中依次调用多个方法，并且每个方法的返回值都是该对象本身，从而可以在同一个对象上连续地调用多个方法。\r\n\r\n方法链的语法通常是在对象上直接调用一个方法，然后在该方法的返回值上继续调用另一个方法，以此类推。例如：\r\n\r\n```js\r\nobj.method1().method2().method3();\r\n```\r\n\r\n```js\r\n// obj method\r\n\r\nclass Person {\r\n  constructor() {\r\n    this.name = \"John\";\r\n    this.age = 30;\r\n  }\r\n  log1 = () => {\r\n    console.log(\"one\");\r\n    return this;\r\n  };\r\n\r\n  log2 = () => {\r\n    console.log(\"two\");\r\n    return this;\r\n  };\r\n}\r\n\r\nconst p = new Person();\r\np.log1().log2();\r\n```\r\n\r\n上述代码中，obj 是一个对象，method1、method2 和 method3 是该对象上的三个方法。通过方法链的方式，可以依次调用这三个方法，并且每个方法的返回值都是该对象本身，所以可以连续调用下一个方法。\r\n\r\n方法链的好处是可以使代码更加简洁和易读，尤其是在需要对同一个对象执行多个连续操作的情况下。它可以减少临时变量的使用，并且可以在一行代码中清晰地表达多个操作的逻辑关系。\r\n\r\n需要注意的是，方法链并不适用于所有情况，特别是当某个方法的返回值类型与后续方法不兼容时，方法链就无法继续进行。此外，过度使用方法链可能会导致代码可读性下降，因此在使用方法链时需要根据具体情况进行权衡和选择。","type":"text/markdown","created":"20230612052402680","creator":"oeyoews","modified":"20230726045248512","modifier":"oeyoews","tags":"JavaScript"},{"title":"microfeed-oeyoews","text":"> <https://microfeed-oeyoews.pages.dev/>\r\n\r\n* use tailwindcss to custom style\r\n* 可以同时在线预览和在线修改后台文章\r\n\r\n* 以<https://oeyoews.fun 为例>， 可以预览文章 <https://oeyoews.fun/admin> 可以登陆后台进行编辑文章\r\n\r\n## 优点\r\n\r\n* 支持 rss\r\n* 文章发布全部在线完成（也支持本地或者服务器部署）\r\n\r\n## 缺点\r\n\r\n* 后台的 visual editor， 不支持 markdown 编辑器\r\n* 不支持文章导入","type":"text/markdown","created":"20230330024846540","creator":"oeyoews","modified":"20230330060723282","modifier":"oeyoews","publish":"article","tags":""},{"title":"microsoft-activate-scripts","text":"This microsoft activate scripts support hack windows and office\nhttps://github.com/massgravel/Microsoft-Activation-Scripts\n\n```powershell\nirm https://massgrave.dev/get | iex\n```\n\n:::tip\nsupport install office and activate office, 不需要下载  [[office-tool-plus]]\n:::","type":"text/markdown","created":"20230414082233061","creator":"oeyoews","modified":"20231009143102787","modifier":"Lenovo","tags":"windows"},{"title":"Microsoft-office365","text":"https://otp.landian.vip/zh-cn/\n\n> download office and activate ","type":"text/markdown","created":"20230824140636872","creator":"oeyoews","modified":"20231009132808479","modifier":"Lenovo","tags":"windows"},{"title":"MIME","text":"MIME 是多用途互联网邮件扩展（Multipurpose Internet Mail Extensions）的缩写，它是一种互联网标准，用于描述和标记各种类型的数据文件，特别是用于电子邮件传输。MIME 类型帮助定义了文件的内容类型，使邮件客户端和网络服务器能够正确地解释和处理不同类型的附件，如文本、图像、音频和视频文件。这有助于确保电子邮件中的内容能够正确地显示和处理。\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types","type":"text/markdown","created":"20231014092420005","creator":"Lenovo","modified":"20231014092442508","modifier":"Lenovo","tags":"名词"},{"title":"minify-recurive-jsfiles","text":"```js\nimport fs from 'fs';\nimport path from 'path';\nimport { spawn } from 'cross-spawn';\n\nfunction findJsFilesInDirectory(directory) {\n  const jsFiles = [];\n\n  function findFiles(dir) {\n    const files = fs.readdirSync(dir);\n\n    for (const file of files) {\n      const filePath = path.join(dir, file);\n      const stat = fs.statSync(filePath);\n\n      if (stat.isDirectory()) {\n        if (file !== 'files') {\n          // 过滤名为 \"files\" 的目录\n          findFiles(filePath);\n        }\n      } else if (filePath.endsWith('.js')) {\n        jsFiles.push(filePath);\n      }\n    }\n  }\n\n  findFiles(directory);\n  return jsFiles;\n}\n\nconst targetDirectory = 'plugins/oeyoews';\nconst jsFiles = findJsFilesInDirectory(targetDirectory);\n\nfor (const jsFile of jsFiles) {\n  const baseName = path.basename(jsFile, '.js');\n  const outputMinJs = path.join(path.dirname(jsFile), `${baseName}.min.js`); // 构建输出文件名\n  const terserProcess = spawn('terser', [jsFile, '-o', outputMinJs]);\n\n  terserProcess.on('close', (code) => {\n    if (code !== 0) {\n      console.error('Terser process exited with code', code);\n    }\n  });\n}\n```","type":"text/markdown","created":"20231021054743835","creator":"Lenovo","modified":"20231021054802362","modifier":"Lenovo","tags":""},{"title":"missing-thinkup","text":"<https://kookma.github.io/TWE-Mehregan/>","type":"text/markdown","created":"20230117133758553","creator":"oeyoews","modified":"20230117133808717","modifier":"oeyoews","tags":""},{"title":"mkdocs","text":"{{||headerTemplate}}\n\nmarkdown-more 插件就是模仿的它,也许有利于迁移","type":"text/markdown","created":"20231019045202613","creator":"Lenovo","modified":"20231019051300052","modifier":"Lenovo","tags":"","url":"https://squidfunk.github.io/mkdocs-material/getting-started/"},{"title":"mobile-tw-app","text":"如果不优化响应式 UI（一款 tw 中确实的 theme plugin）， 编辑体验，开发 tw 的手机 app 没有太多的意义\n\n完全本地： 支持同步， 增删改🍵\nserver： 连接 server","type":"text/markdown","created":"20231009125516671","creator":"Lenovo","modified":"20231009125526059","modifier":"Lenovo","tags":""},{"title":"module-type","text":"一个 JavaScript 模块的 module-type 字段是一个用于标识模块类型的字符串。下列为此维基中使用的模块类型：\r\n\r\n* allfilteroperator\r\n* all 筛选器算子的子算子。\r\n* animation\r\n* 动画模块包含可用于 RevealWidget 的动画。\r\n* authenticator\r\n* 定义内置 HTTP 服务器对请求的身份验证方式。\r\n* bitmapeditoroperation\r\n* 一个位图编辑器工具栏操作。\r\n* command\r\n* 可于 Node.js 执行的指令。\r\n* config\r\n* 加入 $tw.config 的数据。\r\n* filteroperator\r\n* 个别筛选器算子方法。\r\n* filterrunprefix\r\n* formatfilteroperator\r\n* global\r\n* 加入 $tw 的全域数据。\r\n* indexer\r\n* info\r\n* 透过 $:/temp/info-plugin 伪插件，发布系统信息。\r\n* isfilteroperator\r\n* is 筛选器算子的运算符。\r\n* library\r\n* 一般用途的 JavaScript 模块的通用模块类型。\r\n* macro\r\n* JavaScript 宏定义。\r\n* parser\r\n* 不同内容类型的解析器。\r\n* route\r\n* 定义内置 HTTP 服务器如何处理各个网址格式。\r\n* saver\r\n* 于浏览器保存文件的不同的保存处理方法。\r\n* startup\r\n* 启动时期的功能函数。\r\n* storyview\r\n* 查看模式用以自订 list 小部件的动画与行为。\r\n* texteditoroperation\r\n* 一个文本编辑器工具栏操作。\r\n* tiddlerdeserializer\r\n* 转换不同内容类型至条目。\r\n* tiddlerfield\r\n* 定义个别条目栏位的行为。\r\n* tiddlermethod\r\n* 添加方法至 $tw.Tiddler 原型。\r\n* upgrader\r\n* 于升级/导入过程中，套用升级处理至条目。\r\n* utils\r\n* 添加方法至 $tw.utils。\r\n* utils-node\r\n* 将特定于 Node.js 的方法添加到 $tw.utils。\r\n* widget\r\n* 封装 DOM 渲染和刷新的小部件。\r\n* widget-subclass\r\n* wikimethod\r\n* 添加方法至 $tw.Wiki。\r\n* wikirule\r\n* WikiText 解析器的个别的语法规则。","type":"text/markdown","created":"20230605105014869","creator":"oeyoews","modified":"20230726045248512","modifier":"oeyoews","tags":"TiddlyWiki"},{"title":"monaco","text":"摩纳哥是一个位于欧洲的城邦国家，位于法国蔚蓝海岸的一小片土地上。它以豪华度假胜地和博彩业闻名。摩纳哥还以每年的蒙特卡洛大赛而闻名，这是一场国际著名的方程式赛车比赛。该国有着美丽的地中海海岸线、精致的餐厅和豪华的度假胜地，吸引着游客和富人前来度过他们的假期。如果您对摩纳哥有更具体的问题，欢迎提出。","type":"text/markdown","created":"20231022090839463","creator":"Lenovo","modified":"20231022090928057","modifier":"Lenovo","tags":"名词"},{"title":"Monorepo","text":"Monorepo 是一种软件开发的管理方法，它可以帮助开发者更好地管理大型项目、团队协作和代码共享等方面的问题。具体来说，Monorepo 是指将多个相关项目组合成一个单独的存储库（或代码库）中，这些项目可以是不同的应用、服务、工具库或者是其他类型的代码库。\r\n\r\n使用 Monorepo 的主要优点包括：\r\n\r\n- 代码共享：不同项目之间可以共享代码，避免重复编写或复制粘贴代码，减少冗余代码。\r\n- 统一构建、测试和部署：由于所有项目都在同一个代码库中，因此可以方便地进行统一的构建、测试和部署。\r\n- 统一的开发规范：可以统一项目的开发规范，例如代码格式、依赖管理等，提高代码的可维护性和可读性。\r\n- 更好的团队协作：不同开发者可以更容易地共享代码、协作开发以及解决问题。\r\n\r\n然而，Monorepo 也存在一些缺点：\r\n\r\n- 单点故障：所有项目都在同一个代码库中，如果出现了严重的问题可能会影响到整个代码库的稳定性。\r\n- 版本管理较为复杂：不同项目之间的版本号需要进行管理，否则可能导致代码的兼容性问题。\r\n- 构建时间较长：由于需要构建所有项目，因此构建时间可能比较长。\r\n\r\n在实际使用 Monorepo 时，可以采用一些工具来辅助管理，例如 Lerna、Yarn Workspaces 等。这些工具可以帮助开发者更好地管理 Monorepo 中的依赖关系、版本控制等问题，提高开发效率。\r\n\r\n总之，Monorepo 是一种管理大型项目和团队协作的方法，它可以带来一些好处，但也需要注意其缺点，根据实际情况选择合适的方案。","type":"text/markdown","created":"20230502054312303","creator":"oeyoews","modified":"20230502054322664","modifier":"oeyoews","tags":"JavaScript"},{"title":"mozjpeg","text":"* but this conflict libjpeg-turbo","type":"text/markdown","created":"20230405140818387","creator":"oeyoews","modified":"20230405140835886","modifier":"oeyoews","tags":""},{"title":"ms","text":"maxsmall\r\n\r\nxs: extra small","type":"text/markdown","created":"20230411125641026","creator":"oeyoews","modified":"20230414131449911","modifier":"oeyoews","tags":""},{"title":"multi-cursor","text":"`alt click` multi cursor","type":"text/markdown","created":"20230424122617057","creator":"oeyoews","modified":"20230424122656629","modifier":"oeyoews","tags":"Vscode"},{"title":"multi-lines","text":"`shift enter` use multi line","type":"text/markdown","created":"20230429011314584","creator":"oeyoews","modified":"20230429011338350","modifier":"oeyoews","tags":"Tips"},{"title":"multi-useEffect","text":"可以在同一个组件中使用多个 useEffect hook。每个 useEffect hook 是独立的，可以用于添加不同的副作用。\r\n\r\n例如，您可能希望在组件挂载时初始化一些数据，然后在某些数据发生更改时更新其他数据。这可以通过在同一个组件中使用多个 useEffect hook 来实现。\r\n\r\n以下是一个示例，其中一个 useEffect 用于初始化数据，另一个 useEffect 用于在 id 发生更改时更新数据：\r\n\r\n```jsx\r\nfunction MyComponent({ id }) {\r\n  const [data, setData] = useState(null);\r\n\r\n  // This effect runs once, when the component mounts\r\n  useEffect(() => {\r\n    // Initialize data\r\n    setData(fetchData(id));\r\n  }, [id]);\r\n\r\n  // This effect runs whenever `id` changes\r\n  useEffect(() => {\r\n    // Update data\r\n    setData(fetchData(id));\r\n  }, [id]);\r\n\r\n  // Render the component\r\n  return <div>{data}</div>;\r\n}\r\n```\r\n\r\n在此示例中，第一个 useEffect 在组件挂载时初始化 data，第二个 useEffect 在 id 更改时更新 data。这两个 useEffect 是独立的，它们可以在同一个组件中使用，而不会相互干扰。","type":"text/markdown","created":"20230429013228147","creator":"oeyoews","modified":"20230726045248518","modifier":"oeyoews","tags":"React"},{"title":"mutations","text":"```js\r\n// 要观察的元素\r\nconst targetElement = document.getElementById(\"my-element\");\r\n\r\n// 创建 MutationObserver 对象\r\nconst observer = new MutationObserver((mutations) => {\r\n  console.log(\"元素变化啦！\", mutations);\r\n\r\n  // 隐藏按钮\r\n  const button = document.getElementById(\"my-button\");\r\n  button.style.display = \"none\";\r\n});\r\n\r\n// 指定要观察的元素以及要观察的变化类型\r\nobserver.observe(targetElement, { childList: true, attributes: true, subtree: true, characterData: true });\r\n```","type":"text/markdown","created":"20230609130544421","creator":"oeyoews","modified":"20230726045248518","modifier":"oeyoews","tags":"JavaScript"},{"title":"mvc-mvvm","text":"MVC（Model-View-Controller）和 MVVM（Model-View-ViewModel）是两种常见的前端应用程序架构模式，它们的主要区别如下：\r\n\r\n1. 模型与视图的关系不同：在 MVC 中，视图和模型是分离的。控制器作为桥梁，将模型和视图链接在一起。而在 MVVM 中，视图通过数据绑定直接绑定到 ViewModel 上，ViewModel 与模型交互并提供必要的方法。\r\n\r\n2. 数据双向绑定：MVVM 引入了数据双向绑定的概念，使得视图和 ViewModel 之间的交互更加便捷。当 ViewModel 中的数据发生变化时，视图会自动更新；当用户在视图中输入数据时，ViewModel 会自动更新数据模型。\r\n\r\n3. 控制器与 ViewModel 的区别：MVVM 中没有控制器的概念，而是引入了 ViewModel。ViewModel 既可以处理视图的显示逻辑，也可以与模型进行交互。而控制器则只负责处理视图和模型之间的通信。\r\n\r\n4. 独立性不同：在 MVC 中，视图、模型和控制器都是独立的组件，彼此之间没有强耦合。而在 MVVM 中，ViewModel 是视图和模型之间的桥梁，它们之间的联系更加紧密。\r\n\r\n总的来说，MVC 和 MVVM 都是优秀的前端应用程序架构模式，它们各有优缺点，适用于不同的场景和需求。对于需要频繁更新视图的复杂单页应用程序，MVVM 更为适合；而对于传统的多页 Web 应用程序，MVC 则更加适用。","type":"text/markdown","created":"20230503031328980","creator":"oeyoews","modified":"20230503031338437","modifier":"oeyoews","tags":"JavaScript"},{"title":"mvvm","text":"Vue.js 和 React.js 是两个不同的 JavaScript 框架，都可以用于构建现代 Web 应用程序。在数据绑定方面，Vue.js 使用了 MVVM（Model-View-ViewModel）模式，而 React.js 使用了单向数据流模式。\r\n\r\nMVVM 模式将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。视图是用户界面，模型是数据层，而视图模型则是连接两者之间的桥梁。在 Vue.js 中，Vue 实例作为视图模型，处理用户交互和渲染输出。当数据更新时，Vue 的响应式系统会自动更新 DOM 元素。\r\n\r\nReact.js 没有显式地使用 MVVM 模式，而是基于单向数据流的思想。React.js 中的组件是基于数据的，当数据发生变化时，React.js 会重新计算和渲染组件，然后更新 DOM 元素。React.js 还提供了一种称为“hooks”的特性，使开发人员能够更好地管理组件状态和行为。\r\n\r\n因此，尽管 Vue.js 和 React.js 都可以用于构建现代 Web 应用程序，它们在数据绑定方面采用了不同的方法。Vue.js 使用了 MVVM 模式，而 React.js 使用了单向数据流模式。","type":"text/markdown","created":"20230426041236183","creator":"oeyoews","modified":"20230426041253870","modifier":"oeyoews","tags":"React Vue"},{"title":"myst.js","text":"https://github.com/executablebooks/mystjs\r\n\r\nMyst.js 是一个工具集，用于使用 Markdown 和 Jupyter Notebooks 创建交互式文档。它是由 Executable Books 项目开发的开源项目。\r\n\r\nMyst.js 扩展了 Markdown 的功能，允许您通过添加数学方程、代码单元格、交互式小部件等功能来创建丰富的交互式内容。它与 Jupyter Notebooks 集成，使您可以将 Jupyter 的交互式计算环境的强大功能与 Markdown 的简洁灵活性相结合。\r\n\r\n使用 myst.js，您可以编写结合了解释性文本、代码片段、可视化和其他媒体元素的文档。这些文档可以转换为不同的格式，如 HTML、PDF 和 LaTeX，使您能够以不同的方式共享您的工作成果。\r\n\r\n您提供的 GitHub 存储库为 myst.js 提供了源代码、文档和使用示例。它为希望在项目中利用 myst.js 功能的开发人员和用户提供了资源。\r\n\r\n如果您有兴趣使用 myst.js 或了解更多信息，我建议访问该存储库，并探索提供的文档和示例。","type":"text/markdown","created":"20230612155840979","creator":"oeyoews","modified":"20230726045248518","modifier":"oeyoews"},{"title":"navbar","text":"<nav class=\"flex items-center justify-between bg-gray-800 p-4 sticky\">\r\n  <div class=\"flex items-center\">\r\n    <a href=\"#\" class=\"text-white text-xl font-semibold\">\r\n      <!-- 这里放置你的图标 -->\r\n\t\t\tdemo\r\n      <i class=\"fas fa-icon\"></i>\r\n    </a>\r\n  </div>\r\n  <div class=\"flex\">\r\n    <a href=\"#\" class=\"text-gray-300 mx-2 hover:text-white\">链接1</a>\r\n    <a href=\"#\" class=\"text-gray-300 mx-2 hover:text-white\">链接2</a>\r\n    <a href=\"#\" class=\"text-gray-300 mx-2 hover:text-white\">链接3</a>\r\n  </div>\r\n</nav>\r\n\r\n`justify-between` 是 Tailwind CSS 中的一个类，用于在 Flex 容器中将项目（子元素）以两端对齐的方式排列。它会在主轴（水平方向）上将项目拉伸以填充剩余空间，并在项目之间创建平均的空间分配。\r\n\r\n具体来说，`justify-between` 类可以用于以下场景：\r\n\r\n1. 创建两端对齐的导航栏：将 `justify-between` 应用于导航栏容器，使导航栏中的链接或按钮分散对齐。\r\n\r\n2. 创造两端对齐的工具栏或选项卡：将 `justify-between` 应用于工具栏或选项卡容器，使工具或选项在两端对齐，并在宽度上平均分配剩余空间。\r\n\r\n3. 实现两端对齐的网格布局：将 `justify-between` 应用于网格容器，使网格中的单元格以两端对齐的方式布局，从而产生平均分配的效果。\r\n\r\n这只是 `justify-between` 的一些常见用途。Tailwind CSS 提供了许多其他实用的 Flexbox 类，可用于处理布局和对齐。你可以根据自己的需求组合使用不同的类来创建灵活且强大的布局。","type":"text/markdown","created":"20230724070256937","creator":"oeyoews","modified":"20230726045248519","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"neotw-archive","text":"<<tree prefix:\"neotw\" separator:\"-\">>","type":"text/markdown","created":"20231017081803157","creator":"Lenovo","modified":"20231017082202751","modifier":"Lenovo","tags":""},{"title":"neotw-docker-filestruct","text":"```bash\n📂 wiki(任意目录名字)\n   ├── 🐋 docker-compose.yml(docker compose 配置文件)\n   └── 📂 wiki(wiki目录, 名字由docker-compose.yml决定)\n       ├── 📂 files\n       ├── 🔒 subwiki(私密wiki)\n       ├── 📂 tiddlers(wiki内容)\n       └── 📦 tiddlywiki.info(系统配置信息)\n```","type":"text/markdown","created":"20231017023959440","creator":"Lenovo","modified":"20231017024019021","modifier":"Lenovo","tags":"TiddlyWiki"},{"title":"neotw-git","text":"### Reverd\r\n\r\n* git revert id    # 会有冲突出现  ？\r\n\r\n### Log\r\n\r\n* git log --stat    # 查看变动的具体文件\r\n* git reflog    # show local log\r\n* git log --all --graph   #查看所有的分支记录  直观\r\n* git log --all -n 4 --graph  --oneline     # 结合  部分的参数\r\n\r\n### Misc\r\n* git -b develop https://github.com/…… # only to clone a appointment\r\n* git ls-remote  //  detail\r\n\r\n### Status\r\n* git show -sb\r\n\r\n### Count\r\n* git rev-list --count branch_name\r\n\r\n### Gc\r\n- git gc\r\n\r\n### Show\r\n* git show main:readme.md\r\n\r\n### Tag\r\n* git tag name\r\n* git tag -a tagname commit_id\r\n- git tag -a v2.0.1 -m \"demo test\"\r\n- git tag -d v2.0.1\r\n- git push origin :refs/tags/v2.0  delete remote tags\r\n- git checkout v2.0\r\n* git push --tags\r\n\r\n### Reset\r\n* git reset -- filename  or git restore --staged/-S filename\r\n* git restore file (workspace)\r\n* git reset --hard id / tag\r\n\r\n### Diff\r\n* git diff main dev\r\n* git diff --staged\r\n\r\n### Gitignore\r\n* doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\r\n* 匹配模式最后跟\"/\"说明要忽略的是目录\r\n* 可以忽略该仓库的所有文件,不用写递归的路径\r\n* deploy*/   # 忽略以 deploy 开头任意字符结束的目录\r\n\r\n### Remote\r\n* git remote rm origin           # 删除已经关联的远程仓库\r\n* git remote add github git@github:oeyoews/src-gitee.git\r\n* git remote [-v]\r\n\r\n### Branch\r\n* git branch -vv # only show local branchh\r\n* git  branch branchname   # 建立新分支\r\n* git branch –d branchname （D,force delete）\r\n* git branch -m old new # only to local, can't modify remote repo\r\n- git branch -m main        # current branch\r\n* git branch -a/-r\r\n\r\n### Checkout\r\n\r\n* git checkout -- name //使用 head 的最新内容替换工作目录的内容 LL ( only workspace)\r\n* git checkout branchname         # switch anotherbranch (git branch dev    && git checkout dev)\r\n* git checkout --orphan=new-br    #  根据当前的分支，生成新的分支，但是没有提交记录，只能提交才能看到新的分支\r\n* git checkout --merge branch\r\n* git checkout . # restore the current directory to lasted commits\r\n* git checkout filename # in workspace\r\n* git checkout -                  # 切换到上个分支\r\n\r\n### Push\r\n* git push -f\r\n* git pull -p # 在拉去的时候自动删除远程分支已经不存在的本地分支  prune\r\n* git push --all origin # 将本地的所有分支推送到远程主机，不论是否存在与否\r\n* `git push origin  branchname`   # 将新的分支推送到远端\r\n* 也可以进行强行推送（not recommend），直接把远程仓库覆盖掉\r\n* `git push origin  master --force`\r\n* `git push origin  :master`\r\n表示推送一个空的分支到远程的 master 分支。相当于删除远程的 master 分支；\r\n等同`git push origin --delete master`\r\n`git push -all origin`\r\n 不管远程仓库是否存在相应的分支，将本地的所有的分支全部推送上去。\r\n`git push -f  origin`\r\n`git push -f -u origin master`\r\n版本回退 但是会抹去远程库的提交信息 首先进行本地的版本回退，由于进行里本地的版本回滚，版本将落后于远程分支，因此必须要使用强制推送进行版本覆盖，然后进行向远程仓库强制推送  master 为默认本仓库创建的第一个分支， 而 origin 为默认是指向这一个仓库，相当于别名\r\n\r\n### Commit\r\n* git commit -am ' '  // commit file message already added\r\n\r\n### Merge\r\n* git branch --merged    # 显示已经合并到当前分支的分支列表  --no-merged\r\n* git pull  --rebase origin master  # 根据远端的 readme 生成 readme 文件，在本地生成 readme 文件\r\n* git push -f gitee master      # 强制上传，覆盖掉远端的文件（注意，远端确定没有重要的文件）\r\n* git push origin --all # 推送所有的分支到远程仓库\r\n* git push -u origin bugs    #    将本地的 bugs 分支推送到远程的 bugs，如果没有则会被建立，并且建立两者的关联，之后直接使用 git push  就可以\r\n\r\n### Cache\r\n* git rm -r --cached .\r\n* git rm --cached [file]\r\n\r\n### Mv\r\n* git mv xxx xxxx   # 可以在暂存区直接修改，不用再次提交\r\n\r\n### Config\r\n* ~/.gitconfig   # 全局配置文件\r\n* git config --global core.editor vim\r\n* git config --global credential.helper store    # 存储账户密码，但是需要输入一次\r\n* git config -l # 列出 git 的初始化信息。  可以查看当前的仓库链接的是那个具体仓库\r\n* git config --global user.name \"oeyoews\"\r\n* git config --global user.email \"2956398608@qq.com\" # 带有空格\r\n\r\n### Ssh\r\n* ssh-keygen\r\n* ~/.ssh/id_ras.pub\r\n* ssh -T git@github.com\r\n\r\n### Multi_repository_address\r\n* 在.git 文件里面的 url 下面添加一个新的 url，可以同时推送到 github 和 gitee 上。\r\n\r\n### Gitlab\r\n* settings -> general -> advance  # 修改 clone 的地址 gitlab\r\n\r\n### Enhance_speed\r\n* https://raw.githubusercontent.com/ 进行了代理，地址为 https://raw.fastgit.org/ 。\r\n\r\n### GitReset\r\n`git reset --hard id`\r\nhard 表示将工作区 暂存区 版本库记录 恢复到某一定版本，commit 的信息会被删除，并且不会保存之前错误的源码， id 不确定要写几位，一般写前面几位就行了，git 会自动寻找   HEAD 表示当前版本\r\n`git reset  --mixed`\r\n> 等于 `git reset` ，会保留源码，就是之前的所有提交信息都会被保留，只是将 commit 和 index 的信息回退，即更改指针的指向,reset 的指针向后移动了，删除里一些 commit，而 revert 的指针是一直向前的，在 commit 之后有 commit 一次\r\n\r\n### Relative_web\r\n[thin_large_repository](https://gitee.com/help/articles/4232#article-header0)\r\n[auto push in gitlab github gitee](https://www.cnblogs.com/sxdcgaq8080/p/10530176.html)\r\n[Linux and Git](https://www.tag1consulting.com/blog/interview-linus-torvalds-linux-and-git)\r\n\r\n### git_submoudle(子模块)\r\n- https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97\r\n- git clone url --recurse-submoudles\r\n- git submodule init && git submoudle update\r\n- git submoudle update --init --recursive\r\n- git submoudle add url /path/name\r\n- git submoudle update --remote\r\n\r\n### git pull\r\n- git pull origin --depth 1 develop:main\r\n\r\n### commit\r\n- git commit -m \" empty commit \" --allow-empty\r\n\r\n- git remote set-url ... // change remote url\r\n\r\n- git fetch (get all branches ???)\r\n\r\n### Note\r\n\t\r\n- if a new file never recorded by git, even you switch new branch, modify anyaway, it's influencd for all branch\r\n- and if the file is recorded, if you don't add or Commit to switch another branch, it's will fetch current file jobs to\r\n  next branch, unless you commit it's job\r\n","type":"text/markdown","created":"20230609121653253","creator":"oeyoews","modified":"20231002105017411","modifier":"oeyoews"},{"title":"neotw-gource","text":"`gource --output-custom-log my-project-custom.log`\r\n\r\n(V)   Toggle camera mode\r\n(C)   Displays Gource logo\r\n(K)   Toggle file extension key\r\n(M)   Toggle mouse visibility\r\n(N)   Jump forward in time to next log entry\r\n(S)   Randomize colours\r\n(D)   Toggle directory name display mode\r\n(F)   Toggle file name display mode\r\n(U)   Toggle user name display mode\r\n(G)   Toggle display of users\r\n(T)   Toggle display of directory tree edges\r\n(R)   Toggle display of root directory edges\r\n(+-)  Adjust simulation speed\r\n(<>)  Adjust time scale\r\n(TAB) Cycle through visible users\r\n(F12) Screenshot\r\n(Alt+Enter) Fullscreen toggle\r\n(ESC) Quit\r\nq w\r\n","type":"text/markdown","modified":"20230726045248547","modifier":"oeyoews"},{"title":"neotw-lua","text":"## lua\n\n[make_lua_plugin](https://www.2n.pl/blog/how-to-write-neovim-plugins-in-lua)\n\n###  NOTE\n- unpack(v5.1)  ==> table.unpack(v5.4)\n\n    lspinstaller site: .local/share/lsp-servers/...\n\n    system yay site : /usr/libs/lua……(by pkgbuild)\n\n### logical operator\n- and: if has false, return fasle\n- or: if has true (this order is not important), return this true\n\n    path: /usr/share/lua/5.1...\n\n    print(package.path)\n\n### Type\n- number string\n- nil boolean function\n- table userdata thread\n\n","type":"text/markdown","created":"20230609122224832","creator":"oeyoews","modified":"20231017081625284","modifier":"Lenovo"},{"title":"neotw-nginx","text":"## nginx\r\n- ports confict to docker's nginx 8080\r\n- how to config this config : change this default directory\r\n- sudo systemctl reload nginx.versice\r\n\r\n","type":"text/markdown","modified":"20230726045248552","modifier":"oeyoews"},{"title":"neotw-question","text":"## libreoffice\r\n\r\n- page number: right click, to select style and setup first page options\r\n\r\n## Gnome workspace\r\n\r\n- up and down in dash dock to switch workspace\r\n\r\n## Github\r\n\r\n- [ ] github project's item archived, how to check out?\r\n\r\n## latex\r\n\r\n- [ ] how to type arrrange number?\r\n\r\n## wiki\r\n\r\n- [ ] learn short tiddlywiki\r\n\r\n## tiddlywiki\r\n\r\n  <!--- [x] how to add ico image for tiddlywiki website(how to add exist ico)-->\r\n\r\n- bug: add other plugins to tiddylwikidesktop, this app will exit(for 太微 拼音插件)\r\n- bug: ~~save to github is still bug, save is keep fail~~, this push speed very slow\r\n- note: don't use tiddly plugin, it's hard to uninstall plugin, and more troubles, less is simple, is more\r\n\r\n## github\r\n\r\n   plain - notes: git checkout -b dev [commitid]\r\n\r\n## debug\r\n\r\n   plain - when have browser cache, don't use to clean the cache, just open private mode to debug it\r\n\r\n## gnome another clipboard\r\n\r\n   plain - clipboard indicator\r\n\r\n## soft\r\n\r\n   plain - notable\r\n\r\n## note\r\n\r\n   plain - roam research\r\n    - renotexxx\r\n    - logseq\r\n    - zotero\r\n    - Zettelkasten\r\n\r\n## soft\r\n\r\n- agenda in gnome\r\n- gnome-todo\r\n  - gthumb\r\n\r\nsetsid\r\n(cmd)\r\n\r\npm2 to generate systemd\r\nicon-theme papirus\r\npapirus-folders\r\npapirus-folders -C breeze --theme Papirus-Dark\r\n.icons /usr/share/icons\r\n","type":"text/markdown","created":"20230609121759561","creator":"oeyoews","modified":"20230726045248638","modifier":"oeyoews"},{"title":"neotw-ranger","text":"## Ranger\r\nr # choose open file's tool.\r\n\r\n[ or ] # choose parent folder.\r\n\r\nzh or ctrl h  to show hidden files.\r\n\r\ncw # rename file_name. or use 'a' 'A'\r\n\r\ni  # preview like vim but not vim for work.\r\n\r\nv  or space  # select file\r\n\r\nw # task manager.\r\n\r\nalways look for github_wikis.\r\n\r\ntsz -i file_name.\r\n\r\n## Rename\r\n- cw\r\n- a\r\n\r\nS   //进入指定的文件夹，进入一个新的终端，退出当前的终端，会再次回到 ranger 中\r\n\r\n/ #search\r\n\r\ngg G # same vim\r\n\r\nyy dd pp # 复制剪切 粘贴\r\n\r\nf # 查找\r\n\r\nA # 在当前的基础上进行重命名\r\n\r\nI  # 同上   same vim\r\n\r\ndD   # 彻底删除\r\n\r\n  on/ob   根据文件名进行排序(natural/basename)\r\n  oc      根据改变时间进行排序 (Change Time 文件的权限组别和文件自身数据被修改的时间)\r\n  os      根据文件大小进行排序(Size)\r\not      根据后缀名进行排序 (Type)\r\n\r\n  oa      根据访问时间进行排序 (Access Time 访问文件自身数据的时间)\r\nom      根据修改进行排序 (Modify time 文件自身内容被修改的时间)\r\n\r\n  zp   # 预览代码\r\n\r\n  zP # 打开目录预览\r\n\r\n  cat file_name | tsz\r\n\r\n  cd ~/.config/ranger/rifle.conf\r\n  export RANGER_LOAD_DEFAULT_RC=FALSE\r\n  sudo pacman -S  --noconfirm libcaca highlight atool lynx w3m elinks  mediainfo   # install  depencies\r\n\r\n#找出含有 docx 的一行，然后将其注释起来：\r\n#ext docx?, has catdoc,       terminal = catdoc -- \"$@\" | \"$PAGER\"\r\n  s # enter this shell environment.\r\n  git clone https://github.com/alexanderjeurissen/ranger_devicons ~/.config/ranger/plugins/ranger_devicons\r\n  echo \"default_linemode devicons\" >> $HOME/.config/ranger/rc.conf   # add devicons\r\n\r\n  - ranger --copy-config=all  # configure some files\r\n  - [ranger_tutor](https://blog.csdn.net/lxyoucan/article/details/115671189)\r\n\r\n- can't start because of version?\r\n- rm -rf .local/share/ranger/*\r\n\r\n- f (like fzf)\r\n","type":"text/markdown","modified":"20230726045248642","modifier":"oeyoews"},{"title":"neotw-shellscripts","text":"## some shell brackets\n\n```bash\n@shell\n- $() and \\`\\`:  命令替换\n- $(()) : 数学计算，**等运算符号不会被shell解析其他含义\n- $[] : 数学计算， need \\*\n- (()): 支持高级运算， 比如++\n- ${} : 变量替换引用\n- () : 数组变量\n- []: 等同于test\n- [[ ]]: 提供字符串比较(add two space)\n- {}: codeblock\n\n@endshell\n```","type":"text/markdown","created":"20231017081600299","creator":"Lenovo","modified":"20231017081605604","modifier":"Lenovo"},{"title":"neotw-soft","text":"## Gnome\n  - gnome-shell-extension-tray-icons-reloaded\n  - locks\n  - GPaste\n  - kimpanel\n\n      <!-- # (note: if turn on input method panel , all fcitx skin will don't work)-->\n      <!--- gnome-shell-extension-kimpanel-->\n- gnome: dash-to-dock\n- gnome-keyring\n    <!-- # gnome-shell-extension-unite-->\n- cdate\n    <!-- ## like ps painting-->\n    <!--yay gtk-theme-mackos-mojave-->\n    <!--gtk-theme-macos-sierra-archers-git-->\n- fcitx5-material-color\n\n## Office\n- libreoffice-fresh\n- freeoffice\n    <!--- manjaro-settings-manjaro   # kernel manager-->\n    <!--- visual-studio-code-bin     # vscode-->\n- python-pip\n    <!--- xunlei-bin-->\n    <!-- # (xtreme download manager)-->\n    <!-- # xdm-->\n    <!-- # powertop # 耗电分析-->\n    <!-- # mysql tool-->\n    <!-- # system clipboard link-->\n    <!--- neovim(python-pynvim)-->\n\n    <!--- lolcat-->\n    <!-- # ls -al | xclip-->\n    <!-- # gufw-->\n    <!-- # xclip-->\n    <!-- # pacman-->\n    <!-- # grep enhanced, like grep-->\n- ripgrep\n    <!-- # like du -sh-->\n- dust(show curren directory)\n- duf(show disk)\n\n    <!--fzf-->\n    <!--+tree+-->\n\n##  bootiso\n\n  - ventoy\n  - rufus（Windows）\n  - etcher [etcher-link](https://www.balena.io/etcher/)\n\n##  IME\n\n> 使用 fcitx5-im（with pacman)无效？？？ 需要分开装\n\n- fcitx5-im\n -  manjaro-asian-input-support-fcitx5\n- fcitx5-pinyin-zhwiki\n    - fcitx5-pinyin-moegirl\n    - fcitx5-chinese-addons\n\n- jdk8-openjdk\n    <!-- # fgit                       # hub.fastgit.org-->\n    <!-- # deskreen                   # 投屏软件-->\n    <!-- # idea-->\n    <!-- # intellij-idea-ultimate-edition-->\n    <!-- # filezilla # file transfer-->\n    <!-- # npm fast open repo-->\n    <!-- # yay-->\n    <!-- # pip install magic-wormhole-->\n    <!--sudo pacman -S -->\n    <!--- magic-wormhole-->\n    - git-open\n\n##  MusicPlayer\n  - mpv (Q save time)\n  - moc(cli: mocp)\n  - rhythmbox\n  - yesplaymusic\n  - netease-musicbox\n  - lx-music-desktop-bin\n  - clementine(support podcast)\n  - museeks\n\n## picture show\n- inkscape\n\n<!-- # fast find config-->\n<!-- # sudo updatedb-->\n<!-- # comannd: locate [file-name]-->\nmlocate\n\n\n<!--- bat-->\n- tokei\n- procs\n\n    <!--seq-->\n    shuffle(command is shuf)\n\n## better pdf\n- xournal\n\n    <!-- ## download youtube video-->\n    <!--- you-get-->\n    <!--- youtube-dl-->\n\n- awesome-terminal-fonts\n\n##  mysql tools\n- dbeaver\n\n    icdiff\n\n\n<!--* FileManager-->\n<!--- ncdu-->\n<!--- scrapy-->\n<!--- ranger [ranger](https://wiki.archlinux.org/title/Ranger_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))-->\n\n\n##  MarkdownEditor\n  - typora-free\n  - marktext\n  - mdp\n  - slides(terminal presentation)\n  - reveal-md(by npm)\n      <!--- glow-->\n      <!--- agenta(just for macos)-->\n      <!--- joplin(cli desktop)-->\n      <!--- zettlr-->\n      <!--- siyuan(no recomment)-->\n      <!--- obsidian(not recomment)-->\n      <!--- mdcat-->\n      <!--- zim-->\n      <!--- mindforger-->\n      <!--- simplenote-->\n\n      <!--* UML-->\n      <!--- staruml-->\n      <!--- drawio-->\n\n\n<!--- figlet-->\n  - bullshit\n  - asciiquarium\n      <!--- tty-clock-->\n\n      -<!--diff tools-->-\n      delta\n      meld\n\n      <!--like ping -->\n      <!--tracert(maybe is window)-->\n      traceroute(linux)\n\n      -<!--editor-->-\n- kakoune\n- simiki\n\n\n<!--qtcreater-->\n\n<!---comment---->\n<!--gittalk-->\n\n--chm--\n\n<!----image---->\nimagemagick(cmd: display)\n\n\n<!-- # git repository play video-->\n<!--- gource-->\n\n##  Image\n  - picgo [picgo](https://picgo.github.io/PicGo-Doc/zh/guide/config.html#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E9%A2%84%E8%A7%88)\n\n##  Dictionary\n  - wudao-dict-git\n  - clone this repository to .local/share\n  - dict-cli [link](https://github.com/FeeiCN/dict)\n  - translate-shell\n  - artha\n  - crow-translate\n\n* Editor\n  - lyx\n  - geany\n      <!--- doge-->\n\n      ---\n##  System\n  - base-devel\n  - trash-cli\n  - nodejs-lts-erbium # 12.xxx\n  - tmux\n  - lunar-date\n  - utools(recomment system: window)\n  - shellcheck\n  - cloc\n  - htop\n  - btop(c++)\n  - gtop\n  - gotop(like htop be made by go)\n  - gpaste\n\n##  Brower\n  - google-chrome\n  - firefox\n  - microsoft-edge-beta-bin\n\n- fastfetch\n\n* Tools\n  - ttyd\n      <!--- cheat(deprecated)-->\n  - stow\n  - idea-music\n  - downgrade\n\n##  Video\n  - obs                        # record video\n  - kooha\n  - gromit-mpx(painting)\n  - flameshot [flameshot-link](https://github.com/flameshot-org/flameshot)\n\n##  Typing expercise\n  - ttyper(tty-best)\n  - typespeed\n  - ktouch\n  - klavaro\n  - tuxtype\n  - wpm(use pip)\n  - ff(self in omz/src)(tty_best)\n      <!--- ff -n [nu]-->\n      <!--- ff -n 22 -g 4-->\n      <!--- ff -quotes en-->\n      <!--- ff -t 30-->\n\n##  Font\n  - Fira Code\n\n      <!--- [*] Tmp-->\n      <!--- tig-->\n  - mycli\n      <!--- `ranger`-->\n      <!--ncdu-->\n      <!--anbox-->\n- pamac\n    <!--- remmina-->\n\n    <!--* Nothing-->\n  - glade(ui)\n      <!--- bat-->\n\n      <!--font-manager-->\n\n* Space\n  - celestia\n  - stellarium\n  - musescore\n\n  - tldr(tealdeer made by go)\n  - gg\n  - switychomega\n  - nvui\n\n##  terminal\n  - wezterm\n  - kitty\n  - alacritty\n\n  - qbitorrent\n\n      <!--* 内网-->\n      <!--- natapp-->\n      <!--- nload-->\n      <!--- dstat(network)-->\n      <!--- iftop-->\n      <!--- diff-so-fancy-->\n\n##  Image Viewer\n  - gimp\n  - mypaint\n  - krita\n  - inscape\n  - nomacs\n  - ristretto\n  - feh\n  - viu(in terminal, show your terminal)\n  - xnviewmp\n\n      <!--* Pdf-->\n      <!--- [_]   vym(view your mind)(deprecated)-->\n## Reader Viewer\n  - foxit reader\n  - obular\n  - kchmviewer\n  - calibre\n  - foliate                    # book read\n\n##  Video editor\n  - kdenlive\n  - opentoonz\n\n  * passline(in github)\n<!-- ## ppt on web-->\n   plain   <!---  beamer(todo)-->\n","type":"text/markdown","created":"20230609121320383","creator":"oeyoews","modified":"20231017081544724","modifier":"Lenovo"},{"title":"neotw-tar","text":" ## tar\r\n\r\n```bash\r\n tar xvf ... # tar a file\r\n tar zcvf back.tar.gz 1.html 2.html  # - can ben ignore  or use backup.tgz\r\n tar zxvf path/demo.tar.gz # zip demo.tar.gz\r\n tar ztvf 1.tgz # show files about 1.tgz\r\n tar zxvf 1.tgz 1.c # unzip some files in 1.tgz ?\r\n tar zcvf 1.tgz 1.cpp -w # show second confirm\r\n\r\n tat zxvf 1.tgz -C <path> # 将tgz 包解压到制定的目录\r\n\r\n z  --- 利用gzip方式进行压缩文件信息\r\n c  --- creat 创建出一个压缩包\r\n t  list\r\n v  --- 显示压缩数据过程\r\n f  --- 指定压缩包保存路径\r\n```","type":"text/markdown","created":"20230520082239562","creator":"oeyoews","modified":"20230726045248663","modifier":"oeyoews"},{"title":"neotw-tmux","text":"## Tmux\r\n\r\nctrl + a /  ctrl + b      # prefix\r\n\r\nprefix -  # 垂直平分 窗口\r\n\r\n`prefix> C-c`表示您必须先按 Ctrl+a 或 Ctrl+，b 再按 Ctrl+c\r\n\r\nprefix C c  # 新建会话  creat\r\n\r\nprefix s   # 选择窗口 select    安装 x 进行关闭窗口\r\nprefix ?   # show all shortkeys\r\nprefix and press x   # 关闭整个 tmux\r\n\r\nprefix  d # 临时退出 tmux   deattch\r\n\r\ntmux  a -t  (nu)  # 连接已经存在的 session  panel->window->session\r\n\r\ntmux ls   # 列出所有的 window\r\n\r\nprefix t  # show time\r\n\r\nprefix [   # 进入复制模式    进入可视模式    prefix ] 粘贴\r\n\r\nq # 退出\r\n\r\nprefix nu # 切换窗口\r\n\r\n*  tmux  new -s daily # creat a session called daily.\r\n*  C-b , # rename this window's name\r\n*  C-b w # show all window\r\n*  tmux kill-session -t session-name # kill one session\r\n*  tmux kill-pane -t pane-name .\r\n*  tmux a # defult to connect the first session.\r\n*  C-b z # zoom in or reset this pane\r\n*  C-b r # source this .tumu.conf\r\n*  [tmux-tutor](https://louiszhai.github.io/2017/09/30/tmux/#%E4%BF%9D%E5%AD%98Tmux%E4%BC%9A%E8%AF%9D)\r\n\r\n# tips\r\n- pgrep tmux\r\n- prefix z  // zoom panel\r\n- prefix m // toggle mouse mode\r\n","type":"text/markdown","modified":"20230726045248664","modifier":"oeyoews"},{"title":"neotw-translate","text":"## translate\r\n\r\n```plain\r\n* trans -T\r\nhttps://github.com/soimort/translate-shell\r\nhttps://www.clloz.com/programming/assorted/2019/11/19/translate-shell-usage/\r\nbug: translate a text file, ues it will failed again\r\nfix: ip close your ladder network! and you can use `trans --debug \"hello, translate-shell\" to find problem from this debug info\r\nyour ladder is used by abuntant\r\ntrans(late-shell)\r\ntrans --speak demo\r\ntrans -R\r\ntrans -I/E\r\nto chinese\r\ntrans :zsh demo\r\ntrans en:ja -p\r\ntrans -id demo\r\ntrans :fr url(file:///)\r\ntrans -browser firefox :fr http://www.w3.org/\r\ntrans -S\r\ntrans -M\r\ntrans :ja xxx -p -b\r\n```\r\n","type":"text/markdown","created":"20230808063345844","creator":"oeyoews","modified":"20230808063402152","modifier":"oeyoews"},{"title":"Neovim","text":"Neovim 是一个高度可定制的文本编辑器，被广泛应用于编写代码和文本处理。它是 Vim 编辑器的一个分支，旨在改进 Vim 的一些缺陷和限制。Neovim 提供了许多新的特性和功能，包括异步任务支持、插件管理、Lua 脚本支持、更好的 Windows 支持等等。它的目标是成为一个现代化的、可扩展的编辑器，适用于各种编程语言和开发环境。\r\n\r\nNeovim 的设计理念是可定制性和可扩展性。它提供了许多配置选项和插件接口，使用户可以根据自己的需求定制编辑器的行为和外观。同时，它的插件系统非常强大，可以轻松地安装和管理各种插件，包括语法高亮、代码补全、文件管理、版本控制等等。这些插件可以为用户提供更好的开发体验和生产力。\r\n\r\nNeovim 的另一个重要特性是异步任务支持。它允许用户在编辑器中执行异步任务，例如编译代码、运行测试、执行 shell 命令等等。这些任务可以在后台执行，不会阻塞用户的编辑流程，提高了编辑器的响应性和效率。\r\n\r\nNeovim 是一个功能强大、可定制、可扩展的编辑器，非常适合程序员和文本处理者使用。它的广泛应用和活跃的社区使它成为了一个流行的编辑器之一。","type":"text/markdown","created":"20230610123232908","creator":"oeyoews","icon":"neovim.svg","modified":"20230726045248715","modifier":"oeyoews"},{"title":"neovim-0.9","text":"you should update tree-sitter to latest, if you got this \r\n\r\n```shell\r\nnvim: symbol lookup error: nvim: undefined symbol: ts_tree_included_ranges\r\n```","type":"text/markdown","created":"20230408131023896","creator":"oeyoews","modified":"20230409013032549","modifier":"oeyoews","tags":""},{"title":"neovim-personal-plugins","text":"| PluginName | Feature |\r\n| ------ | ---- |\r\n| Comment.nvim | 在代码中添加和编辑注释 |\r\n| autolist.nvim | 为代码提供自动完成列表 |\r\n| bufferline.nvim | 显示和管理缓冲区的标签栏 |\r\n| cmp-buffer | 为自动完成插件 nvim-cmp 提供缓冲区补全功能 |\r\n| cmp-nvim-lsp | 为自动完成插件 nvim-cmp 提供 LSP 补全功能 |\r\n| cmp-nvim-ultisnips | 为自动完成插件 nvim-cmp 提供 UltiSnips 补全功能 |\r\n| cmp-path | 为自动完成插件 nvim-cmp 提供路径补全功能 |\r\n| cmp-tw2css | 为自动完成插件 nvim-cmp 提供 Tailwind CSS 补全功能 |\r\n| codeium.vim | 用于编辑和运行代码的插件 |\r\n| dressing.nvim | 为代码添加注释、空行等装饰性功能 |\r\n| gitsigns.nvim | 在代码编辑器中显示 Git 状态和修改 |\r\n| icon-picker.nvim | 在编辑器中选择和插入图标 |\r\n| indent-blankline.nvim | 在代码缩进处显示可见的空白符号 |\r\n| lazy.nvim | 为 Vim 提供延迟加载插件的功能 |\r\n| leap.nvim | 快速跳转和查找符号定义的插件 |\r\n| live-server.nvim | 在浏览器中实时预览 HTML、CSS 和 JavaScript 文件 |\r\n| lsp-format.nvim | 格式化代码的 LSP 插件 |\r\n| lspsaga.nvim | 提供 LSP 的附加功能和增强体验 |\r\n| lualine.nvim | 创建状态栏和标签栏的 Lua 插件 |\r\n| markdown-preview.nvim | 在浏览器中预览 Markdown 文件 |\r\n| mason-lspconfig.nvim | 为 LSP 提供配置的 Lua 插件 |\r\n| mason-null-ls.nvim | 提供 LSP 的空白补全功能 |\r\n| mason-tool-installer.nvim | 用于安装和管理开发工具的插件 |\r\n| mason.nvim | 为 Vim 提供构建、测试和运行项目的功能 |\r\n| neodev.nvim | 管理和操作 NeoVim 的插件 |\r\n| neogen | 为 Vim 提供代码生成和代码片段功能 |\r\n| nui.nvim | 在 Neovim 中创建用户界面的 Lua 框架 |\r\n| null-ls.nvim | 为 LSP 提供缺失的功能和补全 |\r\n| nvim-autopairs | 自动补全括号、引号等字符的插件 |\r\n| nvim-cmp | 提供快速、智能的代码补全框架 |\r\n| nvim-colorizer.lua | 在编辑器中高亮显示颜色代码 |\r\n| nvim-lspconfig | 配置和管理 LSP 的 Lua 插件 |\r\n| nvim-notify | 在 Neovim 中显示通知消息 |\r\n| nvim-surround | 通过快捷键为代码添加、删除、修改周围的符号 |\r\n| nvim-toggler | 在代码中切换开关的插件 |\r\n| nvim-tree.lua | 在侧边栏显示文件树的 Lua 插件 |\r\n| nvim-treesitter | 用于语法高亮和代码分析的插件 |\r\n| nvim-treesitter-refactor | 为 nvim-treesitter 提供重构功能 |\r\n| nvim-ts-autotag | 自动添加和关闭 HTML、XML 标签的插件 |\r\n| nvim-ts-rainbow | 为括号添加彩虹色彩的插件 |\r\n| nvim-web-devicons | 在编辑器中显示文件类型图标 |\r\n| nvim_context_vt | 在状态栏显示当前函数和变量的上下文信息 |\r\n| plenary.nvim | 提供 Lua 函数的实用工具集 |\r\n| ranger.nvim | 在 Neovim 中浏览和管理文件的插件 |\r\n| tailwindcss-colors.nvim | 提供 Tailwind CSS 颜色的补全和预览 |\r\n| telescope.nvim | 为文件查找、模糊查找、代码搜索等提供强大的模糊查找框架 |\r\n| tokyonight.nvim | 漂亮的主题配色方案 |\r\n| trim.nvim | 为当前行和选定文本提供剪切和删除的功能 |\r\n| ultisnips | 用于创建和使用代码片段的插件 |\r\n| vim-quickrun | 快速运行代码的插件 |\r\n| vim-snippets | 提供丰富的代码片段库 |\r\n| vim-tiddlywiki | 在 Vim 中编辑 TiddlyWiki 笔记 |\r\n| which-key.nvim | 在按键时显示可用的按键绑定和命令列表的插件 |","type":"text/markdown","created":"20230610130526107","creator":"oeyoews","modified":"20230726045248715","modifier":"oeyoews","tags":"Neovim"},{"title":"neovim-plugin","text":"* Neovim 插件一般是对 core 功能的二次封装, 只不过是增加易用性, 便捷性; \r\n\r\n* 核心与插件之间的关系更符合低耦合高内聚原则\r\n\r\n> 核心应该尽可能地独立和稳定，不应该依赖于插件。插件应该尽可能地独立和可移植，不应该依赖于特定版本的核心。同时，核心和插件之间应该有良好的接口和协议，以便插件可以与核心进行交互和通信。这种低耦合高内聚的关系可以使程序更加灵活和可扩展。","type":"text/markdown","created":"20230610121817720","creator":"oeyoews","modified":"20230726045248739","modifier":"oeyoews"},{"title":"NerdFont","text":"Nerd Font 是一种开源字体项目，旨在扩展常见等宽字体的功能，使其适用于开发人员和计算机爱好者。Nerd Font 将大量图标、图形和特殊字符添加到字体中，以增强其在代码编辑器和终端应用程序中的使用。\r\n\r\nNerd Font 最初基于 Font Awesome 项目，但现在已经扩展到支持其他常见的图标集，如 Devicons、Powerline、Octicons 等。它还提供了一些额外的补充字符，如箭头、数学符号、终端相关符号等。\r\n\r\nNerd Font 具有以下特点和优势：\r\n\r\n1. 图标支持：Nerd Font 包含了大量的图标和符号，用于表示文件类型、操作系统、版本控制工具、编程语言等。这些图标可以用于代码编辑器、终端提示符、文件管理器等应用中，使其更加可视化和有趣。\r\n\r\n2. 等宽字体：Nerd Font 大多数情况下都是等宽字体，这对于编写和排列代码非常有用，可以使代码在屏幕上对齐整齐，提高可读性。\r\n\r\n3. 兼容性：Nerd Font 兼容许多常见的编辑器和终端应用程序，包括 Vim、Emacs、Visual Studio Code、Sublime Text、iTerm2、Hyper 等。因此，你可以在自己喜欢的开发环境中使用 Nerd Font。\r\n\r\n4. 开源和可定制性：Nerd Font 是一个开源项目，你可以自由地使用、修改和贡献代码。你可以根据自己的喜好和需求进行定制，添加或删除特定的符号和图标。\r\n\r\n要使用 Nerd Font，你需要先下载并安装所选的字体文件。然后，在你的编辑器或终端应用程序中选择该字体作为显示字体。一旦设置完成，你就可以在代码中使用 Nerd Font 提供的图标和符号了。\r\n\r\n总的来说，Nerd Font 是一个为开发人员和计算机爱好者设计的字体项目，它通过添加图标和特殊字符，提供了更丰富的视觉元素，使代码编辑和终端应用程序使用更加有趣和便捷。","type":"text/markdown","created":"20230611161938920","creator":"oeyoews","modified":"20230726045248740","modifier":"oeyoews"},{"title":"network-type","text":"```js\r\nnavigator.connection\r\n```","type":"text/markdown","created":"20230926105235914","creator":"oeyoews","modified":"20230926105259297","modifier":"oeyoews","tags":"JavaScript"},{"title":"new-obj","text":"当我们使用 `new` 关键字创建一个对象时，实际上会发生下面三件事情：\r\n\r\n1. 创建一个空的 JavaScript 对象。\r\n2. 将该对象的原型指向构造函数的原型。\r\n3. 将该对象作为 `this` 关键字传递给构造函数，并执行构造函数。\r\n\r\n因此，在使用 `new` 关键字创建对象时，我们通常可以直接将对象赋值给变量，而不需要先将变量声明并赋值为 `null` 或 `undefined`。这是因为 `new` 关键字会自动为我们创建一个对象并将其赋值给变量。\r\n\r\n例如，我们可以这样创建一个对象：\r\n\r\n```js\r\nconst obj = new Object();\r\n```\r\n\r\n在这个例子中，我们使用 `new` 关键字创建了一个空的 `Object` 对象，并将其赋值给 `obj` 变量。这个过程可以简写成下面这样：\r\n\r\n```js\r\nconst obj = {};\r\n```\r\n\r\n这样就创建了一个空的对象，并将其赋值给 `obj` 变量。","type":"text/markdown","created":"20230609143145197","creator":"oeyoews","modified":"20230726045248741","modifier":"oeyoews","tags":"JavaScript"},{"title":"nextjs-bug","text":"fetch errored","type":"text/markdown","created":"20231107032812235","creator":"Lenovo","modified":"20231107032840419","modifier":"Lenovo","tags":""},{"title":"NLP","text":"NLP（Natural Language Processing）是自然语言处理的缩写。它是计算机科学、人工智能和语言学等多个学科交叉的研究领域，旨在使计算机能够理解、处理、生成自然语言。\r\n\r\nNLP 的研究主要包括以下几个方面：\r\n\r\n1. 语音识别：将口述的文本转化为可处理的文本形式。\r\n\r\n2. 语音合成：将计算机生成的文本转化为口述的形式。\r\n\r\n3. 自然语言理解：通过分析和理解自然语言的语义、语法、情感等维度，使得计算机能够理解自然语言的含义。\r\n\r\n4. 自然语言生成：根据特定情境下的需求和背景知识，生成符合语法、含义及语用规则的文本。\r\n\r\n5. 机器翻译：利用计算机技术将一种语言的文本转化为另一种语言的文本。\r\n\r\n6. 文本分类：对文本进行分类，如情感分析、垃圾邮件过滤、新闻分类等。\r\n\r\n7. 命名实体识别：从文本中识别出人名、地名、组织机构名等特定实体。\r\n\r\nNLP 在现代社会中越来越重要，应用范围广泛，比如语音识别、智能客服、机器翻译、文本分析等。","type":"text/markdown","created":"20230502142831442","creator":"oeyoews","modified":"20230502142851588","modifier":"oeyoews","tags":""},{"title":"no-phone-me","text":"https://zhuanlan.zhihu.com/p/112518029","type":"text/markdown","created":"20230628023928644","creator":"oeyoews","modified":"20230726045248742","modifier":"oeyoews"},{"title":"node-browser-cros","text":"在浏览器中，由于安全原因，存在同源策略(Same-Origin Policy)的限制。同源策略是一种安全机制，它阻止了通过脚本从一个源加载的文档或脚本访问另一个源的内容，除非这两个源具有相同的协议、主机名和端口号。\n\n跨域请求是指在浏览器环境下，通过脚本发起的 HTTP 请求，其目标地址与当前页面的主机、端口或协议不一致。浏览器会根据同源策略进行安全限制，通常会导致跨域请求失败。\n\n而在 Node.js 环境中，没有同源策略的限制。Node.js 是一个基于 V8 引擎的 JavaScript 运行时环境，用于服务器端开发。在 Node.js 中，你可以使用内置的`http`模块或第三方库（例如`node-fetch`）进行 HTTP 请求，并且不会受到同源策略的限制。\n\n当你在 Node 环境中使用`fetch`函数发送跨域请求时，服务器不会对请求的源进行同源策略的检查，因此可以成功获取跨域资源。这使得 Node.js 成为一个强大的工具，可以用于爬虫、数据抓取等需要访问其他域上资源的场景。\n\n需要注意的是，尽管在 Node.js 环境下可以跨域访问资源，但在浏览器中依然会受到同源策略的限制。如果你需要在浏览器中进行跨域请求，可以通过使用 CORS（跨域资源共享）或 JSONP 等技术进行解决。","type":"text/markdown","created":"20231104084254000","creator":"Lenovo","modified":"20231104084321812","modifier":"Lenovo","tags":"JavaScript"},{"title":"NodeList","text":"`NodeList` 是一个类数组对象，它包含一组 `Node` 对象，这些对象通常是由 `querySelectorAll` 方法返回的。`NodeList` 对象具有以下特点：\r\n\r\n- 它是一个类数组对象，它的每个成员都是一个 `Node` 对象。\r\n- 它是只读的，不能修改它的成员。\r\n- 它是动态的，意味着它会随着文档的变化而自动更新。\r\n\r\n你可以使用 `NodeList` 对象的属性和方法来访问和操作它的成员。例如，你可以使用 `length` 属性获取 `NodeList` 对象的长度，使用 `item` 方法或方括号语法访问 `NodeList` 对象的成员，使用 `forEach` 方法迭代 `NodeList` 对象的成员，等等。\r\n\r\n以下是一个使用 `NodeList` 对象的示例：\r\n\r\n```js\r\n// 获取所有 p 元素\r\nconst paragraphs = document.querySelectorAll('p');\r\n\r\n// 获取 paragraphs 的长度\r\nconst length = paragraphs.length;\r\n\r\n// 访问 paragraphs 的第一个元素\r\nconst firstParagraph = paragraphs[0];\r\nconst firstParagraph2 = paragraphs.item(0);\r\n\r\n// 迭代 paragraphs 中的每个元素\r\nparagraphs.forEach((paragraph) => {\r\n  console.log(paragraph.textContent);\r\n});\r\n```\r\n\r\n在这个例子中，我们使用 `querySelectorAll` 方法获取了所有 `p` 元素，并将它们存储在一个 `NodeList` 对象 `paragraphs` 中。然后，我们使用 `length` 属性获取 `paragraphs` 的长度，使用方括号语法和 `item` 方法访问 `paragraphs` 的第一个元素，使用 `forEach` 方法迭代 `paragraphs` 中的每个元素，并在控制台中打印每个段落元素的文本内容。\r\n\r\n\r\n```js\r\n// 创建 MutationObserver 对象\r\nconst observer = new MutationObserver((mutations) => {\r\n  console.log(\"tc-story-river 元素变化啦！\", mutations);\r\n\r\n  // 暂停观察目标元素\r\n  observer.disconnect();\r\n  copyButton();\r\n  // 恢复观察目标元素\r\n  observer.observe(document.querySelector(\".tc-story-river\"), {\r\n    childList: true,\r\n    subtree: true,\r\n  });\r\n});\r\n\r\n// 指定要观察的元素选择器以及要观察的变化类型\r\nobserver.observe(document.querySelector(\".tc-story-river\"), {\r\n  childList: true,\r\n  subtree: true,\r\n});\r\n```","type":"text/markdown","created":"20230609130758352","creator":"oeyoews","modified":"20230726045248742","modifier":"oeyoews","tags":"JavaScript"},{"title":"noreferrer","text":"当您使用一个链接（标签）将用户从您的站点带到另一个站点时，为了保护您的站点安全，应该在链接中添加 rel=\"noreferrer\" 属性。\r\n\r\n这个属性指示浏览器不要向其他站点提供任何更多的信息（即 referrer 信息），例如从哪里来的访问者和他们在您的站点上做了什么。这可防止其他站点通过 referrer 信息了解您的站点的敏感信息。\r\n\r\n下面是一个可能的链接示例，演示了如何添加 rel=\"noreferrer\" 属性：\r\n\r\n<a href=\"https://www.example.com\" target=\"_blank\" rel=\"noreferrer\">\r\n\tExample Website\r\n\t</a>\r\n\r\n在这个示例中，我们为 href 属性设置了一个外部链接地址，并在 target 属性中使用了 \"_blank\" 以在新标签页中打开该链接。同时，我们还为 rel 属性添加了 \"noreferrer\" 值来指示浏览器禁用 referrer 信息传递。\r\n\r\n需要注意的是，除非您有特殊原因需要传递 referrer 信息，否则最好一直使用 rel=\"noreferrer\" 属性来确保您的站点安全。","type":"text/markdown","created":"20230420033412155","creator":"oeyoews","modified":"20230726045248744","modifier":"oeyoews"},{"title":"not-scale-inlin-ele","text":"scale 对于 inline 无效","type":"text/markdown","created":"20230930075851102","creator":"oeyoews","modified":"20230930075927498","modifier":"oeyoews","tags":"Tailwindcss CSS"},{"title":"npm-dry-run","text":"npm publish --dry-run","type":"text/markdown","created":"20230901063504388","creator":"oeyoews","modified":"20230901063516240","modifier":"oeyoews","tags":""},{"title":"npm-git","text":"npm 如果直接安装 githu 的包, 需要依赖 git","type":"text/markdown","created":"20230905090315280","creator":"oeyoews","modified":"20230905090338988","modifier":"oeyoews","tags":""},{"title":"npm-mirror-tips","text":"```plain\r\nnpm install -g cnpm --registry=https://registry.npmmirror.com\r\ncnpm sync <packagename>\r\n```\r\n\r\n如果 npmmirror, 没有同步过来, 搜索框的补全由 algolia 提供, 此时从命令更新可以更快速","type":"text/markdown","created":"20230831104628491","creator":"oeyoews","modified":"20230831104803359","modifier":"oeyoews","tags":""},{"title":"npm安装sharp出现的问题（安装失败的问题及解决)","text":":::warning sharp bug\n使用 Windows 开发, 你遇到的 bug 数量将会是以前的十倍以上.\n:::\n\n#### [](https://example.com)npm 安装 sharp 库出现的问题及解决\n\n* [npm 安装 sharp 出现的问题及解决：](#npmsharp_2)\n\nBuffer 的使用以及对图片的操作（通过 sharp 库对图片进行操作）\n\n## [](https://example.com)[](https://example.com)npm 安装 sharp 出现的问题及解决\n\n![安装失败的报错](https://img-blog.csdnimg.cn/eaf7aeb9ee9845aba1e6463bfd88d727.png#pic_center)\n\n* 在使用 npm 安装 sharp 一直安装不成功。后面发现安装 sharp 需要依赖 libvips，然后通过查看 npm 路径下的_libvips 文件夹确实为空。（可通过 npm config get cache 查询自己的 npm 存放路径）\n* 后面尝试自己下载 libvips 的安装包，然后在进行安装，发现也还是不行。\n* 最后我是通过修改镜像终于安装成功。\n* 使用镜像地址（仅设置 sharp）：\n\n```plain\nnpm config set sharp_binary_host \"https://npmmirror.com/mirrors/sharp\"\n```\n\n```plain\nnpm config set sharp_libvips_binary_host \"https://npmmirror.com/mirrors/sharp-libvips\"\n```\n\n**sharp 是基于 libvips 的封装，所以在安装的时候会去下载 libvips 的本体，所以最好提前配置好镜像源。**\n\n![安装成功截图](https://img-blog.csdnimg.cn/a610326ec63740718164b69940a82cc1.png)","type":"text/markdown","created":"20231103102116080","creator":"太微搜藏","modified":"20231103102324802","modifier":"Lenovo","tags":"剪藏","url":"https://blog.csdn.net/weixin_53737663/article/details/128958712"},{"title":"nsfw","text":"\"NSFW\" 是英文縮寫，代表 \"Not Safe For Work\"，意思是不適合在工作場合觀看的內容。通常用來警告某些內容可能包含裸露、性暗示或其他不適當的內容，因此在工作環境中應該避免觀看。","type":"text/markdown","created":"20231009130439200","creator":"Lenovo","modified":"20231009130445016","modifier":"Lenovo","tags":""},{"title":"Null-Undefined","text":"- **null**表示一个空值或不存在的对象。当我们将变量初始化为 null 时，意味着它没有被赋予任何值。null 是一个特殊的关键字，用于表示一个空的或无效的对象。例如，如果你有一个指向对象的变量，但是你想要明确地表示该对象为空，你可以将该变量设置为 null。\r\n\r\n  以下是一个示例：\r\n  ```javascript\r\n  let obj = null;\r\n  console.log(obj); // 输出: null\r\n  ```\r\n\r\n- **undefined**表示一个未定义的值。当变量声明但没有被赋值时，它的默认值就是 undefined。此外，如果你访问一个对象的属性或函数，而该对象本身未被定义，那么该属性或函数的值也将是 undefined。\r\n\r\n  以下是一些示例：\r\n  ```javascript\r\n  let x; // 声明一个变量但未赋值\r\n  console.log(x); // 输出: undefined\r\n\r\n  let obj; // 声明一个对象变量但未定义\r\n  console.log(obj.property); // 输出: undefined\r\n  ```\r\n\r\n* 在总结上述区别时，可以将 null 视为已定义但空的值，而 undefined 表示未定义的值。\r\n\r\n* null 是一个表示“空”的对象，转为数值时为 0；undefined 是一个表示\"此处无定义\"的原始值，转为数值时为 NaN。","type":"text/markdown","created":"20230619144051106","creator":"oeyoews","modified":"20230726045248745","modifier":"oeyoews","tags":"JavaScript"},{"title":"number-boolean","text":"```js\r\nport !== Number(PORT) // right\r\n!port === Number(PORT) // wrong !port: port 不是boolean, 是number\r\n```","type":"text/markdown","created":"20230924062036422","creator":"oeyoews","modified":"20230924062222375","modifier":"oeyoews","tags":"JavaScript Bug"},{"title":"obj-clone","text":":::abstract\n其实主要是引用类型, 浅拷贝只能针对基本数据类型\n:::\n\n我们可以通过生活中的例子来更加形象地理解深拷贝和浅拷贝。\n\n假设你有一本书，书中有很多章节，每个章节有许多页，每页上有文字和图片。这本书就可以看作是一个对象，每个章节就是一个数组，每页就是一个对象，文字和图片就是属性值。\n\n现在你想要把这本书借给你的朋友，但是你不想让朋友修改这本书的内容。如果你使用浅拷贝的方式，就相当于把这本书复制了一份，让你的朋友也可以看到这本书，但是你们两个人看到的是同一本书，如果你的朋友在书中做了标记或修改了内容，你也会看到这些标记和修改。\n\n如果你使用深拷贝的方式，就相当于把这本书复制了一份，但是你和你的朋友看到的是两本不同的书，你朋友对他的那本书做了任何修改，都不会影响你看到的那本书。\n\n另外，我们也可以举一个更加简单的例子来理解深拷贝和浅拷贝。假设你有一个盒子，里面放了一个苹果。如果你使用浅拷贝的方式，就相当于你把这个盒子复制了一份，但是两个盒子里面放的还是同一个苹果，如果你从一个盒子里取出苹果，另一个盒子里的苹果也会被取出。如果你使用深拷贝的方式，就相当于你把这个盒子复制了一份，但是两个盒子里面放的是两个完全一样的苹果，如果你从一个盒子里取出苹果，另一个盒子里的苹果还是在原地。\n\n深拷贝（deep copy）和浅拷贝（shallow copy）是在 JavaScript 中经常用到的概念。\n\n浅拷贝是指将一个对象的属性值复制到另一个对象，如果属性值是基本数据类型（如字符串、数字、布尔值等），则复制的是基本数据类型的值；如果属性值是引用数据类型（如数组、对象、函数等），则复制的是内存地址，也就是说两个对象会共享同一个引用类型的值。如果其中一个对象修改了这个引用类型的值，另一个对象也会受到影响。\n\n深拷贝则是将一个对象的所有属性值都复制到另一个对象，包括基本数据类型和引用数据类型。即使原始对象中的引用类型属性值发生了改变，拷贝后的对象中的引用类型属性值也不会受到影响，因为它们指向的是不同的内存地址。\n\n举个例子，如果我们有一个对象 obj1：\n\n```javascript\nconst obj1 = {\n  name: 'Alice',\n  age: 18,\n  hobbies: ['reading', 'dancing'],\n  address: {\n    city: 'Shanghai',\n    street: 'Nanjing Road',\n  },\n};\n```\n\n那么浅拷贝 obj2 可以通过以下方式实现：\n\n```javascript\nconst obj2 = Object.assign({}, obj1);\n```\n\n此时修改 obj1 的 hobbies 属性会影响 obj2：\n\n```javascript\nobj1.hobbies.push('swimming');\nconsole.log(obj2.hobbies); // ['reading', 'dancing', 'swimming']\n```\n\n而深拷贝 obj3 可以通过以下方式实现：\n\n```javascript\nconst obj3 = JSON.parse(JSON.stringify(obj1));\n```\n\n此时修改 obj1 的 hobbies 属性不会影响 obj3：\n\n```javascript\nobj1.hobbies.push('swimming');\nconsole.log(obj3.hobbies); // ['reading', 'dancing']\n```\n\n需要注意的是，JSON.parse(JSON.stringify()) 这种方式虽然可以实现深拷贝，但是它有一些限制，例如无法拷贝函数、正则表达式等特殊对象。在实际开发中，需要根据具体情况选择合适的方式进行拷贝。\n\n\n直接修改 `b` 对象和修改 `b` 对象里面的值是有区别的。\n\n当你直接修改 `b` 对象时，意味着你对 `b` 进行了重新赋值或者指向了另一个对象。这将导致 `b` 引用的对象完全改变，与原始对象不再有任何关联。\n\n而当你修改 `b` 对象里面的值时，即使你修改了 `b` 对象的属性值，但 `b` 仍然指向的是同一个对象。因此，如果其他地方有引用到 `b` 的地方也会受到影响。\n\n\n```javascript\nconst sourceObj = {a: 1, b: {c: 2}};\n\n// 直接修改 b 对象\nsourceObj.b = {d: 3};\nconsole.log(sourceObj); // {a: 1, b: {d: 3}}\n\n// 修改 b 对象里面的值\nsourceObj.b.c = 4;\nconsole.log(sourceObj); // {a: 1, b: {c: 4}}\n```\n\n在第一个例子中，我们直接修改了 `sourceObj.b` 对象，将其重新赋值为 `{d: 3}`。这导致 `b` 引用的对象完全改变，与原始对象 `{c: 2}` 不再有任何关联。\n\n在第二个例子中，我们修改了 `sourceObj.b.c` 的值，而 `b` 仍然指向的是同一个对象。所以，如果其他地方有引用到 `sourceObj.b` 的地方，它们也会看到这个修改。\n\n因此，直接修改 `b` 对象会改变整个对象的结构，而修改 `b` 对象里面的值只是修改了对象内部的属性值。区别在于是否影响到其他引用了该对象的地方。","type":"text/markdown","created":"20230522104023587","creator":"oeyoews","modified":"20231103055759420","modifier":"Lenovo","qrcode":"yes","tags":"JavaScript"},{"title":"obj-to-array","text":"要将 JavaScript 对象转换为数组，你可以使用以下方法：\n\n1. 使用 `Object.keys()` 和 `map`：\n   \n   ```javascript\n   const obj = { a: 1, b: 2, c: 3 };\n   const arr = Object.keys(obj).map(key => obj[key]);\n   ```\n\n2. 使用 `Object.values()`：\n\n   ```javascript\n   const obj = { a: 1, b: 2, c: 3 };\n   const arr = Object.values(obj);\n   ```\n\n3. 使用 `Object.entries()` 和 `map`：\n\n   ```javascript\n   const obj = { a: 1, b: 2, c: 3 };\n   const arr = Object.entries(obj).map(([key, value]) => value);\n   ```\n\n这些方法中，第一种方法会将对象的键转换为数组，第二种方法会将对象的值转换为数组，而第三种方法会将对象的键值对转换为数组中的元素。你可以根据你的需求选择合适的方法。","type":"text/markdown","created":"20231020140047799","creator":"Lenovo","modified":"20231020140101930","modifier":"Lenovo","tags":""},{"title":"Object-assign","text":"`Object.assign()` 方法是一个用于将一个或多个源对象的属性复制到目标对象的方法。它接受两个或多个参数，第一个参数是目标对象，后面的参数都是源对象。\n\n语法如下：\n\n```plain\nObject.assign(target, ...sources)\n```\n\n其中，`target` 参数是目标对象，`...sources` 是一个或多个源对象。\n\n`Object.assign()` 方法会将每个源对象中可枚举的、自有的属性复制到目标对象中。如果目标对象和源对象具有相同的属性，则后来的属性会覆盖先前的属性。该方法会返回目标对象。\n\n下面是一个简单的示例，演示了如何使用 `Object.assign()` 方法将两个对象合并到一个新对象中：\n\n```javascript\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { c: 3, d: 4 };\nconst newObj = Object.assign({}, obj1, obj2);\n\nconsole.log(newObj); // { a: 1, b: 2, c: 3, d: 4 }\n```\n\n在上面的示例中，我们创建了两个源对象 `obj1` 和 `obj2`，并使用 `Object.assign()` 方法将它们合并到一个新对象 `newObj` 中。注意，我们首先传递了一个空对象 `{}` 作为目标对象，这样就不会修改任何已有的对象。\n\n除了合并对象外，`Object.assign()` 方法还可以用于复制对象。例如，如果你想要创建一个新对象，该对象与现有对象具有相同的属性和值，可以使用 `Object.assign()` 方法：\n\n```javascript\nconst obj = { a: 1, b: 2 };\nconst newObj = Object.assign({}, obj);\n\nconsole.log(newObj); // { a: 1, b: 2 }\n```\n\n在上面的示例中，我们创建了一个新对象 `newObj`，它与现有对象 `obj` 具有相同的属性和值。这样做的好处是，你可以修改 `newObj`，而不会影响到原始对象 `obj`。\n\n需要注意的是，`Object.assign()` 方法只会复制源对象自有的、可枚举的属性。如果源对象的属性是继承来的，或者是不可枚举的，则不会被复制。此外，该方法只会复制属性的值，而不会复制属性所代表的特性（例如，是否可写、可枚举等）。\n\n`Object.assign(one, two)` 会将 `two` 对象的属性和值合并到 `one` 对象中，并返回合并后的 `one` 对象。如果 `one` 对象中已经存在相同的属性，则会覆盖原有的值。\n\n`Object.assign({}, one, two)` 会创建一个新的空对象，然后将 `one` 和 `two` 对象的属性和值合并到该空对象中，并返回合并后的新对象。如果 `one` 和 `two` 对象中都存在相同的属性，则后面的对象的属性值会覆盖前面的对象的属性值。\n\n因此，两者的区别在于：\n\n- `Object.assign(one, two)` 会改变 `one` 对象本身，而 `Object.assign({}, one, two)` 不会改变 `one` 和 `two` 对象本身。\n- `Object.assign({}, one, two)` 会返回一个新的合并后的对象，而 `Object.assign(one, two)` 不会返回新的对象，而是返回合并后的 `one` 对象。\n\n需要注意的是，`Object.assign()` 方法是浅拷贝，即如果属性值是一个对象，则只会复制对象的引用，而不会复制对象本身。如果要实现深拷贝，需要使用其他方法。","type":"text/markdown","created":"20231027121810815","creator":"Lenovo","modified":"20231028091118075","modifier":"Lenovo","tags":"JavaScript"},{"title":"object-cover","text":"https://www.runoob.com/cssref/pr-object-fit.html","type":"text/markdown","created":"20230919030437125","modified":"20230919030454090","tags":"Tailwindcss CSS"},{"title":"obsdian-valut","text":"A vault is a folder on your local file system where Obsidian stores your notes. You can keep all your notes in one vault, or create several vaults for each of your different projects.\n\n:::info 吐槽一下\nvault 不是一个常用的表达吧, 这也太抽象了\n:::","type":"text/markdown","created":"20231019025009743","creator":"Lenovo","modified":"20231019025114328","modifier":"Lenovo","tags":""},{"title":"office-tool-plus","text":"office tool plus\r\n\r\ngithub\r\n<https://cloud.tencent.com/developer/article/1858440>","type":"text/markdown","created":"20230413070120597","creator":"oeyoews","modified":"20230413070143829","modifier":"oeyoews","tags":""},{"title":"onkeypress-deprecated","text":"这是因为 onKeyPress 事件只会在用户敲击可打印字符（例如字母、数字和标点符号）时触发。如果用户按下 \"Enter\" 键，它不会被认为是可打印字符，因此默认行为将执行并插入回车符。\n\n相反，onKeyDown 事件在用户按下任何键时都会触发，包括 \"Enter\" 键。因此，如果您希望在用户按下键盘上的 \"Enter\" 键时触发某些事件，最好使用 onKeyDown 事件来处理它。\n\n`onKeyPress` 已被废弃，不建议使用。在 React 中，推荐使用 `onKeyDown` 处理键盘事件。\n\n在 `onKeyDown` 事件处理函数中，您可以通过检查 `event.key` 属性来获得用户按下的键盘键。与 `onKeyPress` 不同，即使用户按下非打印字符（如 \"Shift\"、\"Ctrl\"、\"Alt\" 和 \"Enter\"），`onKeyDown` 也会触发。\n\n以下是在 React 中使用 `onKeyDown` 进行事件处理的示例代码：\n\n```plain\nfunction handleKeyDown(event) {\n  if (event.ctrlKey && event.key === \"Enter\") {\n    // 在这里处理回车按键事件\n  }\n}\n\nreturn (\n  <textarea onKeyDown={handleKeyDown} />\n);\n```\n\n在这个示例中，我们定义了一个名为 `handleKeyDown` 的函数，并将其作为 `onKeyDown` 赋值给文本区域。当用户按下 \"Ctrl\" 和 \"Enter\" 键时，该函数将被调用，从而允许在函数中处理回车按键事件。","type":"text/markdown","created":"20231104100931171","creator":"Lenovo","modified":"20231104101142783","modifier":"Lenovo","tags":""},{"title":"only-of-type-status","text":"<ul>\r\n<li>only-of-type-status</li>\r\n<li class=\"hidden only-of-type:block\">只剩下这一篇了</li>\r\n\t</ul>","type":"text/markdown","created":"20230830014026963","creator":"oeyoews","modified":"20230831024256833","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"open-closed-principle","text":"这是一个经典的编程原则，也被称为“开闭原则”（Open-Closed Principle），它强调一个软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。\r\n\r\n这个原则的核心思想是，当需求变化时，我们应该尽量避免修改已有的代码，而是通过扩展已有的代码实现新的功能。这样做的好处是，可以减少对已有代码的影响，从而降低引入新问题的风险，同时也可以提高代码的可维护性和可扩展性。\r\n\r\n具体来说，如果一个软件实体要支持新的需求，我们应该考虑通过增加新的代码来实现，而不是修改已有的代码。这可以通过使用抽象类、接口、模板方法等技术来实现。这些技术可以将变化的部分隔离出来，从而使得扩展变得更加容易，同时也保证了对已有代码的修改最小化。\r\n\r\n总之，遵循开闭原则可以使得软件系统更加灵活、可维护、可扩展，从而降低开发和维护的成本，提高软件质量。","type":"text/markdown","created":"20230606055932823","creator":"oeyoews","modified":"20230726045248746","modifier":"oeyoews"},{"title":"open-graph-protocol","text":"Open Graph Protocol（开放图谱协议）是一种用于增强网页在社交媒体平台上分享时的展示效果的元数据协议。它由 Facebook 提出并推广，现已成为社交媒体平台通用的标准。\n\nOpen Graph Protocol 使用一组 `<meta>` 标签来提供有关网页内容的元数据信息。这些标签包括：\n\n- `<meta property=\"og:title\" content=\"页面标题\">`：指定网页的标题。\n- `<meta property=\"og:description\" content=\"页面描述\">`：指定网页的描述。\n- `<meta property=\"og:image\" content=\"图片链接\">`：指定网页的缩略图链接。\n- `<meta property=\"og:url\" content=\"网页链接\">`：指定网页的链接。\n- `<meta property=\"og:type\" content=\"类型\">`：指定网页的类型，如 \"website\"、\"article\" 等。\n\n通过在网页的 `<head>` 标签中添加这些 Open Graph 标签，可以告诉社交媒体平台如何展示网页的预览内容。当用户在社交媒体上分享链接时，平台会使用这些元数据来生成链接预览，包括标题、描述和缩略图等。\n\nOpen Graph Protocol 可以提高网页在社交媒体平台上的可视性和点击率，使分享链接更具吸引力。除了 Facebook，其他社交媒体平台如 Twitter、LinkedIn 等也支持 Open Graph Protocol。","type":"text/markdown","created":"20230721160724584","creator":"oeyoews","modified":"20231017104103955","modifier":"Lenovo","tags":"名词"},{"title":"opensource-guide","text":"<https://opensource.guide/zh-hans/>","type":"text/markdown","created":"20230502030415019","creator":"oeyoews","modified":"20230502030426330","modifier":"oeyoews","tags":""},{"title":"optimic-png","text":"* use pngquant and zopflipng to compressor png","type":"text/markdown","created":"20230329070125534","creator":"oeyoews","modified":"20230329070200583","modifier":"oeyoews","tags":""},{"title":"ORM","text":"对象关系映射（Object Relational Mapping，简称 ORM","type":"text/markdown","created":"20230411031602873","creator":"oeyoews","modified":"20230411031615715","modifier":"oeyoews","tags":""},{"title":"os-info","text":"```bash\r\ninxi -F\r\n```","type":"text/markdown","created":"20231003020817095","creator":"oeyoews","modified":"20231003020834637","modifier":"oeyoews","tags":"gnome"},{"title":"OTP","text":"one time password","type":"text/markdown","created":"20230325072400183","creator":"oeyoews","modified":"20230325072408170","modifier":"oeyoews","tags":""},{"title":"overflow-auto","text":"* use flex overflow-atuo","type":"text/markdown","created":"20230502020819353","creator":"oeyoews","modified":"20230502020848159","modifier":"oeyoews","tags":"CSS"},{"title":"pandoc","text":"* https://pandoc.org/getting-started.html\r\n\r\nPandoc 是一个开源的文档转换工具，它可以将一种格式的文档转换成另一种格式，支持的输入格式包括 Markdown、HTML、reStructuredText 等，输出格式包括 HTML、PDF、Word 等。Pandoc 非常灵活，可以处理复杂的文档结构和样式，并且支持用户自定义的转换规则。\r\n\r\n使用 Pandoc 非常简单，你只需要在命令行中输入相应的命令即可完成转换。例如，将 Markdown 文件转换为 HTML 文件的命令如下：\r\n\r\n```plain\r\npandoc input.md -o output.html\r\n```\r\n\r\n这条命令会将名为 input.md 的 Markdown 文件转换为 output.html 的 HTML 文件。\r\n\r\n除了基本的转换功能，Pandoc 还支持许多扩展和选项，例如添加页眉页脚、生成目录、引用外部样式表等。你可以查阅 Pandoc 的官方文档以获取更多详细的信息和使用示例。","type":"text/markdown","created":"20231003040852373","creator":"oeyoews","modified":"20231003041031904","modifier":"oeyoews","tags":""},{"title":"parseInt-Number","text":"`parseInt` 和 `Number` 是 JavaScript 中用于将字符串转换为数字的两个不同方法，它们之间有一些重要的区别：\r\n\r\n1. **parseInt**:\r\n   - `parseInt` 是一个函数，用于将字符串解析为整数。\r\n   - 可以传递第二个参数 `radix`，指定解析时使用的进制（基数），通常使用 10（十进制）。\r\n   - `parseInt` 会从字符串的开头开始解析，直到遇到无法解析为数字的字符为止，然后返回解析的部分。\r\n   - 如果字符串以非数字字符开头，`parseInt` 会返回 `NaN`（Not-a-Number）。\r\n   - `parseInt` 可以用于解析带有正负号的整数，例如 `\"123\"`、`\"-456\"`。\r\n   - `parseInt` 不适用于解析浮点数。\r\n\r\n   例如：\r\n   ```javascript\r\n   parseInt(\"123\"); // 返回 123\r\n   parseInt(\"3.14\"); // 返回 3\r\n   parseInt(\"abc123\"); // 返回 NaN\r\n   parseInt(\"123abc\"); // 返回 123\r\n   ```\r\n\r\n2. **Number**:\r\n   - `Number` 是一个构造函数，用于将值转换为数字。\r\n   - 当传递一个字符串给 `Number` 时，它会尝试将整个字符串转换为一个数字。\r\n   - 如果字符串包含非数字字符（除了可能的正负号和小数点），`Number` 会返回 `NaN`。\r\n   - `Number` 也可以用于将其他类型的值转换为数字，例如布尔值、`null`、`undefined` 等，它会根据规则将它们转换为相应的数字值。\r\n\r\n   例如：\r\n   ```javascript\r\n   Number(\"123\"); // 返回 123\r\n   Number(\"3.14\"); // 返回 3.14\r\n   Number(\"abc123\"); // 返回 NaN\r\n   Number(\"123abc\"); // 返回 NaN\r\n   ```\r\n\r\n总结：\r\n- 如果你需要将字符串解析为整数，并且需要对解析的进制进行控制，可以使用 `parseInt`。\r\n- 如果你需要将字符串解析为数字（可以是整数或浮点数），可以使用 `Number`。\r\n- 无论哪种方法，都需要注意字符串中的非数字字符可能导致结果为 `NaN`。","type":"text/markdown","created":"20230924061533014","creator":"oeyoews","modified":"20230924061545760","modifier":"oeyoews","tags":"JavaScript"},{"title":"Partial","text":"```tsx\r\ninterface Foo {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ntype PartialFoo = Partial<Foo>;\r\n```\r\n\r\n`Partial<T>` 是 TypeScript 提供的一个内置工具类型，它接受一个类型 `T` 作为参数，并将 `T` 中所有属性设为可选的。换句话说，`Partial<T>` 将原始类型 `T` 的每个属性都转换为可选的。\r\n\r\n在你的例子中，`Foo` 是一个接口，表示一个拥有 `x` 和 `y` 属性的对象类型。而 `PartialFoo` 是通过 `Partial<Foo>` 创建的一个类型别名，它描述了一个可选的 `x` 和 `y` 属性。因此，`PartialFoo` 的定义等效于以下代码：\r\n\r\n```typescript\r\ntype PartialFoo = {\r\n  x?: number;\r\n  y?: number;\r\n};\r\n```\r\n\r\n可以看到，`PartialFoo` 中的每个属性都有一个问号 `?`，表示这些属性是可选的。\r\n\r\n通过使用 `Partial<T>`，我们可以更方便地处理那些需要某个类型的部分属性的情况。例如，在创建对象时可以只提供部分属性，而不必设置所有属性的值。","type":"text/markdown","created":"20230724154843239","creator":"oeyoews","modified":"20230726045248747","modifier":"oeyoews","tags":"TypeScript"},{"title":"password-on-tiddlywiki.info","text":"```plain\n\"--password\",\n \"oeyoews\",\n```","type":"text/markdown","created":"20230410125205096","creator":"oeyoews","modified":"20231101072705629","modifier":"Lenovo","tags":"TiddlyWiki"},{"title":"path-basename-ext","text":"`parse` 是一个常用的编程术语，代表解析（parsing）的意思。在计算机科学中，解析是从给定输入数据中提取有意义信息的过程。具体来说，在编程中，解析通常用于将复杂的数据结构或格式转换为更易于处理和理解的形式。\n\n在 Node.js 的 `path` 模块中，`parse` 是该模块提供的一个方法，用于解析文件路径。它接收一个文件路径作为参数，并返回一个解析后的对象，该对象包含了文件路径的各个部分的信息，如目录、根路径、文件名、扩展名等。\n\n以下是一个示例代码：\n\n```javascript\nconst path = require(\"path\");\nconst file = \"/home/user/docs/file.txt\";\n\nconst fileInfo = path.parse(file);\nconsole.log(fileInfo);\n```\n\n上述代码中，我们使用 `path.parse()` 方法将文件路径 `/home/user/docs/file.txt` 解析为一个对象 `fileInfo`。然后，我们通过输出 `fileInfo` 可以看到解析后的结果，其中包含了目录信息、根路径、文件名、扩展名等。\n\n对于给定的文件路径 `/home/user/docs/file.txt`，`fileInfo` 对象的属性如下：\n- `root`: 文件的根路径，对于 Unix 系统来说就是 `/`。\n- `dir`: 文件所在的目录路径，即 `/home/user/docs`。\n- `base`: 文件名和扩展名，即 `file.txt`。\n- `name`: 文件名（不包括扩展名），即 `file`。\n- `ext`: 文件扩展名，即 `.txt`。\n\n通过 `parse` 方法的使用，我们可以方便地从文件路径中提取出各个部分的信息，进而进行后续处理或操作。\n\n使用 Node.js 的 path.basename()方法来提取文件的基本名称（不包括目录路径）是非常常见和方便的。但是，当文件名包含一个或多个句点（.）时，它就会返回带有扩展名的文件名称。这是因为在这种情况下，Node.js 会将最后一个句点和之后的文本视为文件扩展名。\n\n例如，如果你有一个文件名为 \"example.file.txt\" 的文件，当你使用 path.basename()方法来提取它的基本名称时，它将返回 \"example.file.txt\" 而不是预期的 \"example.file\"。\n\n如果你需要去掉扩展名，可以使用 path.parse()方法来分解文件路径并获取文件名和扩展名，然后再使用 string.slice()或其他字符串操作方法来删除扩展名。例如：\n\n```javascript\nconst path = require('path');\nconst filename = 'example.file.txt';\nconst parsed = path.parse(filename);\nconst basenameWithoutExt = parsed.name; // \"example.file\"\n```","type":"text/markdown","created":"20231031134012060","creator":"Lenovo","modified":"20231031134046366","modifier":"Lenovo","tags":"JavaScript"},{"title":"path.resolve-join","text":"`path.join` 方法和 `path.resolve` 方法都可以用于拼接路径，但它们在处理路径的方式上有一些不同：\r\n\r\n1. `path.join`: \r\n\r\n   - 接受多个参数并将它们连接起来形成一个路径。\r\n   - 将会根据平台的特定规则来拼接路径，确保生成的路径是合法的。\r\n   - 不会解析 `..`（上级目录） 和 `.`（当前目录） 这样的相对路径符号。\r\n\r\n2. `path.resolve`:\r\n\r\n   - 接受一个或多个参数，并将它们视为目录或文件路径，从右到左解析它们并生成一个绝对路径。\r\n   - 解析过程中会考虑当前工作目录，并根据绝对路径规则生成最终的路径。\r\n   - 能够解析 `..`（上级目录） 和 `.`（当前目录） 等相对路径符号。\r\n\r\n下面是两者的使用示例：\r\n\r\n```javascript\r\nconst path = require('path');\r\n\r\n// 使用 path.join\r\nconst joinedPath = path.join('/home', 'user', 'documents', 'file.txt');\r\nconsole.log(joinedPath); // 输出: /home/user/documents/file.txt\r\n\r\n// 使用 path.resolve\r\nconst resolvedPath = path.resolve('/home', 'user', '..', 'documents', 'file.txt');\r\nconsole.log(resolvedPath); // 输出: /home/documents/file.txt\r\n```\r\n\r\n总结来说，如果你只是简单地需要将多个路径片段连接起来形成一个路径，可以使用 `path.join`。而如果你需要解析相对路径，并返回一个绝对路径，或者需要考虑当前工作目录，可以使用 `path.resolve`。","type":"text/markdown","created":"20230913054642936","creator":"oeyoews","modified":"20230924030837759","modifier":"oeyoews","tags":"JavaScript"},{"title":"Perplexity","text":"Perplexity","type":"text/markdown","created":"20230416024459062","creator":"oeyoews","modified":"20230416024503062","modifier":"oeyoews","tags":""},{"title":"picture-in-picture","text":"> https://developer.chrome.com/docs/web-platform/document-picture-in-picture/#acknowledgements\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <script src=\"https://cdn.tailwindcss.com\"></script>\r\n    <title>画中画示例</title>\r\n  </head>\r\n  <body class=\"m-2\">\r\n    <video\r\n      id=\"videoElement\"\r\n      controls\r\n      class=\"aspect-video rounded h-full w-full\"\r\n    >\r\n      <source\r\n        src=\"https://mdn.github.io/dom-examples/picture-in-picture/assets/bigbuckbunny.mp4\"\r\n        type=\"video/mp4\"\r\n      />\r\n    </video>\r\n\r\n    <button id=\"startButton\">画中画</button>\r\n\r\n    <script>\r\n      const videoElement = document.getElementById(\"videoElement\");\r\n      const startButton = document.getElementById(\"startButton\");\r\n\r\n      startButton.addEventListener(\"click\", togglePictureInPicture);\r\n\r\n      function togglePictureInPicture() {\r\n        if (document.pictureInPictureElement) {\r\n          document.exitPictureInPicture();\r\n        } else {\r\n          if (document.pictureInPictureEnabled) {\r\n            videoElement.requestPictureInPicture();\r\n          }\r\n        }\r\n      }\r\n    </script>\r\n  </body>\r\n</html>","type":"text/markdown","created":"20230925090732195","creator":"oeyoews","modified":"20230929145034501","modifier":"oeyoews","tags":"JavaScript"},{"title":"placeholder-shown","text":"<input class=\"placeholder-shown:border-red-500\" placeholder=\"you@example.com\" />","type":"text/markdown","created":"20230830022259324","creator":"oeyoews","modified":"20230830022404490","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"plugin-boolean-string","text":":::NOTE\r\ntw 获取到的属性都是字符串\r\n:::","type":"text/markdown","created":"20230929061259513","creator":"oeyoews","modified":"20230929061352094","modifier":"oeyoews","tags":"Plugins"},{"title":"plugin-priority","text":"* 插件一旦加上 plugin-priority, 优先级总是会比影子条目搞","type":"text/markdown","created":"20230922043327017","creator":"oeyoews","modified":"20230922043408917","modifier":"oeyoews","tags":"Plugins"},{"title":"plugin-svg","text":"> svg && svg.met vs tid\r\n\r\n> png to svg","type":"text/markdown","created":"20230307123320496","creator":"oeyoews","modified":"20230307123356033","modifier":"oeyoews","tags":""},{"title":"pm2-multi","text":"在 `ecosystem.config.js` 中，您可以使用 PM2 来管理和运行多个应用程序或进程。您可以在配置文件中定义多个应用程序，并使用 `pm2 start` 命令来启动它们。以下是一个示例 `ecosystem.config.js` 文件，其中定义了多个应用程序：\r\n\r\n```javascript\r\nmodule.exports = {\r\n  apps: [\r\n    {\r\n      name: \"app1\",\r\n      script: \"./app1.js\",\r\n      args: \"--option1=value1\",\r\n      // 其他配置选项\r\n    },\r\n    {\r\n      name: \"app2\",\r\n      script: \"./app2.js\",\r\n      args: \"--option2=value2\",\r\n      // 其他配置选项\r\n    },\r\n    // 可以继续定义更多应用程序...\r\n  ],\r\n};\r\n```\r\n\r\n在上述示例中，我们定义了两个应用程序，分别为 \"app1\" 和 \"app2\"。每个应用程序都有自己的配置，包括脚本文件、命令行参数等。\r\n\r\n要同时运行这些应用程序，您可以使用以下命令：\r\n\r\n```bash\r\npm2 start ecosystem.config.js\r\n```\r\n\r\n这将启动配置文件中定义的所有应用程序。PM2 会为每个应用程序创建一个独立的进程，并以它们的名称命名。您可以使用 `pm2 list` 命令来查看正在运行的应用程序列表：\r\n\r\n```bash\r\npm2 list\r\n```\r\n\r\n如果您需要停止或管理这些应用程序，可以使用 `pm2 stop`、`pm2 restart`、`pm2 delete` 等命令。\r\n\r\n请确保已经全局安装了 PM2，或者将其添加到项目的开发依赖中：\r\n\r\n```bash\r\nnpm install -g pm2\r\n```\r\n\r\n使用 PM2 可以方便地管理多个应用程序，并提供监控、自动重启等功能。","type":"text/markdown","created":"20230902040002798","creator":"oeyoews","modified":"20230902040012708","modifier":"oeyoews","tags":""},{"title":"pm2-not-restarted","text":"* if pm2 not restart automatically, use pm2 delete , and start it, stop and start will break automatically\n\n\n* https://github.com/jawil/blog/issues/7 一篇关于 pm2 的文章\n\n* 也可以使用 reload 代替 stop, watch 不会失效应该\n\n* 不要 stop 然后重新有 start, 要 restart, 否则会导致 watch 失效\n\n> 刚才遇到了 PM2 疯狂重启(我也没修改文件啊)","type":"text/markdown","created":"20230322065143987","creator":"oeyoews","modified":"20231014120147283","modifier":"Lenovo","tags":""},{"title":"pm2-usage","text":"* pm2 login/logout","type":"text/markdown","created":"20230403055607635","creator":"oeyoews","modified":"20230403055618219","modifier":"oeyoews","tags":""},{"title":"png2svg","text":"<https://vectorizer.ai/>","type":"text/markdown","created":"20230417044925649","creator":"oeyoews","modified":"20230417044932988","modifier":"oeyoews","tags":""},{"title":"pnpm-bug","text":"pnpm 通过硬链接, 修改的文件修改后, 全部的文件都被修改了\n\npnpm install github:xxx/xxx 这样安装的是 `git@xxxx`, 显然不对, pnpm update 的时候又更新成了 github:xxxx","type":"text/markdown","created":"20230907083931284","creator":"oeyoews","modified":"20231028025558378","modifier":"Lenovo","tags":""},{"title":"pnpm-usage","text":"```bash\r\npnpm config set store-dir /path/to/.pnpm-store\r\npnpm setup # to add PNPM_HOME on your .bashrc or .zshrc config\r\n```\r\n\r\npnpm dlx create-tw-apps === pnpm create tw-apps","type":"text/markdown","created":"20230830152228251","creator":"oeyoews","modified":"20230831151306680","modifier":"oeyoews","tags":""},{"title":"poem-random","text":"<img src=\"https://v1.jinrishici.com/all.svg\">","type":"text/markdown","created":"20230203135645905","creator":"oeyoews","modified":"20230203135712528","modifier":"oeyoews","tags":""},{"title":"position-display","text":"在 Web 开发中，position 和 display 是两个常用的 CSS 属性，它们用于控制元素在页面上的定位和布局。\r\n\r\n1. position（定位属性）：\r\n   - static：默认值，元素按照正常文档流进行排布，忽略 top、right、bottom 和 left 属性。无法通过设置 z-index 来改变元素的层叠顺序。\r\n   - relative：相对定位，元素在正常文档流中仍占据原来的空间，但可以通过设置 top、right、bottom 和 left 属性相对于自身原本位置进行偏移。\r\n   - absolute：绝对定位，元素脱离正常文档流，不占据原本的空间，并相对于最近的已定位祖先元素（非 static），或者相对于整个文档进行定位。\r\n   - fixed：固定定位，元素脱离正常文档流，不占据原本的空间，相对于浏览器视口进行定位，即无论页面如何滚动，元素始终保持在指定位置。\r\n   - sticky：粘性定位，元素根据正常文档流进行正常排布，但在指定阈值范围内开始固定定位，当页面滚动到该阈值时，元素将固定在设定的位置。\r\n\r\n2. display（显示属性）：\r\n   - block：块级元素，元素独占一行，并且默认宽度为父元素的 100%。常见的块级元素有 `<div>`、`<p>`、`<h1>` 等。\r\n   - inline：内联元素，元素不会换行，与其他内联元素在同一行显示。常见的内联元素有 `<span>`、`<a>`、`<strong>` 等。\r\n   - inline-block：内联块级元素，元素与其他内联元素在同一行显示，并且可以设置宽度、高度等块级元素的属性。\r\n   - none：元素不显示且不占据空间，相当于完全隐藏元素。\r\n\r\n需要注意的是，position 属性和 display 属性是可以同时使用的。对于使用了定位属性的元素，其 display 属性仍然起作用，并且可能影响元素的布局和显示方式。","type":"text/markdown","created":"20230722175929028","creator":"oeyoews","modified":"20230726045248749","modifier":"oeyoews","tags":"CSS"},{"title":"pre-load-videos","text":"短视频也有预先加载","type":"text/markdown","created":"20231104014130375","creator":"Lenovo","modified":"20231104014202374","modifier":"Lenovo","tags":""},{"title":"prev-arrow","text":"<svg stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" version=\"1\" viewBox=\"0 0 48 48\" enable-background=\"new 0 0 48 48\" height=\"1em\" width=\"1em\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"#2196F3\" points=\"30.9,43 34,39.9 18.1,24 34,8.1 30.9,5 12,24\"></polygon></svg>","type":"text/markdown","created":"20230118024922028","creator":"oeyoews","modified":"20230118024928846","modifier":"oeyoews","tags":""},{"title":"preview-all-plugins-tw","text":"* <https://tiddlywiki.com/editions/full/>","type":"text/markdown","created":"20230219042517550","creator":"oeyoews","modified":"20230219042534405","modifier":"oeyoews","publish":"public","tags":""},{"title":"preview-readme-on-local","text":"* use python-grip","type":"text/markdown","created":"20230318033514184","creator":"oeyoews","modified":"20230318033533525","modifier":"oeyoews","tags":""},{"title":"primitive","text":"* string, number, boolean null undefined are primitive\r\n* object and array are non-primitive(ref)","type":"text/markdown","created":"20230429011646413","creator":"oeyoews","modified":"20230429011742917","modifier":"oeyoews","tags":"ES6"},{"title":"Private","text":":::warning\n这里存储的是个人内容, 不对外公开\n:::\n\n<$echarts $tiddler=\"addon/tagpie.js\" filter=\"[publish[private]]\"/>","type":"text/markdown","created":"20230501172445994","creator":"oeyoews","icon":"private.png","modified":"20231011081917438","modifier":"Lenovo","page-icon":"fluent-emoji-flat:locked-with-pen","tags":"Private"},{"title":"private-ts","text":"TypeScript 在编译为 JavaScript 时，使用了一种称为“名称重写”的技术来实现私有成员的访问控制。这个过程被称为“编译时封装”。\r\n\r\n在 TypeScript 中，`private` 成员被编译为 JavaScript 中的闭包。编译器会将 `private` 成员重命名为一个唯一的标识符，并创建一个闭包函数来封装这个成员。这样，外部无法直接访问和修改私有成员，只能通过闭包函数来间接访问。\r\n\r\n以下是一个 TypeScript 类中的 `private` 成员的示例及其编译后的 JavaScript 代码：\r\n\r\n```typescript\r\nclass MyClass {\r\n  private myPrivateProperty: string;\r\n\r\n  constructor() {\r\n    this.myPrivateProperty = \"private value\";\r\n  }\r\n\r\n  private myPrivateMethod() {\r\n    console.log(this.myPrivateProperty);\r\n  }\r\n\r\n  public myPublicMethod() {\r\n    this.myPrivateMethod();\r\n  }\r\n}\r\n\r\nconst myObject = new MyClass();\r\nmyObject.myPublicMethod();\r\n```\r\n\r\n编译后的 JavaScript 代码：\r\n\r\n```javascript\r\nvar MyClass = /** @class */ (function () {\r\n  function MyClass() {\r\n    this._myPrivateProperty = \"private value\";\r\n  }\r\n\r\n  MyClass.prototype._myPrivateMethod = function () {\r\n    console.log(this._myPrivateProperty);\r\n  };\r\n\r\n  MyClass.prototype.myPublicMethod = function () {\r\n    this._myPrivateMethod();\r\n  };\r\n\r\n  return MyClass;\r\n}());\r\n\r\nvar myObject = new MyClass();\r\nmyObject.myPublicMethod();\r\n```\r\n\r\n在编译后的 JavaScript 代码中，`private` 成员 `myPrivateProperty` 被重命名为 `_myPrivateProperty`，`myPrivateMethod` 被重命名为 `_myPrivateMethod`。这些成员只能在闭包函数内部访问，外部无法直接访问它们。\r\n\r\n尽管 JavaScript 中的闭包函数并不能真正阻止对私有成员的访问，但它们提供了一种机制，使得私有成员对外部代码来说更难以访问，从而增强了封装性和代码安全性。","type":"text/markdown","created":"20230702152709671","creator":"oeyoews","modified":"20230726045248750","modifier":"oeyoews","tags":"TypeScript"},{"title":"process","text":"`process` 是 Node.js 中一个全局对象，它提供了有关当前 Node.js 进程的信息。这个对象包含了很多有用的属性和方法，可以让我们更好地控制和管理进程。\r\n\r\n以下是 `process` 对象中一些常用的属性和方法：\r\n\r\n- `process.argv`：返回一个数组，包含了启动 Node.js 进程时传入的命令行参数。\r\n- `process.env`：返回一个对象，包含了当前进程的环境变量。\r\n- `process.cwd()`：返回一个字符串，表示当前工作目录的路径。\r\n- `process.exit([code])`：退出当前 Node.js 进程，并返回一个指定的退出码（如果指定了的话）。\r\n- `process.on(event, callback)`：监听指定的事件，并在事件触发时执行回调函数。\r\n\r\n除了上面列出的属性和方法之外，`process` 对象还提供了很多其他有用的工具，比如流、进程间通信、信号处理等等。\r\n\r\n在实际开发中，我们经常需要使用 `process` 对象来获取或修改进程的信息，比如读取环境变量、获取命令行参数、退出进程、监听信号等等。通过 `process` 对象，我们可以更好地控制和管理 Node.js 进程，提高应用程序的稳定性和可靠性。","type":"text/markdown","created":"20230530020540477","creator":"oeyoews","modified":"20230726045248751","modifier":"oeyoews","tags":"NodeJs"},{"title":"process-tiddlywiki-img-to-img-shield","text":"## Steps\r\n\r\n* 首先需要将图片大小调整为 24, 这使用 inkscape 很容易做到， 但是无法清楚 style 属性， 因此我继续使用了 svgo 进行处理，仅仅保留有一个 path, 但是正式由于这一步图片不再是正方型， 难道是由于这个 widthxheight is 283.464x283.466 导致的问题吗\r\n\r\n## Some Links\r\n\r\n---\r\n\r\n* <https://github.com/simple-icons/simple-icons/discussions/4935>\r\n* svgo **.svg\r\n\r\n---\r\n\r\n* resize svg to 24: <https://www.iloveimg.com/resize-image/resize-svg#resize-options,pixels>\r\n* preview: <https://petershaggynoble.github.io/SI-Sandbox/preview/>\r\n* use svgo to optimize\r\n* remove extra element <https://jakearchibald.github.io/svgomg/>\r\n* add format for shield like role=\"img\"\r\n* resize again\r\n* npx svglint  icon/tiddlywiki.svg\r\n* use inkscape to center","type":"text/markdown","created":"20230331150452289","creator":"oeyoews","modified":"20230726045248752","modifier":"oeyoews"},{"title":"process.argv","text":"```js\r\n// node main.js 1 2 3\r\nconst argv = process.argv.slice(2);\r\nconsole.log([...argv]);\r\n```","type":"text/markdown","created":"20230924021531935","creator":"oeyoews","modified":"20230924021555237","modifier":"oeyoews","tags":"JavaScript"},{"title":"process.cwd","text":"process.cwd() 是 Node.js 中的一个函数，用于获取当前工作目录的路径。它返回一个字符串，表示当前 Node.js 进程所在的工作目录的路径。\r\n\r\n该函数返回的路径是相对于启动 Node.js 进程的位置的，而不是脚本文件的位置。在大多数情况下，它将返回启动 Node.js 进程时所在的目录的路径。\r\n\r\n例如，假设你的 Node.js 脚本文件位于 /home/user/example/script.js，然后你在终端中执行 node /home/user/example/script.js，那么 process.cwd() 将返回 /home/user/example。\r\n\r\n这个函数通常用于在 Node.js 应用程序中获取当前工作目录，并结合其他路径操作函数（如 path.join()）来构建文件路径。","type":"text/markdown","created":"20230721123958115","creator":"oeyoews","modified":"20230726045248754","modifier":"oeyoews","tags":"NodeJs"},{"title":"proxy-types","text":"透明代理和系统代理都是网络代理的形式，但它们的实现方式和应用场景有所不同。\n\n透明代理：透明代理是一种不需要客户端进行任何配置就可以使用的代理方式。它会直接将客户端发出的请求转发给代理服务器处理，并将响应再返回给客户端，而不需要客户端知道代理服务器的存在。透明代理通常用于企业或机构内的网络管理，可以实现对网络流量的监控和过滤。\n\n系统代理：与透明代理不同，系统代理需要客户端进行相关的配置。在系统代理中，客户端会将网络请求发送给代理服务器，以便代理服务器来进行下一步的操作。系统代理可以用于访问受限制的网站、提高访问速度、隐藏 IP 地址等等。\n\n总的来说，透明代理主要用于网络管理和监控，而系统代理则主要用于保护隐私、翻墙访问等。","type":"text/markdown","created":"20231009125138731","creator":"Lenovo","modified":"20231009125152759","modifier":"Lenovo","tags":"proxy"},{"title":"ps1","text":"按照渣软的惯例，Powershell 文件的扩展名应该是.ps 的。但是很可惜，早在 1985 年 Adobe 公司就推出了 PostScript，一种编程语言，其文件格式就是.ps，所以渣软失了先机。\nPowershell 的版本是从 1.0 开始的，所以渣软不得已在 ps 后面加了个版本号，就这样沿用下来了，Powershell 的脚本文件就是.ps1，模块文件就是.psm（Powershell Module）。","type":"text/markdown","created":"20231014092503806","creator":"Lenovo","modified":"20231014092512129","modifier":"Lenovo","tags":"名词"},{"title":"puppeteer","text":"Puppeteer 是一个由 Google Chrome 团队开发的 Node.js 库，可以通过编写 JavaScript 代码来控制 Chrome 或 Chromium 浏览器的行为。Puppeteer 提供了一组 API，可以让开发人员编写脚本来模拟用户在浏览器中的操作，例如点击、填写表单、截图等等。这使得开发人员能够自动化测试和爬取网站，以及进行其他与浏览器交互相关的任务。\r\n\r\nPuppeteer 的特点包括：\r\n\r\n- 它可以完全模拟人类用户的行为，包括点击、输入和滚动等。\r\n- 它可以在无头模式下运行浏览器，这意味着浏览器界面不会显示出来，从而提高了脚本执行的速度。\r\n- 它可以轻松地生成 PDF 或截图，并提供了丰富的 API 来访问和操作页面元素。\r\n- 它提供了一个方便的调试工具，可以在浏览器中查看脚本运行时的页面状态和元素信息。\r\n\r\n总之，Puppeteer 是一个非常强大和灵活的工具，可以大大简化许多 Web 自动化任务的开发和执行过程。它已经成为许多开发人员和企业的首选工具之一，特别是在需要进行大规模测试、数据抓取和屏幕截图等任务时。","type":"text/markdown","created":"20230528035305903","creator":"oeyoews","modified":"20230726045248755","modifier":"oeyoews"},{"title":"pure-function","text":"\"纯函数\" 概念解释\r\nJS 中定义的所有函数都可以增加参数，所谓\"纯函数\"是指函数内部并未修改过该参数的函数。\r\n\r\n例如以下函数：function myFun(a){let c=a }，该函数内部从未更改过参数 a，那么这个函数就是纯函数。\r\n\r\n反例，非纯函数 例如：function myFun(a){a=a+2; let c=a}，该函数内部修改过参数 a，那么这个函数就不再是纯函数了。\r\n\r\n纯函数的特殊意义是什么？\r\n因为纯函数内部从不会直接修改参数，那么无论运行多少次，执行结果永远是一致的。\r\n\r\n若仅仅有一个函数，那么也无所谓，但是如果有多个函数都是都需要调用执行同一个变量(参数)，为了确保多个函数执行结果是符合预期的，那么就要求每个函数都不能在自己内部修改该变量(参数)。\r\n\r\n这就是为什么 react 不允许直接修改某变量的原因。","type":"text/markdown","created":"20230428084101319","creator":"oeyoews","modified":"20230428084114871","modifier":"oeyoews","tags":"React"},{"title":"pwa-pngs","text":"https://maskable.app/editor","type":"text/markdown","created":"20230702133315225","creator":"oeyoews","modified":"20230726045248755","modifier":"oeyoews"},{"title":"QRCode","text":"您好！二维码（QR Code）(quick response 是一种二维条码图形，可由扫描设备读取。它由黑白方块组成，可以包含文本、链接、网址等信息。二维码的主要用途是快速扫描和传输信息。\n\n二维码的工作原理是通过编码将信息转换为图像，然后使用扫描设备（如智能手机或扫描仪）读取该图像，并解码其中的信息。扫描设备会识别并解析二维码的图案，从而获取其中包含的信息。\n\n使用二维码有很多应用场景，例如：\n\n1. 商业营销：企业可以将二维码放置在广告、产品包装或展示物品上，用户可以通过扫描二维码来获取更多信息、获得优惠券或参与活动。\n\n2. 支付方式：许多移动支付平台（例如支付宝、微信支付）使用二维码作为支付方式。商家生成一个包含支付信息的二维码，顾客使用支付应用扫描二维码完成支付。\n\n3. 电子票务：二维码也被广泛用于电子票务系统中。购买电影票、火车票、机票等后，用户会收到一张包含二维码的电子票，扫描该二维码即可进入场馆或乘坐交通工具。\n\n4. 身份验证：二维码还可以用于身份验证，例如在会议签到、登录网站或进行身份验证时，通过扫描二维码以便快速识别用户身份。\n\n生成二维码可通过许多在线工具或移动应用程序完成。同时，也有多种编程库（如 Python 的 qrcode 库）可以用来生成和处理二维码。\n\n总之，二维码是一种便捷的信息传输方式，在商业和个人生活中有着广泛的应用。","type":"text/markdown","created":"20231030032146028","creator":"Lenovo","modified":"20231030032545756","modifier":"Lenovo","tags":""},{"title":"querySelector","text":"`querySelector` 和 `getElementById`、`getElementsByClassName`、 `getElementsByTagName` 这类方法都是用来查找 HTML 元素的 DOM 方法，二者的主要区别在于：\r\n\r\n1. `querySelector` 返回文档中匹配指定 CSS 选择器的第一个元素，而 `getElementById` 直接返回指定 ID 的元素（ID 必须唯一）。\r\n2. `querySelector` 返回的是一个 Element 对象，而 `getElementById`、`getElementsByClassName`、 `getElementsByTagName` 返回的是一个 HTMLCollection 或 NodeList 对象，需要通过索引访问对应元素。\r\n3. `querySelector` 可以使用更为灵活的 CSS 选择器语法进行查询，而 `getElementById`、`getElementsByClassName`、 `getElementsByTagName` 只能传入单个标签名、类名或 ID 等字符串参数。\r\n\r\n举个例子，如果我们要获取文档中 ID 为 `myDiv` 的 div 元素，可以使用以下两种方式：\r\n\r\n```js\r\nvar myDiv1 = document.querySelector('#myDiv');\r\nvar myDiv2 = document.getElementById('myDiv');\r\n```\r\n\r\n其中，`querySelector` 使用 CSS 选择器 `#myDiv` 来匹配 ID 为 `myDiv` 的元素，并返回第一个匹配的元素；而 `getElementById` 直接根据 ID 字符串 `myDiv` 返回对应的元素。","type":"text/markdown","created":"20230603044222457","creator":"oeyoews","modified":"20230726045248756","modifier":"oeyoews","tags":"JavaScript"},{"title":"React","text":":::note React\n\"React 是一个用于构建用户界面的 JavaScript 库。它采用组件化的开发模式，通过构建可重用的 UI 组件来构建复杂的用户界面。React 使用虚拟 DOM（Virtual DOM）的概念，通过比较前后两个状态的差异，最小化 DOM 操作，提高性能和效率。它支持单向数据流，通过状态（state）和属性（props）的管理来实现数据的动态更新和传递。React 具有广泛的生态系统和活跃的社区支持，使开发者能够轻松地构建交互性强、可维护性好的现代 Web 应用程序。\"\n:::\n\n<table>\n<$list filter=\"[tag[React]!sort[modified]!has[draft.of]]\">\n<tr>\n<td class=\"p-2 bg-gray-200\"> <$link to={{!!title}}><$view field=\"title\"/></$link>\n</td>\n</tr>\n</$list>\n</table>\n\n\n<hr>\n\n[link]( https://www.bilibili.com/video/BV1G54y1o7RP/?p=2&spm_id_from=pageDriver&vd_source=d6afd7eedd9f9c940321c63f0a1539e3)","type":"text/markdown","created":"20230426035425719","creator":"oeyoews","icon":"react.png","modified":"20231017234302893","modifier":"Lenovo","page-cover":"https://source.unsplash.com/random/1920x1080?fm=blurhash&React","page-icon":"skill-icons:react-dark","tags":""},{"title":"React FC","text":"这段代码是使用 ES6 模块语法导入 React 库中的 FC（函数组件）组件。在 React 中，FC（FunctionComponent 的缩写）是一种定义函数组件的类型，它是一个接受 props 并返回 JSX 元素的函数。\r\n\r\n通过这行代码导入 FC，你可以在代码中使用它来定义和使用函数组件，例如：\r\n\r\n```jsx\r\nimport React, { FC } from 'react';\r\n\r\nconst MyComponent: FC = () => {\r\n  return <div>Hello, World!</div>;\r\n};\r\n\r\nexport default MyComponent;\r\n```\r\n\r\nFC 组件类型是使用 TypeScript 编写 React 代码时的通用约定之一，它有助于提供静态类型检查和代码补全的功能，让开发更加可靠和方便。","type":"text/markdown","created":"20230709063640775","creator":"oeyoews","modified":"20230726045248760","modifier":"oeyoews","tags":"React"},{"title":"react 生命周期","text":"React 组件的生命周期方法指的是在组件的生命周期中由 React 自动调用的一系列方法，这些方法可以用于在组件的不同阶段执行一些操作，例如初始化状态、更新 UI、处理错误等。React 组件的生命周期方法分为三个阶段：挂载、更新和卸载。下面是每个阶段的生命周期方法：\r\n\r\n1. 挂载阶段（Mounting）：\r\n   - constructor()：组件的构造函数，在组件创建时调用。在构造函数中可以初始化组件的状态（this.state）和绑定成员函数的 this。\r\n   - static getDerivedStateFromProps(props, state)：在组件实例化和接收到新的 props 时调用，用于根据新的 props 更新 state（不推荐使用）。\r\n   - render()：组件的渲染函数，在组件挂载到 DOM 上时调用。render() 必须返回一个 React 元素。\r\n   - componentDidMount()：在组件挂载后调用，用于进行一些异步操作，例如从服务器获取数据、设置定时器等。\r\n\r\n2. 更新阶段（Updating）：\r\n   - static getDerivedStateFromProps(props,state)：在组件接收到新的 props 或 state 时调用，用于根据新的 props 或 state 更新 state（不推荐使用）。\r\n   - shouldComponentUpdate(nextProps, nextState)：在组件接收到新的 props 或 state 时调用，用于决定是否重新渲染组件。如果返回 false，组件将不会重新渲染。\r\n   - render()：同上。\r\n   - componentDidUpdate(prevProps, prevState, snapshot)：在组件更新后调用，用于进行一些副作用操作，例如更新 DOM、记录日志等。可以通过第三个参数 snapshot 获取组件更新前的信息。\r\n\r\n3. 卸载阶段（Unmounting）：\r\n   - componentWillUnmount()：在组件卸载前调用，用于清理组件的副作用操作，例如取消定时器、移除事件监听器等。\r\n\r\n除了上述生命周期方法之外，还有一些其他方法，例如 static getDerivedStateFromError(error) 和 componentDidCatch(error, info)，用于处理组件渲染过程中的错误。需要注意的是，在 React 17 之后，getDerivedStateFromProps 和 componentWillReceiveProps 方法被标记为不安全的方法，不推荐使用。","type":"text/markdown","created":"20230601134216651","creator":"oeyoews","modified":"20230726045248759","modifier":"oeyoews","tags":"React"},{"title":"react-basic","text":"* 在最新的 react 版本中，也可以直接使用<></>来代替 Fragment。其中<>唯一可以拥有的属性为 key。即< key='xxx'></>\r\n\r\n* 使用数组 map 循环更新 li，一定要给 li 添加对应的 key 值，否则虽然正常运行，但是会报错误警告。不建议直接使用 index 作为 key 值。\r\n* 在 JSX 中写注释，格式为：{/* xxxxx */}或{//xxxx}，注意如果使用单行注释，最外的大括号必须单独占一行。注释尽在开发源代码中显示，在导出的网页中不会有该注释。\r\n\r\n* 给标签添加样式时，推荐使用 className，不推荐使用 class。如果使用 class 虽然运行没问题，但是会报错误警告，因为样式 class 这个关键词和 js 中声明类的 class 冲突。类似的还有标签中 for 关键词，推荐改为 htmlFor。\r\n\r\n## 声明式开发\" 概念解释\r\n\"声明式开发\"：基于数据定义和数据改变，视图层自动更新。\r\n\"命令式开发\"：基于具体执行命令更改视图，例如 DOM 操作修改。\r\n\r\n注意：声明式开发并不是不进行 DOM 操作，而是把 DOM 操作频率降到最低。","type":"text/markdown","created":"20230428083657671","creator":"oeyoews","modified":"20230726045248760","modifier":"oeyoews","tags":"React"},{"title":"react-basic01","text":"React 基础概念包括以下几个方面：\r\n\r\n1. 组件：在 React 中，一切都是组件。组件是 React 应用程序的基本构建块，它可以接受输入（称为属性）并返回特定的输出。组件可以是函数型组件或类型组件。\r\n\r\n2. 属性（Props）：组件可以通过属性来接收外部数据。属性是只读的，即子组件不能修改父组件传递过来的属性值。\r\n\r\n3. 状态（State）：状态是组件内部的可变数据。它通常由组件自己管理，并且可以在组件生命周期中随时更改。当状态发生更改时，React 会自动重新渲染组件。\r\n\r\n4. 生命周期：组件有不同的生命周期阶段，这些阶段分别是创建、更新和销毁。每个生命周期阶段都有对应的钩子函数，可以在特定的时刻执行特定的操作。例如，在组件创建时执行某些初始化操作，在组件销毁时清理资源等。\r\n\r\n5. 虚拟 DOM：React 使用虚拟 DOM 来管理页面元素，它是一个轻量级的 JavaScript 对象。每次状态或属性更改时，React 都会重新计算虚拟 DOM 并比较它与上一次的版本之间的差异，然后仅对需要进行更新的部分进行实际 DOM 操作。\r\n\r\n6. JSX：JSX 是一种将 HTML 和 JavaScript 结合起来的语法，可以让你直接在 JavaScript 中编写 HTML 代码，从而轻松创建 React 组件。例如：\r\n\r\n   ```jsx\r\n   function Greeting(props) {\r\n     return <h1>Hello, {props.name}!</h1>;\r\n   }\r\n   ```\r\n\r\n以上就是 React 基础概念的简要介绍。理解了这些概念之后，你就可以开始构建基本的 React 应用程序了。","type":"text/markdown","created":"20230502123940354","creator":"oeyoews","modified":"20230502123959624","modifier":"oeyoews","tags":"React"},{"title":"react-brackets","text":"在 React 中，`{}` 被用于将表达式嵌入到 JSX 中。在 JSX 中，花括号 `{}` 表示 JavaScript 表达式。\r\n\r\n使用 `{}`，我们可以在 JSX 中插入变量、函数调用、JavaScript 运算符和条件语句等 JavaScript 表达式。下面是一个简单的例子：\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\nfunction Greeting(props) {\r\n  const name = props.name;\r\n  return (\r\n    <div>\r\n      <h1>Hello, {name}!</h1>\r\n      <p>Today is {new Date().toLocaleDateString()}.</p>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Greeting;\r\n```\r\n\r\n在这个例子中，我们定义了一个 `Greeting` 组件，接收一个 `name` 属性。在 `h1` 标签内，我们使用花括号将 `name` 变量插入到字符串中。在 `p` 标签中，我们使用花括号将一个表达式作为文本输出。\r\n\r\n花括号 `{}` 是一种非常方便的方式来将动态数据插入到 JSX 中，同时也是 React 应用程序的重要组成部分。但需要注意的是，在使用花括号 `{}`时，需要确保插入的内容是安全的，并不会导致 XSS 攻击或其他安全漏洞。","type":"text/markdown","created":"20230423081726747","creator":"oeyoews","modified":"20230423081753425","modifier":"oeyoews","tags":"App"},{"title":"react-classnames","text":"<div class=\"bg-red-200 rounded-md p-2 indent-4\">\r\nEven use this classnames package, the local debug is normal, but this dist not generate the dynamic tailwindcss class\r\n</div>\r\n\r\nclassnames 是一个 JavaScript 包，用于动态生成 CSS 类名字符串。它可以简化应用程序中条件渲染类名的过程，特别是在 React 应用程序中，当需要根据组件的 props 或 state 动态应用类名时。\r\n\r\nclassnames 函数可以接受任意数量的参数，包括字符串、对象和数组。它会检查每个参数，并根据其类型生成相应的类名字符串。例如，传递一个字符串参数 'foo' 将返回字符串 'foo'，传递一个对象参数 { 'bar': true, 'baz': false } 将返回字符串 'bar'，因为 'baz' 的值为 false。\r\n\r\n以下是一个示例，演示了如何在 React 组件中使用 classnames 生成动态类名字符串：\r\n\r\n```jsx\r\nimport React from 'react';\r\nimport classnames from 'classnames';\r\n\r\nfunction MyComponent({ isHighlighted }) {\r\n  const classes = classnames('my-component', { 'highlighted': isHighlighted });\r\n  return <div className={classes}>Hello, world!</div>;\r\n}\r\n```\r\n\r\n\r\n我们使用 classnames 函数生成 MyComponent 组件的类名字符串。它包括了一个静态类名 'my-component' 和一个动态类名 'highlighted'，根据 isHighlighted prop 的值确定是否应用该类名。","type":"text/markdown","created":"20230424052256811","creator":"oeyoews","modified":"20230424061236928","modifier":"oeyoews","tags":"React"},{"title":"React-comments","text":"React 组件有两种创建方式：函数组件和类组件。\r\n\r\n1. 函数组件\r\n\r\n函数组件也被称为无状态组件，它是一种简单的组件定义方式，由一个 JavaScript 函数来描述组件。通常情况下，一个函数组件只接收 props 作为输入，并返回一个 React 元素来渲染 UI。下面是一个简单的函数组件的例子：\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\nfunction Welcome(props) {\r\n  return <h1>Hello, {props.name}!</h1>;\r\n}\r\n\r\nexport default Welcome;\r\n```\r\n\r\n2. 类组件\r\n\r\n类组件又被称为有状态组件。它使用 ES6 的 class 关键字来描述组件。类组件具有更多的功能和特性，比如能够使用生命周期方法、状态等。下面是一个简单的类组件的例子：\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\nclass Welcome extends React.Component {\r\n  render() {\r\n    return <h1>Hello, {this.props.name}!</h1>;\r\n  }\r\n}\r\n\r\nexport default Welcome;\r\n```\r\n\r\n通过这两个例子可以看出，用函数组件来实现一个简单的 React 组件非常简单明了，而类组件则提供了更多高级的功能。选择哪种方式取决于你的需求，如果你只需要一个简单的 UI 节点，那么使用函数组件就足够了；但如果你需要更复杂的逻辑和状态管理，那么类组件会更加适合。","type":"text/markdown","created":"20230424033807649","creator":"oeyoews","modified":"20230424033828623","modifier":"oeyoews","tags":"React"},{"title":"react-diff","text":"（2）Diff 算法\r\ntree diff：新旧两颗 DOM 树，逐层对比的过程，就是 Tree Diff；当整颗 DOM 逐层对比完毕，则所有需要被按需更新的元素，必然能够找到\r\ncomponent diff：在进行 tree diff 的时候，每一层中，组件级别的对比，叫作 component diff；\r\n如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新；\r\n如果对比前后，组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上；\r\nelement diff：在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，这叫作 element diff；","type":"text/markdown","created":"20230425084303443","creator":"oeyoews","modified":"20230425084314654","modifier":"oeyoews","tags":"React"},{"title":"react-for","text":"在 HTML 中，`for`是`label`元素的属性，用于与`input`元素相关联。当用户单击标签时，浏览器将把焦点转移到关联的输入元素上。例如：\r\n\r\n```html\r\n<label for=\"username\">用户名：</label>\r\n<input type=\"text\" id=\"username\">\r\n```\r\n\r\n在这个例子中，`label`元素的`for`属性指定了它所关联的`input`元素的 ID。因此，当用户单击标签时，输入元素将被选中。\r\n\r\n在 React JSX 中，因为`for`是 JavaScript 的保留字，应该使用`htmlFor`代替标签元素中的`for`属性。\r\n\r\n希望这个回答能够解决您的疑问！","type":"text/markdown","created":"20230502130500988","creator":"oeyoews","modified":"20230502130527910","modifier":"oeyoews","tags":"React"},{"title":"react-hooks","text":"useState：用于在函数组件内部添加 state 状态管理。\r\n\r\nuseEffect：用于控制函数组件的副作用，比如异步请求、定时器、事件监听等。\r\n\r\nuseContext：用于在函数组件中使用上下文信息。\r\n\r\nuseReducer：可用于替代 useState 实现复杂的状态逻辑，尤其在多个组件需要协同工作时效果更好。\r\n\r\nuseCallback：用于避免重复创建函数实例，提高组件性能，优化 useCallback 内部引用的函数的依赖项列表。\r\n\r\nuseMemo：用于缓存计算结果，优化性能。\r\n\r\nuseRef：用于在函数组件之间保留变量的引用，以便跨组件状态共享和访问 DOM 元素。\r\n\r\nuseImperativeHandle：与 useRef 配合使用，使得父组件可以直接访问和调用子组件上的方法。\r\n\r\nuseLayoutEffect：与 useEffect 类似，但会在 DOM 更新前同步执行。\r\n\r\nuseDebugValue：可用于方便地在 React 开发者工具中查看钩子函数的值。","type":"text/markdown","created":"20230430094251202","creator":"oeyoews","modified":"20230430094303768","modifier":"oeyoews","tags":"React"},{"title":"react-icons","text":"https://tabler-icons.io/\r\n\r\nhttps://github.com/react-icons/react-icons","type":"text/markdown","created":"20230701044404329","creator":"oeyoews","modified":"20230726045248761","modifier":"oeyoews","tags":"React"},{"title":"react-key","text":"在 React 中，当我们使用列表或循环渲染多个组件时，需要为每个组件指定一个 `key` 属性。这是因为 React 的 Virtual DOM 算法中使用了一种称为“协调（Reconciliation）”的机制来比较前后两次 DOM 树的差异并进行更新，而 `key` 属性在这个过程中起到了非常重要的作用。\r\n\r\n下面我来简单介绍一下为什么需要设置 `key` 属性：\r\n\r\n1. 加速组件重渲染：当我们的组件列表中的顺序发生变化时，如果没有为组件元素设置唯一的 `key` 属性，React 会认为这些元素都被删除了，然后重新创建和渲染新的元素，会无故浪费很多性能。而通过设置 `key` 属性，React 可以更加精确地识别哪些元素发生了变化，哪些元素需要被更新、添加或删除，从而减少无谓的重新渲染，提升性能。\r\n\r\n2. 更好的协调： `key` 属性还可以帮助 React 正确处理移动、添加和删除操作。如果两个元素在列表中的位置发生了交换，有了 `key` 属性，React 就不会认为它们是不同的元素，而是仅仅将它们的位置进行交换。这样可以避免因为移动列表中的元素而导致组件状态发生错误。\r\n\r\n总之，使用 `key` 属性是 React 中非常重要的一部分，可以提高渲染性能、增强组件的稳定性，并且有助于 React 正确地处理列表中元素的移动、添加和删除等操作。","type":"text/markdown","created":"20230423115521720","creator":"oeyoews","modified":"20230423115551702","modifier":"oeyoews","tags":"React"},{"title":"react-learn","text":"为了学习 React，你需要掌握以下几个方面：\r\n\r\n1. JavaScript 基础：React 是基于 JavaScript 的（特别是 ES6+），因此你需要熟悉 JavaScript 的基本语法、函数、对象、数组等。\r\n\r\n2. HTML 和 CSS：虽然 React 是用于构建 Web 应用程序的 JavaScript 库，但它仍与 HTML 和 CSS 密切相关。你需要熟悉 HTML 和 CSS 的基本语法和布局方式。\r\n\r\n3. React 基础概念：包括组件、状态、属性、生命周期等。\r\n\r\n4. React 组件库：这里有很多成熟的 React 组件库，如 Ant Design、Material-UI 等，学习使用这些组件库可以大大提高开发效率。\r\n\r\n5. React 路由：React Router 是一个流行的 React 路由器，它可帮助你处理应用程序中的页面导航。\r\n\r\n6. 状态管理：React 自带了一种状态管理工具——Context，还有第三方工具 Redux、MobX 等也是流行的状态管理工具。\r\n\r\n7. 数据请求：React 不涉及数据请求，但通常会与后端 API 集成。你需要了解如何使用 Fetch、Axios 或其他工具来进行数据请求。\r\n\r\n8. Webpack 和 Babel：这两个工具对于 React 开发至关重要。Webpack 可以处理模块打包、代码分离、命令行工具等，Babel 可以将 ES6+ 代码转换为向后兼容的 JavaScript 代码。\r\n\r\n在学习 React 的过程中，可以先阅读官方文档，然后再尝试构建一些简单的应用程序。同时还可以参加各种 React 社区提供的在线课程和讨论等活动，不断实践和完善自己的技能。","type":"text/markdown","created":"20230502123840670","creator":"oeyoews","modified":"20230502123904640","modifier":"oeyoews","tags":"React"},{"title":"react-map","text":"这个警告是由 React 引擎系统自动生成的，提示开发者需要为列表中的每个元素提供一个唯一的 `key` 属性。\r\n\r\n在 React 中， `key` 属性用于标识列表项，以便 React 能够快速准确地识别出需要更新或删除的元素。如果没有提供 `key` 属性，将会导致一些潜在的问题，比如：\r\n\r\n- React 可能需要在每次渲染时重新渲染所有的列表项，而不仅仅是更新有变化的部分。\r\n- 如果列表项发生重新排序，可能会导致 React 无法正确地识别和更新元素，从而导致意外的行为。\r\n\r\n我们可以通过给每个列表项添加一个唯一的 `key` 属性来解决这个问题。例如，在你的组件返回值中使用 `map()` 方法时，可以将每个元素的索引作为 `key` 属性的值：\r\n\r\n```jsx\r\nfunction App() {\r\n  const data = [3, 2, 1];\r\n  return (\r\n    <ul>\r\n      {data.map((item, index) => (\r\n        <li key={index} id={item}>\r\n          {item}\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  );\r\n}\r\n```\r\n\r\n在这里，我们使用 `map()` 方法的第二个参数 `index` 作为每个列表项的 `key` 属性的值，以确保每个元素在列表中都具有唯一标识。\r\n\r\n---\r\n在 React 中， map() 方法需要传入一个函数作为参数来遍历数组和生成新的 JSX 元素。这个函数就是我们通常所说的回调函数。\r\n\r\n回调函数的概念在计算机科学中非常常见。简单来说，回调函数就是在某个事件发生时被调用的函数。在 React 中， map() 方法是一个数组上的方法，它循环遍历数组并将每个元素传递给回调函数。因此，在 map() 方法中使用的函数就是回调函数。\r\n\r\n回调函数的作用是将数据进行转换或处理，并返回一个新的值。在 React 中，这个新的值通常是表示一组组件的 JSX 元素。我们将这些元素放在一个数组中并将其渲染到屏幕上。\r\n\r\n例如，下面的代码使用回调函数遍历数组 numbers 中的每个元素，并将它们转换为 <li> 元素：\r\n\r\njsx\r\nconst numbers = [1, 2, 3];\r\n\r\nconst listItems = numbers.map((number) => (\r\n  <li key={number.toString()}>{number}</li>\r\n));\r\n在这里，我们传递了一个匿名函数 (number) => (<li key={number.toString()}>{number}</li>) 给 numbers.map() 方法，该方法将遍历数组 numbers 中的每个元素，并将每个元素传递给回调函数。在回调函数中，我们以 number 作为参数，创建一个新的 <li> 元素并设置 key 属性。最终，返回的结果是一个包含三个元素的数组，表示列表中的所有数字。","type":"text/markdown","created":"20230423083813628","creator":"oeyoews","modified":"20230423083922935","modifier":"oeyoews","tags":"React"},{"title":"react-methods","text":"1. 使用 JSX 创建组件\r\n2. 使用组件 props 传递数据和方法\r\n3. 使用 state 存储组件状态\r\n4. 使用生命周期方法管理组件生命周期\r\n5. 使用事件处理函数处理用户交互\r\n6. 使用条件渲染和循环渲染控制组件显示\r\n7. 使用 ref 获取组件和 DOM 元素的引用\r\n8. 使用 Context 全局共享数据\r\n9. 使用 Redux 管理应用状态\r\n10. 使用 React Router 管理应用路由\r\n\r\n\r\n1. 使用 JSX 创建组件\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\nfunction MyComponent() {\r\n  return <h1>Hello World!</h1>;\r\n}\r\n\r\nexport default MyComponent;\r\n```\r\n\r\n2. 使用组件 props 传递数据和方法\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\nfunction MyComponent(props) {\r\n  return <button onClick={props.onClick}>{props.label}</button>;\r\n}\r\n\r\nexport default MyComponent;\r\n```\r\n\r\n3. 使用 state 存储组件状态\r\n\r\n```jsx\r\nimport React, { useState } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  function handleClick() {\r\n    setCount(count + 1);\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={handleClick}>Click me</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default MyComponent;\r\n```\r\n\r\n4. 使用生命周期方法管理组件生命周期\r\n\r\n```jsx\r\nimport React, { Component } from 'react';\r\n\r\nclass MyComponent extends Component {\r\n  componentDidMount() {\r\n    console.log('Component mounted');\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    console.log('Component unmounted');\r\n  }\r\n\r\n  render() {\r\n    return <h1>Hello World!</h1>;\r\n  }\r\n}\r\n\r\nexport default MyComponent;\r\n```\r\n\r\n5. 使用事件处理函数处理用户交互\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\nfunction MyComponent() {\r\n  function handleClick() {\r\n    console.log('Button clicked');\r\n  }\r\n\r\n  return <button onClick={handleClick}>Click me</button>;\r\n}\r\n\r\nexport default MyComponent;\r\n```\r\n\r\n6. 使用条件渲染和循环渲染控制组件显示\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\nfunction MyComponent(props) {\r\n  if (props.isVisible) {\r\n    return <h1>Hello World!</h1>;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport default MyComponent;\r\n```\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\nfunction MyComponent(props) {\r\n  const items = props.items.map(item => <li key={item.id}>{item.name}</li>);\r\n\r\n  return <ul>{items}</ul>;\r\n}\r\n\r\nexport default MyComponent;\r\n```\r\n\r\n7. 使用 ref 获取组件和 DOM 元素的引用\r\n\r\n```jsx\r\nimport React, { useRef } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const inputRef = useRef(null);\r\n\r\n  function handleClick() {\r\n    inputRef.current.focus();\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <input ref={inputRef} />\r\n      <button onClick={handleClick}>Focus input</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default MyComponent;\r\n```\r\n\r\n8. 使用 Context 全局共享数据\r\n\r\n```jsx\r\nimport React, { createContext, useContext } from 'react';\r\n\r\nconst MyContext = createContext();\r\n\r\nfunction MyComponent() {\r\n  return (\r\n    <MyContext.Provider value=\"Hello World!\">\r\n      <ChildComponent />\r\n    </MyContext.Provider>\r\n  );\r\n}\r\n\r\nfunction ChildComponent() {\r\n  const value = useContext(MyContext);\r\n\r\n  return <h1>{value}</h1>;\r\n}\r\n\r\nexport default MyComponent;\r\n```\r\n\r\n9. 使用 Redux 管理应用状态\r\n\r\n```jsx\r\nimport React from 'react';\r\nimport { connect } from 'react-redux';\r\n\r\nfunction MyComponent(props) {\r\n  function handleClick() {\r\n    props.dispatch({ type: 'INCREMENT' });\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <p>Count: {props.count}</p>\r\n      <button onClick={handleClick}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction mapStateToProps(state) {\r\n  return {\r\n    count: state.count,\r\n  };\r\n}\r\n\r\nexport default connect(mapStateToProps)(MyComponent);\r\n```\r\n\r\n10. 使用 React Router 管理应用路由\r\n\r\n```jsx\r\nimport React from 'react';\r\nimport { BrowserRouter as Router, Route, Link } from 'react-router-dom';\r\n\r\nfunction Home() {\r\n  return <h1>Home</h1>;\r\n}\r\n\r\nfunction About() {\r\n  return <h1>About</h1>;\r\n}\r\n\r\nfunction MyComponent() {\r\n  return (\r\n    <Router>\r\n      <nav>\r\n        <ul>\r\n          <li>\r\n            <Link to=\"/\">Home</Link>\r\n          </li>\r\n          <li>\r\n            <Link to=\"/about\">About</Link>\r\n          </li>\r\n        </ul>\r\n      </nav>\r\n\r\n      <Route exact path=\"/\" component={Home} />\r\n      <Route path=\"/about\" component={About} />\r\n    </Router>\r\n  );\r\n}\r\n\r\nexport default MyComponent;\r\n```","type":"text/markdown","created":"20230522115335779","creator":"oeyoews","modified":"20230726045248762","modifier":"oeyoews","tags":"React"},{"title":"react-native","text":"React Native 是一种基于 React 框架开发的移动端应用程序框架，它可以让你使用 JavaScript 和 React 的语法来编写原生应用程序。具体而言，React Native 向开发者提供了一套类似于 Web 前端技术的 API，包括 View、Text、Image 等基础组件，还有 StyleSheet 样式、Flex 布局等常见的 Web 前端技术。\r\n\r\nReact Native 的主要特点如下：\r\n\r\n1. 原生渲染：与传统的 Hybrid 应用不同，React Native 的组件并不是通过 WebView 渲染实现的，而是通过原生组件完成的，因此 React Native 应用程序的性能与原生应用程序非常接近。\r\n\r\n2. 热更新：React Native 支持热更新功能，即在应用程序运行中不需要重新打包和发布，就可以实时地更新应用程序的代码和资源文件。\r\n\r\n3. 跨平台：React Native 可以同时在 iOS 和 Android 平台上运行，并且开发者可以共享部分代码（如业务逻辑层），减少重复开发和维护成本。\r\n\r\n4. 组件化：React Native 采用组件化的开发方式，使得应用程序的 UI 部分可以高度抽象和复用，提高了开发效率和质量。\r\n\r\n5. 社区支持：React Native 拥有庞大的社区支持，有许多优秀的第三方组件和工具，可以帮助开发者更快地完成应用程序的开发和测试。\r\n\r\nReact Native 作为一种新兴的移动端应用程序开发框架，目前已经得到了广泛的应用和支持。由于它与 Web 前端技术的联系比较紧密，因此对于熟悉 React 框架和前端技术的开发者来说，学习和使用 React Native 也相对比较容易。","type":"text/markdown","created":"20230503031441315","creator":"oeyoews","modified":"20230503031457255","modifier":"oeyoews","tags":"React"},{"title":"react-props","text":"{ message } 和 (props) 都是 JavaScript 中传递函数参数的有效方式。\r\n\r\n使用解构赋值 { message } 允许你从传递给函数的对象中提取 message 属性。这可以使函数调用更加简洁和易读，特别是如果对象有许多属性，而你只需要其中的一些属性。然而，如果对象有很多属性，在函数中没有用到，解构可以创建不必要的代码。\r\n\r\n使用 (props) 允许你将具有任意数量属性的对象传递给函数。如果函数需要访问对象的多个属性，或者对象具有不预先知道的可变数量属性，这可能非常有用。然而，如果对象有很多属性，在函数中没有用到，传递整个对象作为 (props) 可能会创建不必要的开销。\r\n\r\n总的来说，{ message } 和 (props) 的选择取决于函数的具体需求和它所期望的对象参数。如果你只需要从对象中提取一些属性，并且预先知道这些属性是什么，解构可以使函数调用更加简洁。如果你需要访问对象的多个属性，或者对象具有可变数量的属性，将整个对象作为 (props) 传递可能更合适。","type":"text/markdown","created":"20230424152149080","creator":"oeyoews","modified":"20230424152207209","modifier":"oeyoews","tags":"React"},{"title":"react-redux-example","text":"以下是一个简单的 React 状态管理示例，使用 Redux 作为状态管理库：\r\n\r\n首先，我们需要创建一个 Redux store，并在应用程序中使用它。可以通过以下代码实现：\r\n\r\n```javascript\r\nimport { createStore } from 'redux';\r\nimport rootReducer from './reducers';\r\n\r\nconst store = createStore(rootReducer);\r\n\r\nfunction App() {\r\n  return (\r\n    <Provider store={store}>\r\n      <MyComponent />\r\n    </Provider>\r\n  );\r\n}\r\n```\r\n\r\n这样，我们就可以将 store 传递给应用程序中的组件。\r\n\r\n接下来，我们需要编写 reducer 函数，该函数用于处理不同的 action，并返回新的应用程序 state：\r\n\r\n```javascript\r\nconst initialState = {\r\n  todos: [],\r\n};\r\n\r\nfunction todoReducer(state = initialState, action) {\r\n  switch (action.type) {\r\n    case 'ADD_TODO':\r\n      return {\r\n        ...state,\r\n        todos: [...state.todos, action.payload],\r\n      };\r\n    case 'REMOVE_TODO':\r\n      return {\r\n        ...state,\r\n        todos: state.todos.filter((todo) => todo.id !== action.payload),\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n```\r\n\r\n在这个 reducer 中，我们定义了两个 action，一个用于添加 todo，另一个用于移除 todo。在每个 action 中，我们都返回了一个新的 state 对象，而不是修改原始 state 对象。\r\n\r\n接下来，我们需要编写一个 action creator，它是一个返回 action 对象的函数：\r\n\r\n```javascript\r\nfunction addTodoAction(todo) {\r\n  return {\r\n    type: 'ADD_TODO',\r\n    payload: todo,\r\n  };\r\n}\r\n\r\nfunction removeTodoAction(id) {\r\n  return {\r\n    type: 'REMOVE_TODO',\r\n    payload: id,\r\n  };\r\n}\r\n```\r\n\r\n最后，我们需要在组件中使用这些 action creator 来修改应用程序的状态。例如，我们可以在一个按钮点击事件中调用 addTodoAction：\r\n\r\n```javascript\r\nimport { connect } from 'react-redux';\r\nimport { addTodoAction } from './actions';\r\n\r\nfunction MyComponent({ todos, addTodo }) {\r\n  const [text, setText] = useState('');\r\n\r\n  function handleAdd() {\r\n    if (text) {\r\n      addTodo({\r\n        id: Math.random(),\r\n        text,\r\n      });\r\n      setText('');\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <input type=\"text\" value={text} onChange={(e) => setText(e.target.value)} />\r\n      <button onClick={handleAdd}>Add Todo</button>\r\n      <ul>\r\n        {todos.map((todo) => (\r\n          <li key={todo.id}>\r\n            {todo.text} <button onClick={() => removeTodo(todo.id)}>x</button>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst mapStateToProps = (state) => ({\r\n  todos: state.todos,\r\n});\r\n\r\nconst mapDispatchToProps = {\r\n  addTodo: addTodoAction,\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(MyComponent);\r\n```\r\n\r\n在这个组件中，我们使用 connect 函数将组件连接到 Redux store。通过 mapStateToProps 函数，我们将 store 中的 todo 状态映射到组件的 props 中，而 mapDispatchToProps 函数则将 addTodoAction 映射到组件的 props 中。最后，我们可以在点击事件中调用这个 action 来添加一个新的 todo。\r\n\r\n这就是一个简单的 React 状态管理示例，演示了如何使用 Redux 作为状态管理库来管理应用程序的状态。","type":"text/markdown","created":"20230430111115041","creator":"oeyoews","modified":"20230430111133240","modifier":"oeyoews","tags":"React"},{"title":"react-router","text":"React Router 是一个基于 React 的路由库，它可以帮助我们在 React 应用程序中管理不同页面之间的导航。使用 React Router，我们可以定义各种 URL 路径和对应的组件来实现不同页面的呈现和导航。\r\n\r\nReact Router 提供了多种路由类型，包括 BrowserRouter、HashRouter、MemoryRouter 等，在不同的项目场景下可以选择不同的路由类型。\r\n\r\n此外，React Router 还提供了很多功能，如路由嵌套、动态路由匹配、路由参数传递等等。这些功能可以让我们更加灵活地构建复杂的单页应用程序或多页应用程序。\r\n\r\n总之，React Router 是一个非常重要的库，它可以帮助我们实现页面之间的导航和流程控制，从而提升用户体验。","type":"text/markdown","created":"20230502111942875","creator":"oeyoews","modified":"20230502111955703","modifier":"oeyoews","tags":"React"},{"title":"react-router-route-components","text":"`react-router-dom` and `react-router` are two packages that are used for different purposes, but they both share a lot of the same code. Here's a brief overview of the differences between the two:\r\n\r\n- `react-router`: This is the core routing library for React. It provides the basic building blocks for creating a routing system in a React app. It includes components like `BrowserRouter`, `Route`, and `Link`.\r\n\r\n- `react-router-dom`: This package builds on top of `react-router`. It adds support for web-specific features like handling browser history and rendering `<a>` tags instead of `<Link>` tags.\r\n\r\nIn other words, you would typically use `react-router` if you're building a React app that needs to handle routing, regardless of whether it's a web app or a mobile app. On the other hand, if you're building a web app with React, you'll probably want to use `react-router-dom` so you can take advantage of its web-specific features.\r\n\r\nHere's an example of how you might import each package:\r\n\r\n```javascript\r\nimport { BrowserRouter as Router, Route, Link } from 'react-router-dom';\r\n\r\n// OR\r\n\r\nimport { BrowserRouter as Router, Route, Link } from 'react-router';\r\n```\r\n\r\nAs you can see, the usage is very similar between the two packages - the only difference is the name of the package you're importing from.\r\n\r\nrouter 和 route 是两个不同的概念，它们在 React Router 中扮演不同的角色。\r\n\r\nRouter: Router 是 React Router 中最基本的组件之一。它是一个高阶组件，用于将整个应用程序包装在路由器中。它提供了一个上下文对象，使得子组件可以访问到 react-router 的一些路由信息和方法。\r\n\r\nRoute: Route 是用于路由匹配的组件，用来控制那个页面渲染。每个 Route 组件都要有一个 path 属性，它表示这个路由所匹配的路径，当 URL 与路径匹配时，就会显示相应的 UI 界面。\r\n\r\n简单来说，Router 是一个组件，负责把整个应用程序进行路由处理。而 Route 是另外一个组件，用于匹配 URL 并对其进行处理渲染出相应的内容。当 URL 发生变化时，React Router 就会重新匹配当前 URL 对应的 Route，并且将对应的组件渲染到屏幕上。","type":"text/markdown","created":"20230502115639584","creator":"oeyoews","modified":"20230726045248764","modifier":"oeyoews","tags":"React"},{"title":"react-single-date","text":"## 单项数据流\" 概念解释\r\nreact 框架的原则中规定，子组件只可以使用父组件传递过来的 xxx 属性对应的值或方法，不可以改变。\r\n\r\n数据只能单向发生传递(父传向子，不允许子直接修改父)，若子组件想修改父组件中的数据，只能通过父组件暴露给子组件的函数(方法)来间接修改。\r\n\r\nreact 框架具体实现方式是设置父组件传递给子组件的\"数据值或方法\"仅仅为可读，但不可修改。\r\n\r\n为什么要做这样的限制？\r\n因为一个父组件可以有多个子组件，如果每个子组件都可修改父组件中的数据(子组件之间彼此共用父组件的数据)，一个子组件的数据修改会造成其他子组件数据更改，最终会让整个组件数据变得非常复杂。\r\n\r\n为了简化数据操作复杂程度，因此采用单向数据流策略，保证父组件数据的唯一最终可修改权归父组件所有。","type":"text/markdown","created":"20230428084511366","creator":"oeyoews","modified":"20230726045248766","modifier":"oeyoews","tags":"React"},{"title":"react-snippets","text":"## shortcuts\r\n\r\n`ctrl alt r` to search snippets(based vscode extensions)\r\n\r\n## imrc\r\n\r\n`import React, { Component } from 'react'`\r\n\r\n## imr\r\n\r\n`import React from 'react'`\r\n\r\n## rsc(React Stateless Component)\r\n```jsx\r\n\r\nimport React from 'react';\r\n\r\nconst ComponentName = () => {\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t\r\n\t\t</div>\r\n\t);\r\n};\r\n\r\nexport default ComponentName;\r\n```","type":"text/markdown","created":"20230424064913112","creator":"oeyoews","modified":"20230726045248766","modifier":"oeyoews","tags":"React"},{"title":"react-spring","text":"<https://github.com/pmndrs/react-spring>","type":"text/markdown","created":"20230501052623161","creator":"oeyoews","modified":"20230501052634344","modifier":"oeyoews","tags":"React"},{"title":"react-state-example01","text":"在 React 中，Provider 是一个高阶组件，用于向组件树中的所有子组件传递共享的数据或状态。Provider 接受一个名为 \"value\" 的 prop，该 prop 包含要共享的数据或状态。然后，Provider 将该值传递给其所有子组件，这些子组件可以通过使用 Consumer 组件来访问该值。\r\n\r\n以下是一个示例，演示如何在 React 中使用 Provider 和 Consumer：\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\n// 创建一个上下文\r\nconst MyContext = React.createContext();\r\n\r\n// 创建一个 Provider 组件\r\nclass MyProvider extends React.Component {\r\n  state = {\r\n    data: 'Hello, world!'\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <MyContext.Provider value={this.state.data}>\r\n        {this.props.children}\r\n      </MyContext.Provider>\r\n    );\r\n```\r\n\r\n在这个示例中，我们创建了一个上下文 MyContext，并使用 MyProvider 组件将状态数据 \"Hello, world!\" 传递给其所有子组件。然后，我们在 App 组件中使用 MyConsumer 组件来访问该值，并将其呈现为一个段落元素。这样，我们就成功地在组件树中共享了数据，并在子组件中使用 Consumer 组件来访问这些数据","type":"text/markdown","created":"20230430110941485","creator":"oeyoews","modified":"20230430111024599","modifier":"oeyoews","tags":"React"},{"title":"react-strictmode","text":"StrictMode is a built-in component in React that helps you to identify common issues and potential bugs earlier during development. When you wrap a section of your application in StrictMode, React will perform additional checks and give you warning messages in the console for things like:\r\n\r\nUsing deprecated methods\r\nIdentifying components with unsafe lifecycle methods\r\nDetecting unexpected side effects during rendering\r\nFinding potential issues with the usage of context APIs\r\nDetecting issues with the usage of setState and useReducer functions\r\nIn summary, StrictMode can be used as a tool to improve the quality of your code and to help you catch and fix issues before they become bigger problems. You can wrap your entire application or specific components with StrictMode in your index.js file like this:\r\n\r\n```jsx\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n```\r\n\r\nReact.StrictMode 是 React 中一个特殊的组件，它可以帮助您发现应用程序中潜在的问题和错误。\r\n\r\n使用 React.StrictMode 组件包装应用程序的根组件时，React 将会在开发模式下进行额外的检查和警告。这些检查包括：\r\n\r\n识别不安全的生命周期方法\r\n检测过时的 API 使用\r\n检测意外的副作用\r\n检测关于使用过时字符串 ref API 的错误\r\nReact.StrictMode 组件不会在生产环境中运行，它仅在开发环境中提供额外的检查和警告。这意味着您可以在开发过程中使用它，而不必担心将其包含在发布的应用程序中。\r\n\r\n例如，在以下代码中，React.StrictMode 组件包装了应用程序的根组件 App：\r\n\r\n```jsx\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n```\r\n\r\n在这个例子中，React.StrictMode 组件将触发 React 在开发模式下进行额外的检查，以帮助您发现应用程序中的潜在问题和错误。","type":"text/markdown","created":"20230424034648007","creator":"oeyoews","modified":"20230429015903527","modifier":"oeyoews","tags":"React"},{"title":"react-style","text":"In React, styles=`{{}}` is a way to define inline styles for a component using JavaScript objects.\r\n\r\nThe styles prop is an object that contains key-value pairs of CSS property names and their corresponding values. Each key represents a CSS property name, and each value is the value to be applied to that property. For example:\r\n\r\n```jsx\r\n<div style={{ \r\n\tcolor: 'red', \r\n\tfontSize: '16px'\r\n}}>\r\n\tHello, World!\r\n</div>\r\n```\r\n\r\nIn the above example, we define an inline style for a `<div>` element. The styles prop is set to an object with two properties: color and fontSize. The color property is set to 'red', and the fontSize property is set to 16px.\r\n\r\nNote that the styles prop is actually a JavaScript object, not a string. The double curly braces `{{}}` are used to indicate that we are passing a JavaScript object as a prop. The inner set of curly braces contains the JavaScript object itself.\r\n\r\nUsing inline styles with the styles prop in React can be useful for adding dynamic styling to a component, since the values can be computed dynamically using JavaScript expressions.","type":"text/markdown","created":"20230426055358263","creator":"oeyoews","modified":"20230726045248767","modifier":"oeyoews","tags":"React"},{"title":"react-use-dynamic-tailwindcss","text":"## dyanmic tailwindcss\r\n\r\n```jsx\r\n<p className={`m-0 max-w-[30ch] text-lg ${isActive ? 'bg-gray-200' : ''} ${customClassName}`}>\r\n  Find in-depth information about Next.js features and API.\r\n</p>\r\n```","type":"text/markdown","created":"20230504024935858","creator":"oeyoews","modified":"20230504025008149","modifier":"oeyoews","tags":"React"},{"title":"react-心智负担","text":"\"React 心智负担\"是指在使用 React 进行开发时，开发者需要处理和跟踪的复杂性和认知负荷。它反映了在构建和维护复杂 React 应用程序时所面临的挑战。\r\n\r\nReact 的强大之处在于它提供了一种组件化的方式来构建用户界面。然而，随着应用程序的复杂性增加，组件之间的相互关系、数据流动和状态管理等方面变得更加复杂。开发者需要花费更多的精力来理解和处理这些复杂性。\r\n\r\nReact 心智负担可能会出现在以下情况下：\r\n\r\n1. 组件层次结构复杂：随着组件的嵌套和相互依赖关系的增加，理解和维护组件层次结构变得更加困难。\r\n\r\n2. 状态管理：React 的状态管理是以单向数据流的方式进行的，当状态和数据在多个组件之间传递时，开发者需要仔细考虑如何设计和管理状态，防止出现混乱和不一致的情况。\r\n\r\n3. 生命周期管理：React 组件具有生命周期方法，在特定事件发生时触发。理解和正确使用生命周期方法可以是一项挑战，特别是在处理异步操作或数据加载时。\r\n\r\n4. 虚拟 DOM 和渲染：React 通过虚拟 DOM 机制来进行高效的 UI 更新。但是，开发者需要了解虚拟 DOM 的工作方式，并确保他们的组件正确地渲染和更新。\r\n\r\n为了减轻 React 心智负担，可以采取以下措施：\r\n\r\n1. 使用组件库和工具：使用优秀的第三方组件库（如 Material-UI、Ant Design 等）可以简化组件的构建和样式处理。\r\n\r\n2. 使用状态管理库：选择适合项目的状态管理库（如 Redux、MobX 等）来处理复杂的状态管理需求，确保代码清晰可维护。\r\n\r\n3. 模块化和代码分割：将应用程序拆分成小的、可重用的模块，使用代码分割来按需加载组件，减少复杂性和提高性能。\r\n\r\n4. 学习和实践最佳实践：深入研究 React 文档和社区资源，了解最佳实践和设计模式，以更好地理解和应对 React 应用程序的挑战。","type":"text/markdown","tags":"React"},{"title":"react01","text":"* 命令式 过程优先\r\n* 声明式 只关心结果, 不关心过程","type":"text/markdown","created":"20230423040402015","creator":"oeyoews","modified":"20230423040504309","modifier":"oeyoews","tags":"React"},{"title":"README","text":"Markdown 是一种轻量级的标记语言，具有以下几个优点：\n\n1. 简单易学：Markdown 语法简洁明了，语法规则简单，学习成本低。只需记住几个基本符号，即可快速上手使用。\n\n2. 平台无关性：Markdown 可以在几乎所有文本编辑器和网页浏览器中使用，无论是 Windows、Mac 还是 Linux 系统，都可以轻松编辑和阅读 Markdown 文件。\n\n3. 格式清晰可读：Markdown 文本具有良好的可读性和格式清晰性。通过简单的标记语法，可以快速实现标题、列表、链接、引用等文本格式化操作，使文档结构清晰、易于阅读。\n\n4. 兼容性强：Markdown 文本可以轻松转换为其他常用格式，如 HTML、PDF、Word 等，方便与其他人协作或进行多媒体展示。\n\n5. 支持版本控制：由于 Markdown 是纯文本格式，易于与版本控制系统（如 Git）结合使用，方便进行文档的版本管理和协同编辑。\n\n6. 支持代码展示：Markdown 内置支持代码段的展示，可以很方便地插入代码块，并指定代码语言，使代码显示更加美观和易于理解。\n\n总之，Markdown 简单、易用，并且具有广泛的应用性，非常适合在写作、博客、文档编写、项目文档等方面使用。它可以帮助用户专注于内容的创作，而不需要过多关注格式和排版的细节。\n\n> 这里主要记录但不限于一些临时想法，代码，日记，名词解释，bug，笔记，书单等\n","type":"text/markdown"},{"title":"reduce-filter-map","text":"使用 `filter()` 和 `map()` 方法时会遍历数组两次，而使用 `reduce()` 方法可以在只遍历一次数组的情况下实现相同的效果，从而更高效。\n\n`reduce()` 方法是数组的一个高阶函数，在每次迭代过程中将数组元素归约为单个值。它接受一个回调函数作为参数，并且可以传递一个初始值作为累加器的起始值。\n\n下面是一个使用 `filter()` 和 `map()` 方法的示例代码：\n\n```python\n# 使用 filter() 和 map() 遍历数组两次\narray = [1, 2, 3, 4, 5]\n\nfiltered_array = filter(lambda x: x % 2 == 0, array)\nmapped_array = map(lambda x: x * 2, filtered_array)\n\nresult = list(mapped_array)\nprint(result)  # 输出 [4, 8]\n\n```\n\n而下面是使用 `reduce()` 方法实现相同效果的示例代码：\n\n```python\n# 使用 reduce() 遍历数组一次\nfrom functools import reduce\n\narray = [1, 2, 3, 4, 5]\n\nresult = reduce(lambda acc, x: acc + [x * 2] if x % 2 == 0 else acc, array, [])\n\nprint(result)  # 输出 [4, 8]\n```\n\n在上述代码中，`reduce()` 方法的回调函数接受两个参数：`acc`（累加器）和 `x`（当前迭代的数组元素）。在每次迭代过程中，如果当前元素 `x` 满足条件（偶数），则将其乘以 2 并添加到累加器 `acc` 中；否则，直接返回累加器 `acc`。最终的结果是一个包含满足条件的元素的列表。\n\n因此，使用 `reduce()` 方法可以在只遍历一次数组的情况下完成过滤和映射的操作，提高了效率。\n\n不需要一直使用 `reduce()` 方法代替 `filter()`。实际上，根据具体的需求和代码可读性，选择使用适当的方法是更为重要的。\n\n`reduce()` 方法在某些情况下可以替代 `filter()` 和 `map()` 方法，但并不意味着它必须一直代替它们。以下是一些考虑因素：\n\n1. 可读性：使用 `filter()` 和 `map()` 方法可以更直观地表达你的意图。这些方法是广为人知的函数式编程范式，可以使代码更易于理解和维护。相比之下，使用 `reduce()` 方法可能需要更多的解释和理解成本。\n\n2. 代码简洁性： `filter()` 和 `map()` 方法通常可以更简洁地实现过滤和映射的操作，而 `reduce()` 方法可能需要更多的代码来处理边界条件和累加器的初始值。\n\n3. 性能：虽然 `reduce()` 方法只遍历一次数组，但在某些情况下，使用 `filter()` 和 `map()` 方法可能会更高效。因为这些方法具有优化的实现，并且在底层使用了高度优化的算法。\n\n因此，在选择使用 `filter()`、`map()` 或 `reduce()` 方法时，建议综合考虑以上因素，并根据具体的情况做出决策。在大多数情况下，使用 `filter()` 和 `map()` 方法会更为常见和推荐。只有在一些特定的场景下，才会选择使用 `reduce()` 方法来提高效率。","type":"text/markdown","created":"20231103080948734","creator":"Lenovo","modified":"20231103081025359","modifier":"Lenovo","tags":"JavaScript"},{"title":"redux","text":"Redux 和 useState 不会发生冲突。它们都是 React 中不同类型的状态管理工具，用于在组件之间共享数据。\r\n\r\nuseState 是 React 内置的状态管理机制，它允许在函数式组件中定义和更新组件的本地状态（state）。每个 useState 调用都只影响到当前组件本身。使用 useState 时，React 会根据状态更新重新渲染组件的 UI。\r\n\r\nRedux 是一个独立于 React 的状态容器，用于管理应用程序的全局状态。Redux 允许在多个组件之间分享相同的状态，并使用单向数据流来确保数据的一致性。Redux 通常与 React 结合使用，但也可以与其他框架和库一起使用。\r\n\r\n在 React 中使用 Redux 时，Redux 存储在单独的状态树中，而不是存储在组件的本地状态中。组件可以通过 dispatch（）函数向 Redux 发送操作，操作触发 Redux 中对应的 reducer 函数，从而更新 Redux 中的状态树。然后，React 会在 Redux 状态被更新时重新呈现受影响的组件。\r\n\r\n使用 Redux 或 useState，取决于应用程序的需要和开发者的偏好。Redux 适用于大型应用程序，需要跨组件共享状态的情况。而 useState 通常用于小型应用程序或仅需要在本地控制状态的组件。开发者可以根据实际情况并结合实践来选择合适的状态管理工具。","type":"text/markdown","created":"20230428084651907","creator":"oeyoews","modified":"20230428084705660","modifier":"oeyoews","tags":"React"},{"title":"redux-state-lib","text":"React 状态管理库有很多，以下列举几个常用的：\r\n\r\nRedux：它是最流行的 React 状态管理库之一，通过单一、可预测且可控制的状态管理来使应用程序更具可伸缩性。\r\n\r\nMobX：它是一个简单、可扩展和高度可靠的状态管理库，它与 React 的集成非常紧密，可以实现自动更新机制，让代码更加简洁易懂。\r\n\r\nRecoil：这是 Facebook 推出的一个新的状态管理库，旨在使 React 应用的状态管理变得更加简洁、灵活、可扩展和可组合。\r\n\r\nZustand：一个基于 React Hooks 的轻量级状态管理库。它提供了类似 Redux 的状态管理器接口，但同时又能够避免 Redux 的繁琐和冗长的配置。\r\n\r\nXState：一个用于 JavaScript 状态机的库，适用于任何前端框架。它的思想是使用状态来描述用户界面的各种状态，并以状态转换的方式来处理用户界面的交互。\r\n\r\n以上这些状态管理库都有各自的","type":"text/markdown","created":"20230430105627523","creator":"oeyoews","modified":"20230430105641299","modifier":"oeyoews","tags":"React"},{"title":"redux-store","text":"在 redux 中，store 是一个包含整个应用程序状态的对象。它是一个单一的 JavaScript 对象，其中包含应用程序的所有数据和状态。store 可以被视为应用程序中的一个全局变量，您可以在任何地方访问它，以获取或更改应用程序的状态。store 通过 reducer 处理 action，并根据 action 的类型更新应用程序的状态。当状态发生变化时，store 将通知应用程序中的任何订阅者，以便它们可以更新自己的状态和 UI。store 可以通过 Provider 组件提供给 React 组件树中的所有组件。","type":"text/markdown","created":"20230428090025500","creator":"oeyoews","modified":"20231018062321564","modifier":"Lenovo","tags":"React"},{"title":"relative-absoulte","text":"<div class=\"relative bg-red-400/20 p-4 h-32\">\r\ndemo\r\n<div class=\"absolute bottom-0 bg-red-200 p-2 right-0 rounded-lg shadow-lg \">\r\n\t\tdemo\r\n</div>\r\n</div>","type":"text/markdown","created":"20230712065249996","creator":"oeyoews","modified":"20230909051207460","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"Release__Yarn_4.0_🪄⚗️___Yarn","text":"Today is the day! After more than a year of work, our team is excited to finally put a fancy \"stable\" sticker on the first release from the 4.x release line! To celebrate, let's make together a tour of the major changes; should you look for a more itemized list, take a look at the [changelog](https://yarnpkg.com/advanced/changelog#400).今天是一天！经过一年多的工作，我们的团队很高兴终于在 4.x 发布线的第一个版本上贴上了一个花哨的“稳定”贴纸！为了庆祝，让我们一起参观主要变化;如果您正在寻找更详细的列表，请查看更新日志。\n\n## Breaking Changes[​](#breaking-changes \"Direct link to Breaking Changes\") 重大变更\n\nHere's what you need to know when upgrading from 3.x projects:以下是从 3.x 项目升级时需要了解的内容：\n\n* We now require Node.js 18+.我们现在需要 Node.js 18+。\n* New projects created with `yarn init` won't enable [Zero-Install](https://yarnpkg.com/features/caching#zero-installs) by default anymore.默认情况下，使用 创建 `yarn init` 的新项目将不再启用零安装。\n* New projects created with `yarn init` will use [Corepack](https://nodejs.org/api/corepack.html) rather than `yarnPath`.使用 创建 `yarn init` 的新项目将使用 Corepack 而不是 `yarnPath` 。\n* All official plugins (`typescript`, `interactive-tools`, ...) are now included by default.现在默认包含所有官方插件（ `typescript` `interactive-tools` 、、...）。\n* The `yarn workspaces foreach` command has a slightly altered syntax.该 `yarn workspaces foreach` 命令的语法略有改动。\n\n## Installing Yarn[​](#installing-yarn \"Direct link to Installing Yarn\") 安装纱线\n\nEver since the 2.0 our recommendation has been to install Yarn on a per-project basis using the `yarnPath` setting (automatically set either of `yarn init -2` and `yarn set version`). We intentionally don't release modern releases on the npm `yarn` package, [so as not to break older projects which didn't migrate yet](https://yarnpkg.com/getting-started/qa#why-is-the-yarn-package-on-npm-still-on-1x).自 2.0 以来，我们的建议是使用以下 `yarnPath` 设置（自动设置 和 `yarn set version` ）。 `yarn init -2` 我们故意不在 npm `yarn` 包上发布现代版本，以免破坏尚未迁移的旧项目。\n\nTo that end we used to recommend using the `yarnPath` setting pointing to a checked-in binary, but this pattern increased friction more than we liked - many people didn't like the idea of adding a binary to their repository, however small. We listened, and worked conjointely with Node.js on a project called [Corepack](https://nodejs.org/api/corepack.html). Corepack is a tool shipped with Node.js 16+ that will automatically select the right package manager version to run depending on the project you're working on.为此，我们曾经建议使用指向已签入二进制文件的 `yarnPath` 设置，但这种模式增加了比我们喜欢的更多的摩擦 - 许多人不喜欢将二进制文件添加到他们的存储库的想法，无论多么小。我们倾听并与 Node 合作.js 在一个名为 Corepack 的项目上。Corepack 是 Node.js 16+ 附带的工具，它将根据您正在处理的项目自动选择要运行的正确包管理器版本。\n\nNow that Corepack is shipped with both Node 18 and 20 we no longer need to rely on `yarnPath`, and as a result we updated our [installation guide](https://yarnpkg.com/getting-started/install) to reflect that. The `yarn init -2` and `yarn set version` commands have been updated to favor updating the `packageManager` field when possible.现在 Corepack 随节点 18 和 20 一起提供，我们不再需要依赖 `yarnPath` ，因此我们更新了安装指南以反映这一点。和 `yarn set version` 命令已更新， `yarn init -2` 以便尽可能更新 `packageManager` 字段。\n\ninfo 信息\n\nCorepack knows which package manager version to use thanks to the standard `packageManager` field in your `package.json`. This field will typically be set via one of `yarn init -2`, `yarn set version x.y.z`, or the more generic `corepack use yarn@x.y.z`.Corepack 知道要使用哪个包管理器版本，这要归功于 `packageManager` `package.json` .此字段通常通过 `yarn init -2` 、 `yarn set version x.y.z` 或更通用 `corepack use yarn@x.y.z` 的 之一进行设置。\n\n## Hardened Mode[​](#hardened-mode \"Direct link to Hardened Mode\") 强化模式\n\nYarn attempts to protect you from common attacks, and this is pushed even further by the introduction of the Hardened Mode. When operating under this mode, Yarn will perform two extra validations:Yarn 试图保护您免受常见攻击，而强化模式的引入进一步推动了这一点。在此模式下运行时，Yarn 将执行两个额外的验证：\n\n* It will validate the resolutions stored in the lockfile are consistent with what the ranges could resolve to.它将验证存储在锁定文件中的分辨率是否与范围可以解析的内容一致。\n* It will validate that the package metadata stored in the lockfile are consistent the remote registry metadata.它将验证存储在锁文件中的包元数据是否与远程注册表元数据一致。\n\nTogether, those checks will prevent any attacker from surreptitiously modifying your lockfiles when making PRs to your project using Yarn (<https://snyk.io/blog/why-npm-lockfiles-can-be-a-security-blindspot-for-injecting-malicious-modules/>).总之，这些检查将防止任何攻击者在使用 Yarn （https://snyk.io/blog/why-npm-lockfiles-can-be-a-security-blindspot-for-injecting-malicious-modules/） 为您的项目制作 PR 时偷偷修改您的锁文件。\n\ntip 提示\n\nThe Hardened Mode is enabled by toggling on `enableHardenedMode`, but it's also automatically enabled when Yarn detects that it runs within a GitHub pull request on a public repository. This can be disabled by explicitly toggling off `enableHardenedMode` in your yarnrc file.强化模式通过打开 `enableHardenedMode` 来启用，但当 Yarn 检测到它在公共存储库的 GitHub 拉取请求中运行时，它也会自动启用。这可以通过在 yarnrc 文件中显式关闭 `enableHardenedMode` 来禁用。\n\ncaution 谨慎\n\nInstalls operating under Hardened Mode constraints are significantly slower than usual as they need to perform many network requests that would be skipped otherwise. We don't recommend enabling it by default - if you need it in a specific CI job, toggle it on via an environment variable:在强化模式约束下运行的安装比平时慢得多，因为它们需要执行许多网络请求，否则这些请求将被跳过。我们不建议默认启用它 - 如果您在特定的 CI 作业中需要它，请通过环境变量将其打开：\n\n```plain\nexport YARN_ENABLE_HARDENED_MODE=1\n```\n\n## JavaScript Constraints[​](#javascript-constraints \"Direct link to JavaScript Constraints\") JavaScript 约束\n\nYarn is the only package manager to implement a [constraints engine](https://yarnpkg.com/features/constraints). If you don't know it, this feature lets you define a set of rules that your project must satisfy. For instance, the Yarn repository enforces that no two workspaces depend on different versions of any given dependencies, unless explicitly allowed.Yarn 是唯一实现约束引擎的包管理器。如果您不知道，此功能允许您定义项目必须满足的一组规则。例如，Yarn 存储库强制要求没有两个工作区依赖于任何给定依赖项的不同版本，除非明确允许。\n\nOur constraints engine used to be powered by Tau-Prolog, a JavaScript [Prolog](https://en.wikipedia.org/wiki/Prolog#Rules_and_facts) implementation. Unlike imperative languages like JavaScript, Prolog uses a different model called logic programming - you define that something exists if a rule is true. It's a very interesting pattern that integrates well with the concept of rule-based linting. Unfortunately, Prolog proved very complex to use, increasing the learning curve of constraints past the threshold we were comfortable with.我们的约束引擎过去由 JavaScript Prolog 实现的 Tau-Prolog 提供支持。与 JavaScript 等命令式语言不同，Prolog 使用一种称为逻辑编程的不同模型 - 如果规则为真，则定义存在某些东西。这是一个非常有趣的模式，与基于规则的 linting 的概念很好地集成在一起。不幸的是，Prolog 被证明使用起来非常复杂，将约束的学习曲线增加到了我们满意的阈值之外。\n\nAs a result, Prolog constraints are deprecated starting from Yarn 4, and **they have been superseded by a shiny new JavaScript-based engine, with optional TypeScript support!** We have been writing our own rules at [Datadog](https://www.datadoghq.com/) with this framework for a couple of months now, with great success. You can also check the public [Yarn repository](https://github.com/yarnpkg/berry/blob/c3b319a8943dcc35e689ebff4051c112bfc598f5/yarn.config.cjs#L17-L43) for a practical example of the kind of rules you can enforce at the repository level, and the [newly revamped documentation](https://yarnpkg.com/features/constraints) is there to help you quickly get up to speed.因此，Prolog 约束从 Yarn 4 开始被弃用，并且它们已被一个闪亮的基于 JavaScript 的新引擎所取代，该引擎具有可选的 TypeScript 支持！几个月来，我们一直在 Datadog 上用这个框架编写自己的规则，并取得了巨大的成功。您还可以查看公共 Yarn 存储库，以获取可以在存储库级别强制执行的规则类型的实际示例，新修订的文档可帮助您快速上手。\n\ntip 提示\n\nThe new optional `enableConstraintsChecks` setting will make Yarn run your constraints as part of `yarn install`. It's a handy way to surface errors before having to wait for the remote CI to raise them, and since the new engine is so fast, it has almost no impact on your install time 🚀新的可选 `enableConstraintsChecks` 设置将使 Yarn 将约束作为 的一部分 `yarn install` 运行。这是一种在等待远程 CI 引发错误之前发现错误的便捷方法，而且由于新引擎速度如此之快，因此对您的安装时间🚀几乎没有影响\n\nVarious features in Yarn used to be shipped as sideloaded plugins that needed to be managed separately from the main bundle. While this helped us build a plugin ecosystem, it also proved challenging to manage for our users. We implemented some features to make that easier (auto-upgrade plugins when you auto-update Yarn), but in the end the few KiBs we gained by not shipping all the features by default weren't worth the confusion and friction they caused.Yarn 中的各种功能过去都是作为旁加载插件提供的，需要与主捆绑包分开管理。虽然这有助于我们构建插件生态系统，但事实证明，为我们的用户管理也具有挑战性。我们实现了一些功能来简化此操作（自动更新 Yarn 时会自动升级插件），但最终，由于默认情况下没有提供所有功能而获得的几个 KiB 不值得它们造成的混乱和摩擦。\n\nAs a result, while Yarn still supports third-party plugins (and will continue to in the future), **all the features and commands we build are now available as part of the main distribution**. You can now use `yarn upgrade-interactive` and `yarn stage` without plugins and, if you have TypeScript configured in your project, Yarn will now auto-add and remove `@types` packages as needed whenever you update your dependencies with `yarn add` and `yarn remove`.\n\n## Improved User Interface[​](#improved-user-interface \"Direct link to Improved User Interface\")\n\nVarious pieces of the UI got revamped to better convey information. For example, `yarn install` now tells you the packages you added, and their total weight. You will also notice it doesn't print as much warnings around peer dependencies, as we now try to only print warnings for actionable situations:\n\n```plain\n➤ YN0000: · Yarn 4.0.0\n\n➤ YN0000: ┌ Resolution step\n\n➤ YN0085: │ + next@npm:13.5.4, react-dom@npm:18.2.0, and 24 more.\n\n➤ YN0000: └ Completed in 0s 280ms\n\n➤ YN0000: ┌ Fetch step\n\n➤ YN0013: │ 22 packages were added to the project (+ 177.72 MiB).\n\n➤ YN0000: └ Completed in 3s 723ms\n\n➤ YN0000: ┌ Link step\n\n➤ YN0000: └ Completed\n\n➤ YN0000: · Done with warnings in 4s 123ms\n```\n\nAnother example is the `yarn config` command, which sports a new tree display and now also accepts an arbitrary number of settings as positional arguments, letting you select what you wish to see:\n\n```plain\n├─ cacheFolder\n\n│  ├─ Description: Folder where the cache files must be written\n\n│  ├─ Source: \n\n│  └─ Value: '/Users/global/.yarn/berry/cache'\n\n│\n\n└─ enableHardenedMode\n\n   ├─ Description: If true, automatically enable --check-resolutions --refresh-lockfile on installs\n\n   ├─ Source: \n\n   └─ Value: null\n```\n\n## Performances[​](#performances \"Direct link to Performances\")\n\nThe 4.0 isn't lagging behind in performance improvements, and shows to be significantly faster at installs than the 3.6. For instance, here's the difference in time to install Gatsby and its ~350MiB dependency tree from a cold cache. The 3x improved performances are due to a new package metadata cache which significantly improves performances of repeated installs:\n\n```plain\nhyperfine -L v stable,canary --prepare 'rm -rf ~/.yarn/berry/cache' 'cd $(mktemp -d) && yarn init -2 && yarn set version {v} && yarn && yarn add gatsby --mode=skip-build'\n```\n\n```plain\nBenchmark 1: 3.6.0\n  Time (mean ± σ):     65.599 s ±  2.214 s    [User: 82.952 s, System: 8.638 s]\n  Range (min … max):   62.167 s … 68.277 s    10 runs\n\nBenchmark 2: 4.0.0\n  Time (mean ± σ):     16.724 s ±  0.928 s    [User: 14.622 s, System: 5.743 s]\n  Range (min … max):   15.318 s … 18.110 s    10 runs\n\nSummary\n  4.0.0 ran 3.92 ± 0.25 times faster than 3.6.0\n```\n\nThese changes make Yarn [as fast as pnpm in most scenarios](https://yarnpkg.com/features/performances), although competition is still fierce 🔥\n\n## Fancy Website[​](#fancy-website \"Direct link to Fancy Website\")\n\nAs you probably noticed, our website received a major overhaul, both style and content! We worked on this new iteration for more than a year now, and we hope it'll help you find better information, faster than before.\n\nSome particular improvements:\n\n* All referenced commands now link to their documentation (`yarn install`)\n* All referenced options now have a tooltip explaining their goal (`yarn --immutable-cache`)\n* Most pages were rewritten to be both simplified & clarified when needed\n* The package page now shows various configurable checks, like whether a package supports CJS, ESM, has types, ...\n\nOur expertise lies in tooling more than building websites, so I'm sure various hanging fruits remain - especially around loading time. If you're interested to help us, check the [sources](https://github.com/yarnpkg/berry/tree/master/packages/docusaurus) and please feel free to send PRs our way!\n\n## Closing Words[​](#closing-words \"Direct link to Closing Words\")\n\nThe journey to transition from Yarn 3 to Yarn 4 was a lengthy one, with a whopping 53 release candidates along the way, but we finally made it! Our aim for this new iteration has been to both decrease Yarn's learning curve and improve your user experience, without the migration feeling overwhelming. We made concerted efforts to avoid making significant breaking changes unless we also had ways to automatically migrate projects, so if you encounter any issues that you believe the software should have addressed, share your feedback with us on [Discord](https://discord.gg/yarnpkg).\n\nAs for what lies ahead, it's a bit too early to provide a definitive answer, but I can tell you I'm particularly intrigued by the potential for native Yarn builds. Performances has been under the spotlight lately, and I sometimes wonder how much overhead may have Node.js on the overall execution time. That being said, we don't plan on undertaking another complete rewrite of the codebase, nor do we want to compromise the factors that make Yarn so contributor-friendly, so the specifics, as well as the timeline, are still under consideration.\n\nIn the meantime we'll continue to build upon our existing foundations for the time being. From CLI completion and UI commands to reducing the learning curve and general upkeep, we have a broad array of improvements on our radar. So see you next time!\n","type":"text/markdown","created":"20231024061050847","creator":"太微搜藏","modified":"20231024061050847","modifier":"太微搜藏","tags":"剪藏","url":"https://yarnpkg.com/blog/release/4.0"},{"title":"rem-px-em","text":"在 HTML 和 CSS 中，rem、em 和 px 是用于定义文本和元素大小的单位。让我为您详细解释一下它们的含义：\n\n1. **px（像素）**：\n   - **定义**：像素是屏幕上的最小显示单元，通常用于固定大小的元素。\n   - **示例**：`font-size: 16px;` 表示文本的大小为 16 像素。\n\n2. **em**：\n   - **定义**：em 是相对于元素的字体大小来定义大小的单位。如果您在一个元素上设置字体大小为 1em，它将等于该元素的父元素的字体大小。\n   - **示例**：如果父元素的字体大小为 16px，然后子元素的字体大小设置为 1.5em，那么子元素的字体大小将为 16 * 1.5 = 24px。\n\n3. **rem**：\n   - **定义**：rem 也是相对单位，但它是相对于根元素（通常是`<html>`标签）的字体大小来定义的。这使得 rem 在整个文档中保持一致性，不受父元素字体大小的影响。\n   - **示例**：如果根元素的字体大小为 16px，然后设置一个元素的字体大小为 2rem，它将等于 32px（2 倍的根元素字体大小）。\n\n总结：\n- px 是绝对单位，通常用于固定大小的元素。\n- em 是相对单位，相对于父元素的字体大小来定义大小。\n- rem 也是相对单位，相对于根元素的字体大小来定义大小，并在整个文档中保持一致性。\n\n您可以根据设计的需要选择合适的单位来定义文本和元素的大小。\n\n:::note\n混合使用不同的单位（如 px、em 和 rem）可能会导致一些布局和样式问题，因此需要谨慎使用。下面是一些可能出现的问题以及如何避免它们：\n\n1. **不一致的字体大小**：如果您混合使用 px、em 和 rem 来定义字体大小，可能会导致不一致的字体大小，使页面看起来不协调。为了避免这个问题，尽量使用相对单位（em 和 rem）来定义字体大小，以确保文本大小相对一致。\n\n2. **复杂的样式计算**：混合使用不同的单位会导致复杂的样式计算，使代码难以维护。建议尽量保持一致性，选择一种主要的单位来定义大小，并在需要的情况下使用相对单位来微调样式。\n\n3. **响应式设计问题**：在响应式设计中，使用不同单位可能会导致布局在不同屏幕尺寸下出现问题。确保在响应式设计中考虑并测试不同单位的行为，以确保页面在不同设备上都能正常显示。\n\n4. **性能问题**：在某些情况下，使用不同单位可能会导致性能问题，因为浏览器需要进行复杂的单位转换。虽然现代浏览器通常能够有效处理这些转换，但过度混合单位可能会导致性能下降。\n\n总之，混合使用不同单位并不一定会导致问题，但需要谨慎处理。建议在项目中选择一种主要的单位来保持一致性，只在必要的情况下使用其他单位，同时进行测试以确保样式和布局在不同情况下都能正常工作。这将有助于提高代码的可维护性和一致性。\n:::","type":"text/markdown","created":"20231010055520351","creator":"Lenovo","modified":"20231010055612372","modifier":"Lenovo","tags":"Tailwindcss CSS"},{"title":"remember-everything","text":"* <https://ncase.me/remember/zh.html>","type":"text/markdown","created":"20230401122116491","creator":"oeyoews","modified":"20230401122125590","modifier":"oeyoews","tags":""},{"title":"remove-neovim-lastline","text":"[remove lastline](https://stackoverflow.com/questions/1050640/how-to-stop-vim-from-adding-a-newline-at-end-of-file)\r\n\r\n[issue](https://github.com/vim/vim/issues/488)","type":"text/markdown","created":"20230610045709595","creator":"oeyoews","modified":"20230726045248768","modifier":"oeyoews","tags":"Neovim"},{"title":"remove-none-images","text":"```docker\r\ndocker rmi $(docker images -f \"dangling=true\" -q)\r\n```","type":"text/markdown","created":"20230925080743226","creator":"oeyoews","modified":"20230925080812252","modifier":"oeyoews","tags":"docker"},{"title":"remove-obj-arrt","text":"如果你想删除 JavaScript 对象的属性，但又不想改变原始对象，则可以使用 `Object.assign()` 或扩展运算符（`...`）等方法来创建新对象并复制原始对象的所有属性，然后再从新对象中删除属性。以下是一个示例：\n\n```javascript\nconst originalObj = {\n  name: 'John',\n  age: 30,\n  city: 'New York'\n};\n\n// 使用 Object.assign() 复制对象并删除属性\nconst newObj = Object.assign({}, originalObj);\ndelete newObj.age;\n\nconsole.log(originalObj); // 输出 { name: 'John', age: 30, city: 'New York' }\nconsole.log(newObj); // 输出 { name: 'John', city: 'New York' }\n\n// 使用扩展运算符复制对象并删除属性\nconst anotherObj = { ...originalObj };\ndelete anotherObj.city;\n\nconsole.log(originalObj); // 输出 { name: 'John', age: 30, city: 'New York' }\nconsole.log(anotherObj); // 输出 { name: 'John', age: 30 }\n```\n\n在上面的示例中，我们首先创建了一个名为 `originalObj` 的对象，并设置了三个属性：`name`、`age` 和 `city`。然后，我们使用 `Object.assign()` 方法或扩展运算符（`...`）复制 `originalObj` 并将其存储在 `newObj` 或 `anotherObj` 中。接着，我们从 `newObj` 和 `anotherObj` 中分别删除了 `age` 和 `city` 属性。最后，我们分别打印了 `originalObj` 和 `newObj` 或 `anotherObj`，以显示删除属性后的结果。\n\n需要注意的是，这两种方法都只复制了原始对象的浅层副本。如果原始对象包含嵌套的对象或数组，则嵌套对象或数组仍然是通过引用共享的。\n\n\n使用 `filter` 方法来过滤对象属性并创建一个新的对象是不太适用的，因为 `filter` 方法是用于数组的，而不是对象。\n\n如果你想删除 JavaScript 对象的属性，但又不想改变原始对象，并且希望使用其他方法，可以考虑使用解构赋值来创建一个新对象，只包含需要保留的属性。以下是一个示例：\n\n```javascript\nconst originalObj = {\n  name: 'John',\n  age: 30,\n  city: 'New York'\n};\n\nconst { age, ...newObj } = originalObj;\n\nconsole.log(originalObj); // 输出 { name: 'John', age: 30, city: 'New York' }\nconsole.log(newObj); // 输出 { name: 'John', city: 'New York' }\n```\n\n在上面的示例中，我们使用解构赋值语法从 `originalObj` 中提取 `age` 属性，并将其存储在变量 `age` 中。然后，我们使用剩余参数（`...`）来创建一个名为 `newObj` 的新对象，它只包含除了 `age` 以外的其他属性。最后，我们分别打印了 `originalObj` 和 `newObj`，以显示删除属性后的结果。\n\n需要注意的是，这种方法只能用于较新版本的 JavaScript（ES6+）。它通过将需要保留的属性提取到单独的变量中，并使用剩余参数来创建新对象，实现了从原始对象中删除属性的效果。","type":"text/markdown","created":"20231101020044086","creator":"Lenovo","modified":"20231101020134919","modifier":"Lenovo","tags":"JavaScript"},{"title":"remove-old-data-on-mongodb","text":"<img src=\"https://gitlab.com/oeyoews/img/-/raw/main/pictures/2023/03/24/%E6%88%AA%E5%9B%BE%202023-03-24%2023-20-08.png\">","type":"text/markdown","created":"20230324152102603","creator":"oeyoews","modified":"20230324152127029","modifier":"oeyoews","tags":""},{"title":"removeEventListener","text":"`removeEventListener` 用于从元素中移除先前添加的事件监听器。它在以下情况下会被使用：\n\n1. 当您想要停止监听特定事件时：如果您之前使用 `addEventListener` 添加了一个事件监听器，但是后续不再需要监听该事件，可以使用 `removeEventListener` 来移除监听器。这可以防止不必要的事件处理程序执行和内存泄漏。\n\n2. 在使用匿名函数作为事件处理程序时，特别有用：当您通过匿名函数添加事件监听器时，无法直接使用 `removeEventListener` 移除监听器，因为匿名函数是无法被直接引用的。此时，您可以通过将事件处理程序保存到变量中，然后使用该变量来移除监听器。\n\n以下是使用 `removeEventListener` 的示例：\n\n```javascript\nconst element = document.getElementById(\"elementId\");  // 替换 \"elementId\" 为您要移除事件监听器的元素的 ID\n\nfunction handleClick() {\n  console.log(\"点击事件已触发\");\n}\n\n// 添加事件监听器\nelement.addEventListener(\"click\", handleClick);\n\n// 在某个条件满足时移除事件监听器\nif (shouldRemoveListener) {\n  element.removeEventListener(\"click\", handleClick);\n}\n```\n\n在上述示例中，我们首先使用 `addEventListener` 添加了一个名为 `handleClick` 的事件监听器。然后，在某个条件满足时，我们使用 `removeEventListener` 来移除该事件监听器。通过提供相同的事件类型（如 `\"click\"`）和相同的事件处理程序（如 `handleClick` 函数），我们可以确保正确地移除监听器。\n\n需要注意的是，为了成功移除事件监听器，添加和移除监听器的代码必须位于相同的作用域中。此外，请确保使用的事件类型和事件处理程序与添加监听器时的参数完全匹配。\n\n内联事件处理程序具有以下几个好处：\n\n1. 简单直观：使用内联事件处理程序可以将事件处理逻辑直接嵌入到 HTML 元素中，使代码更加简洁和易于理解。你无需在 JavaScript 代码中查找事件监听器的定义，而是直接在相关元素的属性中找到事件处理逻辑。\n\n2. 快速实现：内联事件处理程序可以快速实现基本的事件处理逻辑，特别适用于简单的交互行为。你可以直接在 HTML 元素上编写事件处理函数，无需额外的 JavaScript 代码。\n\n3. 上下文传递：使用内联事件处理程序可以方便地将当前元素的上下文信息传递给事件处理函数。通过在内联事件处理程序中使用 `this` 关键字，你可以轻松访问当前元素的属性和方法，而无需通过其他方式获取元素的引用。\n\n4. 动态生成：内联事件处理程序可以与动态生成的元素结合使用。当你通过 JavaScript 动态创建元素时，你可以直接在元素的属性中设置内联事件处理程序，无需在生成元素后再添加事件监听器。\n\n尽管内联事件处理程序具有这些好处，但它们也有一些限制和潜在的问题。例如，使用内联事件处理程序会导致 HTML 与 JavaScript 代码耦合在一起，不利于代码的维护和复用。此外，当需要在多个元素上共享相同的事件处理逻辑时，内联事件处理程序会导致代码重复。在这种情况下，使用事件监听器和事件委托等技术可能更加灵活和可扩展。\n\n在 JavaScript 中，当你销毁一个节点（例如通过 `removeChild` 方法从 DOM 中移除节点），与该节点相关的事件监听器会如何处理取决于几个因素。\n\n1. 使用 `addEventListener` 添加的事件监听器：如果你使用 `addEventListener` 方法添加了一个事件监听器，并且没有显式地移除它，那么该监听器将仍然存在于内存中，即使你移除了节点。这可能导致内存泄漏，因为该监听器仍然保留着对节点的引用，即使节点已经被移除。\n\n   解决方法：在销毁节点之前，你应该显式地使用 `removeEventListener` 方法来移除事件监听器，以确保它们不再保留对节点的引用。这样可以防止内存泄漏并释放相关资源。\n\n2. 使用内联事件处理程序（Inline Event Handlers）：如果你使用内联事件处理程序（例如 `onclick=\"...\"`）来添加事件处理逻辑，当你移除包含该处理程序的节点时，相关的事件处理逻辑也会自动被移除。这是因为内联事件处理程序是直接附加到节点上的，而不是通过事件监听器的方式。\n\n   解决方法：在销毁节点时，你无需额外处理内联事件处理程序，它们会自动被移除。\n\n总结起来，对于使用 `addEventListener` 添加的事件监听器，你需要在销毁节点之前使用 `removeEventListener` 方法显式地移除它们，以防止内存泄漏。对于使用内联事件处理程序添加的事件处理逻辑，当你移除包含该处理程序的节点时，相关的事件处理逻辑会自动被移除。","type":"text/markdown","created":"20231002164345079","creator":"oeyoews","modified":"20231028000837980","modifier":"Lenovo","tags":"JavaScript"},{"title":"rename-branch-name","text":"* git branch -M [branch-name]","type":"text/markdown","created":"20230402103541799","creator":"oeyoews","modified":"20230402103617661","modifier":"oeyoews","tags":""},{"title":"resolve-promise","text":"`resolve` 不是一个函数，而是 Promise 对象中的一个方法。它是 Promise 的内置方法之一，用于将一个 Promise 标记为已成功（fulfilled），并将一个值传递给与之关联的`.then`方法中的回调函数。\r\n\r\n在 JavaScript 中，Promise 对象有三种状态：待定（pending）、已成功（fulfilled）、已拒绝（rejected）。`resolve`方法用于将一个待定的 Promise 状态转变为已成功的状态，并传递一个值作为成功的结果。\r\n\r\n示例用法如下：\r\n\r\n```javascript\r\nconst myPromise = new Promise((resolve, reject) => {\r\n  // 一些异步操作，最终成功后调用resolve\r\n  setTimeout(() => {\r\n    resolve(\"成功的结果\");\r\n  }, 1000);\r\n});\r\n\r\nmyPromise.then((result) => {\r\n  console.log(result); // 输出：成功的结果\r\n});\r\n```\r\n\r\n在上面的示例中，`resolve`方法被调用，并将字符串\"成功的结果\"传递给了`.then`方法中的回调函数。这样，当 Promise 对象状态变为已成功时，`.then`中的回调函数就会被执行，并且可以访问到成功的结果。\r\n\r\n总之，`resolve`是 Promise 对象的方法，用于标记 Promise 为已成功状态，并传递成功的结果。","type":"text/markdown","created":"20230924062943526","creator":"oeyoews","modified":"20230924063006585","modifier":"oeyoews","tags":"JavaScript ES6"},{"title":"resume-templates","text":"<https://resume.mdnice.com/>","type":"text/markdown","created":"20230407171633687","creator":"oeyoews","modified":"20230407171643463","modifier":"oeyoews","tags":""},{"title":"reveal-icon","text":"<svg stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" role=\"img\" viewBox=\"0 0 24 24\" height=\"1em\" width=\"1em\" xmlns=\"http://www.w3.org/2000/svg\"><title></title><path d=\"M4.271 1.352a.774.774 0 0 0-.787.775v19.761c0 .49.45.857.93.758l6.676-1.382-2.77-.614-3.675.762V2.607l3.101.686 2.777-.574-6.097-1.35a.774.774 0 0 0-.155-.017zm15.315.002L5.145 4.344v15.092l14.43 3.195a.774.774 0 0 0 .94-.758V2.111a.773.773 0 0 0-.93-.757zM2.984 4.79l-2.367.49A.774.774 0 0 0 0 6.04v11.639a.774.774 0 0 0 .607.754l2.377.525V4.791zm18.034.252V6.23l1.822.405v11.011l-1.822.377v1.186l2.365-.49A.774.774 0 0 0 24 17.96V6.322a.774.774 0 0 0-.607-.754l-2.375-.525z\"></path></svg>","type":"text/markdown","created":"20230227021503565","creator":"oeyoews","modified":"20230227021514889","modifier":"oeyoews","tags":""},{"title":"revers-cards-thoughts","text":"如果 ai,可以自动化 tiddler, 自动制卡挺方便的， 比如自己写了一段话， 他会自动提炼出问题，和答案, 全部自动化就很方便了","type":"text/markdown","created":"20231002121807704","creator":"oeyoews","modified":"20231002121941580","modifier":"oeyoews","tags":"thoughts"},{"title":"rmi-docker-images","text":"`docker rmi $(docker images --filter \"dangling=true\")` 删除所有 `<none>` 镜像\r\n\r\n=== \r\n`docker container prune` // should clean container before delete image\r\n`docker image prune`\r\n\r\ndocker tag oeyoews/tiddlywiki \"oeyoews/tiddlywiki:5.3.1\"\r\n\r\ndocker rmi id -f","type":"text/markdown","created":"20230903081518911","creator":"oeyoews","modified":"20230903144517343","modifier":"oeyoews","tags":""},{"title":"rtl-with-web","text":"* RTL 代表从右到左，这是在某些语言（例如阿拉伯语、希伯来语和波斯语）中使用的书写方向。在 RTL 书写系统中，文本是从右到左书写的，这与英语等大多数语言中使用的从左到右的方向相反。\r\n\r\n* 为了在 Web 开发中支持 RTL，CSS 提供了一些可用于更改元素布局的属性。例如，direction 属性可以设置 rtl 为将文本和其他元素的方向更改为从右到左。此外，一些 CSS 框架（如 Bootstrap 和 TailwindCSS）提供对 RTL 布局的内置支持，使创建支持 RTL 语言的网站变得更加容易。","type":"text/markdown","created":"20230324133259939","creator":"oeyoews","modified":"20230324133324931","modifier":"oeyoews","tags":""},{"title":"run-builds-cmds","text":"```plain\r\nnpx tiddlywiki . --build <none>\r\n```\r\n\r\nto run all cmd","type":"text/markdown","created":"20230713161639528","creator":"oeyoews","modified":"20230726045248768","modifier":"oeyoews","tags":"TiddlyWiki"},{"title":"rv-diff","text":"Ng 像 Windows.哲学是,我默认用户是小白,我给他提供最好的.\r\n\r\nVue 像 Mac.哲学是,我默认用户是有特定需求(比如写代码)的,为此我不惜抛弃一些不用的东西(比如打游戏)你要打游戏也能打,但是体验会很差.\r\n\r\nReact 是 Unix.哲学是,我默认用户都是有经验的开发者,他们很清楚他们的写的是什么并且有会有什么样的结果,并为此结果负责.\r\n\r\n这不是错觉，学 vue 像练了一套罗汉拳，然后师傅说，你可以出门闯荡了。学 react 的话，是师傅塞了一把砍刀给你，告诉你说，就这一招，看谁不顺眼直接砍就行...\r\n\r\nvue 的语法决定了，不同的人写在同一个项目里的代码，不会有很大差别。而在一个维护时长超过一个年的 react 项目中，你能见识到前端发展史...\r\n\r\n---\r\nNG 是指 Angular 框架，是一个由 Google 开发的 JavaScript 前端框架，用于构建 Web 应用程序。它采用了 MVC 架构模式和数据双向绑定技术，可以方便地开发大规模、高性能的 Web 应用程序。","type":"text/markdown","created":"20230428081848524","creator":"oeyoews","modified":"20230428082458066","modifier":"oeyoews","tags":"React Vue"},{"title":"safari-shit","text":"safari 总是会有很多奇怪的问题, 样式兼容是最大的问题, 明明在模拟器里面很正常, 真机就出幺蛾子(:cry:)\r\n\r\n> 关键是还不知道怎么调试真机, 放弃了移动端了","type":"text/markdown","created":"20230930043333799","creator":"oeyoews","modified":"20230930043616280","modifier":"oeyoews","tags":"Plugins TiddlyWiki safari"},{"title":"screenity","text":"<https://github.com/alyssaxuu/screenity>","type":"text/markdown","created":"20230416020538863","creator":"oeyoews","modified":"20230423053122278","modifier":"oeyoews","tags":"App"},{"title":"scroll-view","text":"<div class=\"h-screen overflow-y-auto shadow border border-gray-300 border-2 rounded\">\n    <p class=\"p-4\">\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec tincidunt finibus mauris, nec tristique elit condimentum at. Integer facilisis sem at metus convallis, ac tincidunt nunc posuere. Donec volutpat sapien in lectus euismod, non semper turpis fermentum. Sed faucibus consectetur augue, ut interdum tortor convallis sed. Nulla facilisi. Fusce cursus nisl non dapibus pretium. Vestibulum eleifend vehicula mauris, sed varius turpis venenatis id. Fusce in maximus arcu, a hendrerit dolor. Nullam at nulla at dolor cursus pellentesque. Sed rhoncus, ipsum sit amet convallis efficitur, arcu ex lacinia velit, eu ultrices libero elit nec odio. Maecenas auctor faucibus pharetra. Vestibulum sed enim lorem. Integer ultrices nisl at finibus fringilla. Nunc mattis urna ac turpis venenatis, ut fringilla sem volutpat.\n    </p>\n  </div>","type":"text/markdown","created":"20230615093818784","creator":"oeyoews","modified":"20231018055203604","modifier":"Lenovo","tags":"Tailwindcss"},{"title":"sdk","text":"software development kit","type":"text/markdown","created":"20230326150022283","creator":"oeyoews","modified":"20230326150038805","modifier":"oeyoews","tags":""},{"title":"search-fast-with-gpt","text":"* <https://manateelazycat.github.io/think/2023/02/14/chatgpt.html>","type":"text/markdown","created":"20230318091953844","creator":"oeyoews","modified":"20230318092011449","modifier":"oeyoews","tags":""},{"title":"search-on-tw","text":"`$tw.wiki.search` 负责搜索文本, 最后会返回一个 array 或者 string\r\n\r\n```js\r\nexports.search = function(text,options) {\r\n\toptions = options || {};\r\n\tvar self = this,\r\n\t\tt,\r\n\t\tregExpStr=\"\",\r\n\t\tinvert = !!options.invert;\r\n\t// Convert the search string into a regexp for each term\r\n\tvar terms, searchTermsRegExps,\r\n\t\tflags = options.caseSensitive ? \"\" : \"i\",\r\n\t\tanchor = options.anchored ? \"^\" : \"\";\r\n\tif(options.literal) {\r\n\t\tif(text.length === 0) {\r\n\t\t\tsearchTermsRegExps = null;\r\n\t\t} else {\r\n\t\t\tsearchTermsRegExps = [new RegExp(\"(\" + anchor + $tw.utils.escapeRegExp(text) + \")\",flags)];\r\n\t\t}\r\n\t} else if(options.whitespace) {\r\n\t\tterms = [];\r\n\t\t$tw.utils.each(text.split(/\\s+/g),function(term) {\r\n\t\t\tif(term) {\r\n\t\t\t\tterms.push($tw.utils.escapeRegExp(term));\r\n\t\t\t}\r\n\t\t});\r\n\t\tsearchTermsRegExps = [new RegExp(\"(\" + anchor + terms.join(\"\\\\s+\") + \")\",flags)];\r\n\t} else if(options.regexp) {\r\n\t\ttry {\r\n\t\t\tsearchTermsRegExps = [new RegExp(\"(\" + text + \")\",flags)];\r\n\t\t} catch(e) {\r\n\t\t\tsearchTermsRegExps = null;\r\n\t\t\tconsole.log(\"Regexp error parsing /(\" + text + \")/\" + flags + \": \",e);\r\n\t\t}\r\n\t} else if(options.some) {\r\n\t\tterms = text.trim().split(/ +/);\r\n\t\tif(terms.length === 1 && terms[0] === \"\") {\r\n\t\t\tsearchTermsRegExps = null;\r\n\t\t} else {\r\n\t\t\tsearchTermsRegExps = [];\r\n\t\t\tfor(t=0; t<terms.length; t++) {\r\n\t\t\t\tregExpStr += (t===0) ? anchor + $tw.utils.escapeRegExp(terms[t]) : \"|\" + anchor + $tw.utils.escapeRegExp(terms[t]);\r\n\t\t\t}\r\n\t\t\tsearchTermsRegExps.push(new RegExp(\"(\" + regExpStr + \")\",flags));\r\n\t\t}\r\n\t} else { // default: words\r\n\t\tterms = text.split(/ +/);\r\n\t\tif(terms.length === 1 && terms[0] === \"\") {\r\n\t\t\tsearchTermsRegExps = null;\r\n\t\t} else {\r\n\t\t\tsearchTermsRegExps = [];\r\n\t\t\tfor(t=0; t<terms.length; t++) {\r\n\t\t\t\tsearchTermsRegExps.push(new RegExp(\"(\" + anchor + $tw.utils.escapeRegExp(terms[t]) + \")\",flags));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n// Accumulate the array of fields to be searched or excluded from the search\r\n\tvar fields = [];\r\n\tif(options.field) {\r\n\t\tif($tw.utils.isArray(options.field)) {\r\n\t\t\t$tw.utils.each(options.field,function(fieldName) {\r\n\t\t\t\tif(fieldName) {\r\n\t\t\t\t\tfields.push(fieldName);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tfields.push(options.field);\r\n\t\t}\r\n\t}\r\n\t// Use default fields if none specified and we're not excluding fields (excluding fields with an empty field array is the same as searching all fields)\r\n\tif(fields.length === 0 && !options.excludeField) {\r\n\t\tfields.push(\"title\");\r\n\t\tfields.push(\"tags\");\r\n\t\tfields.push(\"text\");\r\n\t}\r\n\t// Function to check a given tiddler for the search term\r\n\tvar searchTiddler = function(title) {\r\n\t\tif(!searchTermsRegExps) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tvar notYetFound = searchTermsRegExps.slice();\r\n\r\n\t\tvar tiddler = self.getTiddler(title);\r\n\t\tif(!tiddler) {\r\n\t\t\ttiddler = new $tw.Tiddler({title: title, text: \"\", type: \"text/vnd.tiddlywiki\"});\r\n\t\t}\r\n\t\tvar contentTypeInfo = $tw.config.contentTypeInfo[tiddler.fields.type] || $tw.config.contentTypeInfo[\"text/vnd.tiddlywiki\"],\r\n\t\t\tsearchFields;\r\n\t\t// Get the list of fields we're searching\r\n\t\tif(options.excludeField) {\r\n\t\t\tsearchFields = Object.keys(tiddler.fields);\r\n\t\t\t$tw.utils.each(fields,function(fieldName) {\r\n\t\t\t\tvar p = searchFields.indexOf(fieldName);\r\n\t\t\t\tif(p !== -1) {\r\n\t\t\t\t\tsearchFields.splice(p,1);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tsearchFields = fields;\r\n\t\t}\r\n\t\tfor(var fieldIndex=0; notYetFound.length>0 && fieldIndex<searchFields.length; fieldIndex++) {\r\n\t\t\t// Don't search the text field if the content type is binary\r\n\t\t\tvar fieldName = searchFields[fieldIndex];\r\n\t\t\tif(fieldName === \"text\" && contentTypeInfo.encoding !== \"utf8\") {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tvar str = tiddler.fields[fieldName],\r\n\t\t\t\tt;\r\n\t\t\tif(str) {\r\n\t\t\t\tif($tw.utils.isArray(str)) {\r\n\t\t\t\t\t// If the field value is an array, test each regexp against each field array entry and fail if each regexp doesn't match at least one field array entry\r\n\t\t\t\t\tfor(var s=0; s<str.length; s++) {\r\n\t\t\t\t\t\tfor(t=0; t<notYetFound.length;) {\r\n\t\t\t\t\t\t\tif(notYetFound[t].test(str[s])) {\r\n\t\t\t\t\t\t\t\tnotYetFound.splice(t, 1);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tt++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// If the field isn't an array, force it to a string and test each regexp against it and fail if any do not match\r\n\t\t\t\t\tstr = tiddler.getFieldString(fieldName);\r\n\t\t\t\t\tfor(t=0; t<notYetFound.length;) {\r\n\t\t\t\t\t\tif(notYetFound[t].test(str)) {\r\n\t\t\t\t\t\t\tnotYetFound.splice(t, 1);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tt++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn notYetFound.length == 0;\r\n\t};\r\n\t// Loop through all the tiddlers doing the search\r\n\tvar results = [],\r\n\t\tsource = options.source || this.each;\r\n\tsource(function(tiddler,title) {\r\n\t\tif(searchTiddler(title) !== invert) {\r\n\t\t\tresults.push(title);\r\n\t\t}\r\n\t});\r\n\t// Remove any of the results we have to exclude\r\n\tif(options.exclude) {\r\n\t\tfor(t=0; t<options.exclude.length; t++) {\r\n\t\t\tvar p = results.indexOf(options.exclude[t]);\r\n\t\t\tif(p !== -1) {\r\n\t\t\t\tresults.splice(p,1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn results;\r\n};\r\n```","type":"text/markdown","created":"20230929074144075","creator":"oeyoews","modified":"20230929074559370","modifier":"oeyoews","tags":"Plugins"},{"title":"searchbar","text":"```html \r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n    <title>Index 18</title>\r\n    <script src=\"https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio\"></script>\r\n    <script>\r\n      tailwind.config = { corePlugins: { preflight: true } };\r\n    </script>\r\n  </head>\r\n  <body>\r\n    <form class=\"fixed left-1/2 -translate-x-1/2 bottom-4 w-2/5 border rounded\">\r\n      <textarea\r\n        row=\"1\"\r\n        type=\"text\"\r\n        overflow=\"hidden\"\r\n        placeholder=\"search\"\r\n        name=\"name\"\r\n        class=\"w-full border-none rounded resize-none bg-transparent focus:ring-0\"\r\n        style=\"overflow-y: hidden; height: 50px; max-height: 200px\"\r\n      ></textarea>\r\n    </form>\r\n\r\n    <form\r\n      class=\"stretch mx-2 flex flex-row gap-3 last:mb-2 md:mx-4 md:last:mb-6 lg:mx-auto lg:max-w-2xl xl:max-w-3xl fixed top-1/2 left-1/2 -translate-x-1/2 w-2/5 -translate-y-1/2\"\r\n    >\r\n      <div\r\n        class=\"relative flex h-full flex-1 items-stretch md:flex-col\"\r\n        role=\"presentation\"\r\n      >\r\n        <div\r\n          class=\"flex flex-col w-full py-[10px] flex-grow md:py-4 md:pl-4 relative border border-black/10 bg-white dark:border-gray-900/50 dark:text-white dark:bg-gray-700 rounded shadow-xs dark:shadow-xs\"\r\n        >\r\n          <textarea\r\n            id=\"prompt-textarea\"\r\n            tabindex=\"0\"\r\n            data-id=\"root\"\r\n            rows=\"1\"\r\n            placeholder=\"Send a message\"\r\n            class=\"m-0 w-full resize-none border-0 bg-transparent p-0 pr-10 focus:ring-0 focus-visible:ring-0 dark:bg-transparent md:pr-12 pl-3 md:pl-0\"\r\n            style=\"max-height: 200px; height: 30px; overflow-y: hidden\"\r\n          ></textarea>\r\n        </div>\r\n        <div>\r\n          <div\r\n            class=\"h-full flex ml-1 md:w-full md:m-auto md:mb-4 gap-0 md:gap-2 justify-center\"\r\n          >\r\n            <div class=\"grow\"></div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </form>\r\n  </body>\r\n</html>\r\n```","type":"text/markdown","created":"20230805105358168","creator":"oeyoews","modified":"20230805105433299","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"self-chat","text":"<https://sspai.com/post/79230>","type":"text/markdown","created":"20230420131318773","creator":"oeyoews","modified":"20230420131327500","modifier":"oeyoews","tags":""},{"title":"sessionStorage","text":"sessionStorage 是会话存储，只能在同一个浏览器窗口（或者标签页）中共享数据，在浏览器窗口关闭时，存储在 sessionStorage 中的数据也会被清除。\r\n\r\n而 localStorage 是本地存储，可以在不同浏览器窗口（或者标签页）之间共享数据，并且即使关闭了浏览器窗口，存储在 localStorage 中的数据仍然存在。\r\n\r\n因此，如果您希望在刷新浏览器后仍然保留数据，应该使用 localStorage 而不是 sessionStorage。\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <title>Session Demo</title>\r\n  </head>\r\n  <body>\r\n    <h1>Session Demo</h1>\r\n\r\n    <!-- 用户输入名字和年龄 -->\r\n    <label for=\"name\">Name:</label>\r\n    <input type=\"text\" id=\"name\" /><br /><br />\r\n\r\n    <label for=\"age\">Age:</label>\r\n    <input type=\"number\" id=\"age\" /><br /><br />\r\n\r\n    <!-- 保存按钮 -->\r\n    <button onclick=\"saveData()\">Save</button>\r\n\r\n    <!-- 显示已保存的数据 -->\r\n    <h2>Saved Data:</h2>\r\n    <p id=\"saved-data\"></p>\r\n\r\n    <!-- 清除按钮 -->\r\n    <button onclick=\"clearData()\">Clear</button>\r\n\r\n    <script>\r\n      function saveData() {\r\n        // 获取用户输入的数据并保存到sessionStorage中\r\n        const name = document.getElementById(\"name\").value;\r\n        const age = document.getElementById(\"age\").value;\r\n\r\n        sessionStorage.setItem(\"name\", name);\r\n        sessionStorage.setItem(\"age\", age);\r\n\r\n        // 更新显示已保存的数据\r\n        updateSavedData();\r\n      }\r\n\r\n      function clearData() {\r\n        // 清除sessionStorage中的数据\r\n        sessionStorage.removeItem(\"name\");\r\n        sessionStorage.removeItem(\"age\");\r\n\r\n        // 更新显示已保存的数据\r\n        updateSavedData();\r\n      }\r\n\r\n      function updateSavedData() {\r\n        // 从sessionStorage中获取已保存的数据并更新页面上的文本内容\r\n        const name = sessionStorage.getItem(\"name\");\r\n        const age = sessionStorage.getItem(\"age\");\r\n\r\n        let savedDataText = \"\";\r\n\r\n        if (name) {\r\n          savedDataText += \"Name: \" + name + \"<br>\";\r\n        }\r\n\r\n        if (age) {\r\n          savedDataText += \"Age: \" + age + \"<br>\";\r\n        }\r\n\r\n        document.getElementById(\"saved-data\").innerHTML = savedDataText;\r\n      }\r\n\r\n      // 页面加载时更新已保存的数据\r\n      updateSavedData();\r\n    </script>\r\n  </body>\r\n</html>\r\n```","type":"text/markdown","created":"20230507093356341","creator":"oeyoews","modified":"20230507093435262","modifier":"oeyoews","tags":"JavaScript"},{"title":"set-state","text":"在 JavaScript 中，语法 setState(prevState => [...prevState, name]) 用于通过将新元素添加到数组末尾来更新数组状态。\r\n\r\n具体来说，setState 是由 React 的 useState hook 提供的函数，它允许您更新组件的状态。您传入一个新的状态值，React 将自动使用更新后的状态重新渲染组件。\r\n\r\nsetState 的参数是一个函数，它以先前的状态为参数并返回新状态。在这种情况下，(prevState => [...prevState, name]) 是一个函数，它将先前的状态（一个数组）展开到一个新数组中，然后使用展开运算符将新的 name 值添加到数组末尾。\r\n\r\n因此，当此函数传递给 setState 时，它将通过将 name 添加到数组末尾来更新数组状态。然后使用更新后的状态重新渲染组件。\r\n\r\n[ref](https://www.bilibili.com/video/BV1Ze4y1u792/?spm_id_from=333.337.search-card.all.click&vd_source=d6afd7eedd9f9c940321c63f0a1539e3)","type":"text/markdown","created":"20230429010925509","creator":"oeyoews","modified":"20230726045248770","modifier":"oeyoews","tags":"React"},{"title":"setInterval","text":"在使用 setInterval 时，需要注意在组件卸载时清除计时器。否则，计时器将继续运行，即使组件已经卸载，这可能导致内存泄漏和性能问题。\r\n\r\n因此，在使用 setInterval 时，通常需要在 useEffect hook 的清除函数中调用 clearInterval 来清除计时器。这样可以确保在组件卸载时清除计时器，避免内存泄漏和性能问题。\r\n\r\n```jsx\r\nuseEffect(() => {\r\n    const testInterval = setInterval(() => {\r\n      setNumber((pre) => pre + 1);\r\n    }, 1000);\r\n    return () => {\r\n      clearInterval(testInterval);\r\n    };\r\n  }, []);\r\n```\r\n\r\n在使用 setInterval 创建定时器时，它会返回一个唯一的 ID，以便您可以在以后使用 clearInterval 函数来清除该定时器。如果您不指定定时器 ID，那么 clearInterval 函数将不知道要清除哪个定时器，因为它无法识别它们。\r\n\r\n如果您有多个定时器在运行，而没有指定它们的 ID，那么 clearInterval 函数将清除最后创建的那个定时器。这可能会导致您意外地清除了错误的定时器，导致不必要的错误和行为不一致。\r\n\r\n因此，为了确保您能够正确地清除定时器，您应该始终将定时器 ID 传递给 clearInterval 函数。在 React 中，通常在 useEffect hook 的清除函数中使用 clearInterval 函数来清除定时器，并将定时器 ID 存储在组件的状态或 ref 中。这样可以确保在组件卸载时清除定时器，并且可以处理多个定时器的情况。","type":"text/markdown","created":"20230429014305584","creator":"oeyoews","modified":"20230429014523487","modifier":"oeyoews","tags":"React"},{"title":"seveal-framworks","text":"* astro\r\n* gastby\r\n* remix\r\n* nextjs\r\n* vite","type":"text/markdown","created":"20230405162037049","creator":"oeyoews","modified":"20230405162106039","modifier":"oeyoews","tags":""},{"title":"sevenday","text":"<div class=\"my-8\">\n<div class=\"dark:hidden\">\n<$echarts $tiddler=\"addon/sevenday.js\" $theme='light' days=31 title=\"最近文章数量\"/>\n</div>\n\n<div class=\"hidden dark:inline\">\n<$echarts $tiddler=\"addon/sevenday.js\" $theme='dark' days=21/>\n</div>\n</div>","type":"text/markdown","created":"20231010122137962","creator":"Lenovo","modified":"20231018034823098","modifier":"Lenovo","tags":""},{"title":"several-render-method","text":"* bsr\r\n* csr\r\n* ssr\r\n* ssg","type":"text/markdown","created":"20230406031231249","creator":"oeyoews","modified":"20230406031250919","modifier":"oeyoews","tags":""},{"title":"shadow-tiddlers","text":"影子条目(shaodw) 是来自插件加载的条目, 如果用户修改就变成了普通条目; 不要和系统条目混淆","type":"text/markdown","created":"20230907104707389","creator":"oeyoews","modified":"20230907104842738","modifier":"oeyoews","tags":""},{"title":"shared-data","text":"在同源页面中，可以使用`window.postMessage()`方法实现数据共享。`postMessage()`方法允许将消息发送到另一个窗口或跨窗口的 iframe 中。\r\n\r\n以下是一些基本步骤来实现同源页面之间的数据共享：\r\n\r\n1. 在一个页面中使用`window.postMessage()`方法发送消息给另一个页面。\r\n2. 在另一个页面中使用`window.addEventListener()`方法监听`message`事件。\r\n3. 当`message`事件被触发时，使用`event.source.postMessage()`方法向原始页面发送响应数据。\r\n\r\n下面是一个简单示例，演示如何在两个同源页面之间共享数据：\r\n\r\n在源页面中：\r\n\r\n```plain\r\n// 源页面\r\nconst targetWindow = window.parent; // 获取目标窗口对象\r\ntargetWindow.postMessage('hello', 'http://localhost:8080'); // 向目标窗口发送消息\r\n```\r\n\r\n在目标页面中：\r\n\r\n```plain\r\n// 目标页面\r\nwindow.addEventListener('message', function(event) {\r\n  if (event.origin === 'http://localhost:8080') { // 确认消息来源\r\n    console.log('收到来自源页面的消息:', event.data);\r\n    event.source.postMessage('world', event.origin); // 向源页面发送响应消息\r\n  }\r\n});\r\n```\r\n\r\n在这个示例中，源页面向目标窗口发送了一个消息`hello`，并指定消息需要发送到`http://localhost:8080`。当目标页面接收到来自源页面的消息时，它会打印出消息内容，并向源页面发送响应消息`world`。\r\n\r\n需要注意的是，也同样需要在接收页面中进行安全检查，以确保消息来自预期的来源，并防止 XSS 攻击等风险。此外，在使用`postMessage()`方法时，还需要谨慎处理消息内容，避免不良用户通过此方式传递恶意代码。","type":"text/markdown","created":"20231002060651907","creator":"oeyoews","modified":"20231002060716791","modifier":"oeyoews","tags":"JavaScript"},{"title":"shared-storage","text":"Shared storage and local storage are both mechanisms that allow web applications to store data locally in a user's browser, but they have some differences.\r\n\r\n- **Local Storage**: This is a client-side storage that allows web applications to store data in the form of key-value pairs. This data is stored persistently on the user's browser and can be accessed even after the user closes the browser window. Local storage is limited to the domain from which it was created, and any web page on that domain can access it. The maximum size of local storage is typically around 5-10 MB.\r\n\r\n- **Shared Storage**: Shared storage is a new feature that allows web applications to share data between different windows or tabs that belong to the same origin. This means that if a user has multiple windows or tabs open for a particular website, the data stored in shared storage can be accessed by all of them. Shared storage has a larger storage capacity than local storage and can store up to 2GB of data.\r\n\r\nIn summary, local storage is limited to a single browser window or tab and has a smaller storage capacity, while shared storage allows web applications to share data between different windows or tabs and has a larger storage capacity.\r\n\r\nTo use shared storage in a web application, you can follow these general steps:\r\n\r\n1. Create a new `SharedStorage` object using the `SharedStorage()` constructor:\r\n```javascript\r\nconst sharedStorage = new SharedStorage();\r\n```\r\n\r\n2. Use the `setItem()` method to store data in shared storage:\r\n```javascript\r\nsharedStorage.setItem('key', 'value');\r\n```\r\n\r\n3. Use the `getItem()` method to retrieve data from shared storage:\r\n```javascript\r\nconst value = sharedStorage.getItem('key');\r\n```\r\n\r\n4. Use the `removeItem()` method to remove an item from shared storage:\r\n```javascript\r\nsharedStorage.removeItem('key');\r\n```\r\n\r\nYou can also listen for changes to shared storage using the `addEventListener()` method:\r\n```javascript\r\nsharedStorage.addEventListener('storage', (event) => {\r\n  // Handle storage change event\r\n});\r\n```\r\n\r\nKeep in mind that shared storage is only available to web pages that belong to the same origin (i.e., have the same protocol, domain, and port). Also, like local storage, shared storage is not secure and should not be used to store sensitive data.","type":"text/markdown","created":"20230415013139714","creator":"oeyoews","modified":"20230726045248771","modifier":"oeyoews"},{"title":"shields.io-not-support-online-image","text":"<https://github.com/badges/shields/issues/8843>","type":"text/markdown","created":"20230325084344398","creator":"oeyoews","modified":"20230325084405173","modifier":"oeyoews","tags":""},{"title":"show-articles","text":"<$set name=\"a-count\" value={{{ [$:/temp/articles/number]get[number](#%24%3A/temp/articles/number%5Dget%5Bnumber) }}}>\r\n{{{ [!is[system]field:publish[article]!sort[modified]limit<a-count>] -[GettingStarted](#GettingStarted)||$:/core/ui/ViewTemplate}}}\r\n</$set>","type":"text/markdown","created":"20230320111601537","creator":"oeyoews","modified":"20230320111609296","modifier":"oeyoews","tags":""},{"title":"show-loglevel","text":"1. remove quiet\r\n2. add i8042.dumbkbd\r\n3. timeout-style -> menu \r\n4. loglevel=3\r\n\r\n```grub\r\n# GRUB boot loader configuration\r\n\r\nGRUB_DEFAULT=saved\r\nGRUB_TIMEOUT=5\r\nGRUB_DISTRIBUTOR=\"Manjaro\"\r\nGRUB_CMDLINE_LINUX_DEFAULT=\"splash loglevel=3 udev.log_priority=3 i8042.dumbkbd\"\r\nGRUB_CMDLINE_LINUX=\"\"\r\n\r\n# Preload both GPT and MBR modules so that they are not missed\r\nGRUB_PRELOAD_MODULES=\"part_gpt part_msdos\"\r\n\r\n# Uncomment to enable booting from LUKS encrypted devices\r\n#GRUB_ENABLE_CRYPTODISK=y\r\n\r\n# Set to 'countdown' or 'menu' to change timeout behavior,\r\n# press ESC key to display menu.\r\nGRUB_TIMEOUT_STYLE=menu\r\n\r\n# Uncomment to use basic console\r\nGRUB_TERMINAL_INPUT=console\r\n\r\n# Uncomment to disable graphical terminal\r\n#GRUB_TERMINAL_OUTPUT=console\r\n\r\n# The resolution used on graphical terminal\r\n# note that you can use only modes which your graphic card supports via VBE\r\n# you can see them in real GRUB with the command 'videoinfo'\r\nGRUB_GFXMODE=auto\r\n\r\n# Uncomment to allow the kernel use the same resolution used by grub\r\nGRUB_GFXPAYLOAD_LINUX=keep\r\n\r\n# Uncomment if you want GRUB to pass to the Linux kernel the old parameter\r\n# format \"root=/dev/xxx\" instead of \"root=/dev/disk/by-uuid/xxx\"\r\n#GRUB_DISABLE_LINUX_UUID=true\r\n\r\n# Uncomment to disable generation of recovery mode menu entries\r\nGRUB_DISABLE_RECOVERY=true\r\n\r\n# Uncomment and set to the desired menu colors.  Used by normal and wallpaper\r\n# modes only.  Entries specified as foreground/background.\r\nGRUB_COLOR_NORMAL=\"light-gray/black\"\r\nGRUB_COLOR_HIGHLIGHT=\"green/black\"\r\n\r\n# Uncomment one of them for the gfx desired, a image background or a gfxtheme\r\n#GRUB_BACKGROUND=\"/usr/share/grub/background.png\"\r\nGRUB_THEME=\"/usr/share/grub/themes/manjaro/theme.txt\"\r\n\r\n# Uncomment to get a beep at GRUB start\r\n#GRUB_INIT_TUNE=\"480 440 1\"\r\n\r\n# Uncomment to make GRUB remember the last selection. This requires\r\n# setting 'GRUB_DEFAULT=saved' above.\r\nGRUB_SAVEDEFAULT=true\r\n\r\n# Uncomment to disable submenus in boot menu\r\n#GRUB_DISABLE_SUBMENU=y\r\n\r\n# Uncomment this option to enable os-prober execution in the grub-mkconfig command\r\nGRUB_DISABLE_OS_PROBER=false\r\n\r\n# Uncomment to ensure that the root filesystem is mounted read-only so that\r\n# systemd-fsck can run the check automatically. We use 'fsck' by default, which\r\n# needs 'rw' as boot parameter, to avoid delay in boot-time. 'fsck' needs to be\r\n# removed from 'mkinitcpio.conf' to make 'systemd-fsck' work.\r\n# See also Arch-Wiki: https://wiki.archlinux.org/index.php/Fsck#Boot_time_checking\r\n#GRUB_ROOT_FS_RO=true\r\n```","type":"text/markdown","created":"20231002144052570","creator":"oeyoews","modified":"20231002144159618","modifier":"oeyoews","tags":"gnome"},{"title":"show-your-mirror-branch","text":"* <https://wiki.manjaro.org/index.php/Switching_Branches/zh-cn>","type":"text/markdown","created":"20230327173058174","creator":"oeyoews","modified":"20230327173112839","modifier":"oeyoews","tags":""},{"title":"simple-encrypt-tiddlywiki-file","text":"if use --password on tiddlywiki, this file will be more larger, about more 2M, so if you just want to add password on open website simple, not encrypt all website(note: if your html download, this content will be check by editor to open this html file)","type":"text/markdown","created":"20230410125509639","creator":"oeyoews","modified":"20230410125734831","modifier":"oeyoews","tags":""},{"title":"simple-tiddlywiki-plugin-widget.js","text":"```javascript\r\n/*\\\r\ntitle: $:/plugins/oeyoews/simple-plugin.js\r\ntype: application/javascript\r\nmodule-type: widget\r\n\r\nJust a simple plugin\r\n\\*/\r\n\r\n/**\r\n * 上面的注释会被tiddlywiki读取, 删除上面的注释真的会影响代码运行, 当然也可以使用meta文件代替, 暂时不谈, 如果复制整个文件的代码到tiddlywiki里面还需要添加 module-type字段为 widget 和type字段为 application/json\r\n *\r\n * 简单的widget 一般是对dom的操作, 如果代码很长, 也可以分成能够多个文件, 最后使用require进行加载\r\n *\r\n */\r\n\r\n/**\r\n * 在Tiddlywiki里面, widget一般使用IFEE结构, tiddlywiki核心目前为了兼容性使用es5, 5.3.0以后准备引入es8 其实对于第三方插件来说, 也可以使用es6以后的语法, 不使用IFEE结构, 直接写代码, 比如下面的Class\r\n */\r\n(function () {\r\n  /*jslint node: true, browser: true */\r\n  /*global $tw: false */\r\n  'use strict';\r\n\r\n  const Widget = require('$:/core/modules/widgets/widget.js').widget;\r\n\r\n  class SimpleWidget extends Widget {\r\n    constructor(parseTreeNode, options) {\r\n      super(parseTreeNode, options);\r\n    }\r\n\r\n    // render 函数在被调用的时候只执行一次, 也可以看作main入口函数\r\n    // Widget 类有很多函数, 如refresh, destory, 当然也可以自定义函数\r\n    render(parent, nextSibling) {\r\n      // 判断当前环境, 如果不是浏览器,则不渲染, 否则渲染, 建议加上\r\n      if (!$tw.browser) return;\r\n\r\n      // 固定模板, 不建议修改\r\n      this.parentDomNode = parent;\r\n      this.computeAttributes();\r\n      this.execute();\r\n\r\n      // <$simple text=\"xxx\" />\r\n      const text = this.getAttribute('text', 'Button');\r\n\r\n      /**\r\n       * 传统的js创建节点, 下面两种方法都可以\r\n       */\r\n      const anotherButtonNode = document.createElement('button');\r\n      anotherButtonNode.textContent = 'anotherButtonNode';\r\n\r\n      const buttonNode = $tw.utils.domMaker('button', {\r\n        text: text,\r\n        // 节点class\r\n        class: 'btn',\r\n        // 节点属性\r\n        attributes: {},\r\n        // 子节点\r\n        children: [anotherButtonNode],\r\n        // ...\r\n      });\r\n\r\n      // 绑定点击事件\r\n      buttonNode.addEventListener('click', this.handlerClick);\r\n\r\n      // 插入 buttonNode 节点\r\n      parent.insertBefore(buttonNode, nextSibling);\r\n      // 便于tw 更新管理节点\r\n      this.domNodes.push(buttonNode);\r\n    }\r\n\r\n    // 自定义函数\r\n    handlerClick = () => {\r\n      alert('button clicked');\r\n    };\r\n  }\r\n\r\n  // widget(又称微件) 导出, tiddlywiki 会自动加载\r\n  // 使用示例 <$simple text=\"xxx\" />\r\n  exports['simple'] = SimpleWidget;\r\n})();\r\n```","type":"text/markdown","created":"20230621154224021","creator":"oeyoews","modified":"20230726045248773","modifier":"oeyoews","tags":"Plugins"},{"title":"skeleton-loading","text":"\\import [$:/core/ui/PageMacros](#%24%3A/core/ui/PageMacros) [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]]\r\n\\rules only filteredtranscludeinline transcludeinline macrocallinline\r\n<div class=\"tc-remove-when-wiki-loaded\">\r\n\r\n<center>\r\n  <div class=\"h-screen p-4 bg-white rounded shadow-md skeleton w-1/2\">\r\n    <div class=\"animate-pulse flex space-x-4\">\r\n      <div class=\"flex-1 py-1\">\r\n        <div class=\"w-3/4 h-4 bg-gray-300 rounded\"></div>\r\n        <div class=\"mt-2 w-5/6 h-3 bg-gray-300 rounded\"></div>\r\n        <div class=\"mt-2 w-3/4 h-4 bg-gray-300 rounded\"></div>\r\n      </div>\r\n    </div>\r\n    <div class=\"animate-pulse flex space-x-4\">\r\n      <div class=\"flex-1 py-1\">\r\n        <div class=\"w-3/4 h-4 bg-gray-300 rounded\"></div>\r\n        <div class=\"mt-2 w-5/6 h-3 bg-gray-300 rounded\"></div>\r\n        <div class=\"mt-2 w-3/4 h-4 bg-gray-300 rounded\"></div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</center>\r\n\r\n<style scoped>\r\n  .w-1\\/2 {\r\n    width: 50%;\r\n  }\r\n  .h-screen {\r\n    height: 100vh !important;\r\n  }\r\n  .p-4 {\r\n    padding: 1rem;\r\n  }\r\n\r\n  .bg-white {\r\n    background-color: #fff;\r\n  }\r\n\r\n  .rounded {\r\n    border-radius: 0.25rem;\r\n  }\r\n\r\n  .shadow-md {\r\n    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),\r\n      0 2px 4px -1px rgba(0, 0, 0, 0.06);\r\n  }\r\n\r\n  .skeleton {\r\n    background-color: #f2f2f2;\r\n  }\r\n\r\n  .animate-pulse {\r\n    animation-duration: 1s;\r\n    animation-fill-mode: both;\r\n    animation-iteration-count: infinite;\r\n    animation-name: pulse;\r\n    animation-timing-function: ease-in-out;\r\n  }\r\n\r\n  .flex {\r\n    display: flex;\r\n  }\r\n\r\n  .space-x-4 {\r\n    margin-right: 1rem;\r\n  }\r\n\r\n  .flex-1 {\r\n    flex: 1;\r\n  }\r\n\r\n  .py-1 {\r\n    padding-top: 0.25rem;\r\n    padding-bottom: 0.25rem;\r\n  }\r\n\r\n  .w-3\\/4 {\r\n    width: 75%;\r\n  }\r\n\r\n  .h-4 {\r\n    height: 1rem;\r\n  }\r\n\r\n  .bg-gray-300 {\r\n    background-color: #e2e8f0;\r\n  }\r\n\r\n  .rounded {\r\n    border-radius: 0.25rem;\r\n  }\r\n\r\n  .mt-2 {\r\n    margin-top: 0.5rem;\r\n  }\r\n\r\n  .w-5\\/6 {\r\n    width: 83.333333%;\r\n  }\r\n\r\n  .h-3 {\r\n    height: 0.75rem;\r\n  }\r\n\r\n  @keyframes pulse {\r\n    0% {\r\n      opacity: 1;\r\n    }\r\n    50% {\r\n      opacity: 0.5;\r\n    }\r\n    100% {\r\n      opacity: 1;\r\n    }\r\n  }\r\n</style>\r\n\r\n</div>","type":"text/markdown","created":"20230513020359350","creator":"oeyoews","modified":"20230513031325008","modifier":"oeyoews","tags":""},{"title":"sleep-promise","text":"```js\n/**\n * description: 请你编写一个异步函数，它接收一个正整数参数 millis ，并休眠这么多毫秒。要求此函数可以解析任何值。 \n * order: 2621\n * type: javascript\n */\n\n/**\n * @param {number} millis\n */\nasync function sleep(millis) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, millis)\n  })\n}\n\n/**\n * let t = Date.now()\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\n */\n```","type":"text/markdown","created":"20230528025224357","creator":"oeyoews","modified":"20231018062628578","modifier":"Lenovo","tags":"LeetCode"},{"title":"slice.call","text":"`Array.prototype.slice.call` 是一种常见的 JavaScript 代码模式，通常用于将类似数组的对象（array-like objects）转换为真正的数组。这种模式的作用是复制一个数组的一部分或全部元素到一个新的数组中。\r\n\r\n让我解释一下各部分的含义：\r\n\r\n1. `Array.prototype.slice`：这是数组对象的一个方法，用于从数组中创建一个新的数组，包含从起始索引到结束索引（不包括结束索引）的元素。\r\n\r\n2. `.call`：这是 JavaScript 函数的方法，它允许你调用一个函数并指定函数内部的 `this` 值。在这种情况下，我们将 `Array.prototype.slice` 函数作为 `call` 方法的参数传递，这意味着我们将要调用 `slice` 函数，并将它的 `this` 值设置为后面的对象。\r\n\r\n3. `Array.prototype.slice.call`：这是将 `slice` 函数与 `call` 方法一起使用的常见模式，它允许你在非数组对象上调用 `slice` 函数。因为 `slice` 是一个数组方法，如果你尝试直接在非数组对象上使用它，通常会导致错误。通过使用 `call`，你可以绕过这个问题，将非数组对象作为参数传递给 `slice` 函数。\r\n\r\n总之，`Array.prototype.slice.call` 的作用是将非数组对象转换为数组，并复制其中的元素。在你的代码中，它被用于将 `process.argv`（一个类似数组的对象）的元素转换为数组，并且去掉前两个元素（`process.argv[0]` 和 `process.argv[1]` 通常是 Node.js 进程的路径和脚本文件的路径）。","type":"text/markdown","created":"20230911024910425","modified":"20230911024917870","tags":""},{"title":"SN","text":"1:s/n 是机器本身的编号,像人的身份证一样. 　　\n2:MO是厂家的批量号。 　　\n3:factory ip 是代工厂商编号。\n\nhttps://newsupport.lenovo.com.cn/guardeploySearch.html?from=deploy&pmf_group=quo&pmf_medium\n\nPF2LLLTS","type":"text/markdown","created":"20231015003708309","creator":"Lenovo","modified":"20231015031636980","modifier":"Lenovo","tags":"名词"},{"title":"soft-link-for-path","text":"> for ln -s, use absolute path general, but for some special conditions is not necessary\r\n\r\n<hr> \r\n\r\n> if you want to ln a directory to some where, just jump target use cd, and execute command, such as\r\n\r\n```bash\r\nln ../../plugins ./plugins\r\n```","type":"text/markdown","created":"20230317061727080","creator":"oeyoews","modified":"20230317062012538","modifier":"oeyoews","tags":""},{"title":"sort","text":"`a.date > b.date ? 1 : -1` 是一个简洁的比较函数，用于对日期进行排序。\r\n\r\n这个比较函数可以应用于一个包含日期的数组，并根据日期的大小进行升序排序。\r\n\r\n下面是这个比较函数的工作原理：\r\n\r\n- 如果 `a.date` 大于 `b.date`，则返回 `1`，表示 `a` 应该排在 `b` 后面；\r\n- 如果 `a.date` 小于 `b.date`，则返回 `-1`，表示 `a` 应该排在 `b` 前面。\r\n\r\n通过返回不同的值，我们可以在排序时确定元素的相对位置。\r\n\r\n这种比较函数的作用是根据日期的大小来确定排序顺序。如果 `a.date` 大于 `b.date`，我们认为 `a` 较新，应该排在 `b` 后面；如果 `a.date` 小于 `b.date`，我们认为 `a` 较旧，应该排在 `b` 前面。\r\n\r\n这个比较函数是一种通用的约定，可以应用于各种排序需求，不仅限于日期。\r\n\r\n`arr.sort()` 是 JavaScript 中用于对数组进行排序的方法。它会原地修改数组，将其按照默认的排序规则进行排序。\r\n\r\n默认的排序规则是将数组元素转换为字符串，然后根据 Unicode 码点值的大小进行比较。\r\n\r\n以下是一些示例来演示 `arr.sort()` 的使用：\r\n\r\n```javascript\r\nconst numbers = [10, 5, 8, 1, 7];\r\nnumbers.sort();\r\nconsole.log(numbers);\r\n// 输出：[1, 10, 5, 7, 8]\r\n\r\nconst names = ['John', 'Alice', 'Bob', 'David'];\r\nnames.sort();\r\nconsole.log(names);\r\n// 输出：['Alice', 'Bob', 'David', 'John']\r\n\r\nconst mixed = [10, 'a', 5, 'b', 1];\r\nmixed.sort();\r\nconsole.log(mixed);\r\n// 输出：[1, 10, 5, 'a', 'b']\r\n```\r\n\r\n可以看到，默认情况下 `sort()` 方法会将元素转换成字符串，然后根据字符串的 Unicode 码点值进行比较排序。\r\n\r\n如果你希望按照其他规则进行排序，例如数字比较或自定义比较，可以传入一个比较函数作为参数。","type":"text/markdown","created":"20230722093201816","creator":"oeyoews","modified":"20230726045248773","modifier":"oeyoews","tags":"JavaScript"},{"title":"sounds-mp3","text":"<https://mixkit.co/free-sound-effects/click/?page=2>","type":"text/markdown","created":"20230410120010462","creator":"oeyoews","modified":"20230410120018898","modifier":"oeyoews","tags":""},{"title":"sourcegraph","text":"Sourcegraph 是一款代码搜索和代码导航工具，它旨在帮助开发人员更轻松地理解、查找和修改代码。以下是 Sourcegraph 的一些主要特点和功能：\n\n1. **代码搜索**：Sourcegraph 可以搜索代码库中的所有代码，使开发人员能够快速找到他们需要的代码片段。\n\n2. **代码浏览**：它提供了代码查看器，允许开发人员在不离开浏览器的情况下查看代码库的内容，并提供代码高亮和跳转等功能。\n\n3. **代码跟踪**：Sourcegraph 可以跟踪代码库的更改，以帮助您了解代码的演变历史，查看提交记录和分支信息。\n\n4. **代码审阅**：开发团队可以使用 Sourcegraph 进行代码审阅，评论代码变更并进行协作讨论。\n\n5. **多语言支持**：它支持多种编程语言，包括常见的编程语言如 Java、Python、JavaScript 等，以及其他语言。\n\n6. **集成性**：Sourcegraph 可以与多种代码托管平台（如 GitHub、GitLab、Bitbucket）和代码编辑器（如 Visual Studio Code）集成，使其成为一个强大的开发工具。\n\n7. **安全性**：它还提供了安全扫描工具，帮助团队发现代码库中的潜在安全漏洞。\n\nSourcegraph 的目标是提高开发团队的生产力，使他们更轻松地理解和协作在代码上。如果您有任何具体的问题或需要更多详细信息，请随时提出。","type":"text/markdown","created":"20231014140123566","creator":"Lenovo","modified":"20231014140142313","modifier":"Lenovo","tags":"名词"},{"title":"spa","text":"SPA 是单页应用程序（Single Page Application）的缩写，它使用 JavaScript 动态更新页面内容，而无需每次更改时重新加载整个页面。React 是一种用于构建用户界面的 JavaScript 库，它可以帮助您构建高效且易于维护的 SPA 应用程序。\r\n\r\nReact 使用组件化的方法来构建应用程序，将页面拆分为小部件，每个部件负责呈现自己的内容。这使得开发人员能够更轻松地管理代码和 UI 状态，并创建可重用的代码块。\r\n\r\n当 React 与 SPA 结合使用时，您可以使用 React 来构建应用程序中的每个部分，并使用 React Router 等路由库来控制应用程序的导航。这将使您的应用程序具有更好的性能和用户体验，并更容易扩展和维护。\r\n\r\n\r\nSPA（Single Page Application）是一种 Web 应用程序开发模式，它通过使用 AJAX 和动态 HTML 更新单个页面来提供更快速的用户体验。与传统的多页应用程序相比，SPA 通常具有以下特点：\r\n\r\n1. 页面刷新少：因为 SPA 只加载一个 HTML 页面并通过 AJAX 请求数据，所以可以减少页面刷新和服务器负载。\r\n\r\n2. 更快的用户体验：由于只需要在用户与应用程序交互时才需要更新页面，并且可以使用缓存技术在本地存储数据，因此可以提高应用程序的响应速度和性能。\r\n\r\n3. 更灵活的前端架构：因为 SPA 通常使用 JavaScript 来渲染视图，所以可以使用现代的前端框架（如 React、Angular 或 Vue.js）来构建复杂的用户界面。\r\n\r\n4. SEO 困难：因为 SPA 只有一个 HTML 页面，而且大部分内容都是通过 AJAX 请求获取后渲染到页面上，搜索引擎可能无法正确索引网站，对 SEO 会有一定影响。\r\n\r\n以下是一些常见的 SPA 框架和库：\r\n\r\n- AngularJS / Angular\r\n- React\r\n- Vue.js\r\n- Ember.js\r\n- Backbone.js\r\n\r\n需要注意的是，在使用 SPA 开发 Web 应用程序时，需要特别注意安全性问题，例如跨站脚本攻击（XSS）和跨站请求伪造（CSRF）等问题。","type":"text/markdown","created":"20230504084318317","creator":"oeyoews","modified":"20230507125135111","modifier":"oeyoews","tags":"React"},{"title":"space-x-2","text":"`space-x-2` 是 Tailwind CSS 中的一个类，用于在水平方向（主轴）上为 Flex 容器内的项目（子元素）添加指定的间距。\r\n\r\n具体来说，`space-x-2` 类会在每个项目之间添加 `2` 的间距。你可以根据需要使用不同的数字来调整间距的大小，例如 `space-x-4` 表示在项目之间添加 `4` 的间距。\r\n\r\n使用 `space-x-2` 类的示例代码如下：\r\n\r\n```html\r\n<div class=\"flex space-x-2\">\r\n  <div class=\"bg-red-500 w-8 h-8\"></div>\r\n  <div class=\"bg-blue-500 w-8 h-8\"></div>\r\n  <div class=\"bg-green-500 w-8 h-8\"></div>\r\n</div>\r\n```\r\n\r\n在上面的代码中，`space-x-2` 类被应用于包含三个 `<div>` 元素的 Flex 容器。这将在每个项目之间添加 `2` 的间距。每个项目都设置了背景颜色和宽高以便进行可视化。\r\n\r\n你可以根据需求调整 `space-x-2` 类的数值，或者使用其他 Tailwind CSS 提供的间距类来创建所需的布局效果。","type":"text/markdown","created":"20230724090417731","creator":"oeyoews","modified":"20230726045248775","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"special-keys","text":"```plain\nŒ∑´®†¥¨ˆøπ“‘«åß∂ƒ©˙∆˚¬…æΩ≈ç√∫˜μmol≤≥÷\nŒ„´‰ˇÁ¨ˆØ∏”’»ÅÍÎÏ˝ÓÔÒÚÆ¸˛Ç◊ı˜Â¯˘¿\n```\n\non ios ","type":"text/markdown","created":"20231009130056191","creator":"Lenovo","modified":"20231009130203714","modifier":"Lenovo","tags":""},{"title":"split-join-array-string","text":"```js\r\nconst de = \"1 2 3\";\r\nconsole.log(de.split(\" \").join(\"\"));\r\nconsole.log(...de.split(\" \"));\r\n```","type":"text/markdown","created":"20230925013202389","creator":"oeyoews","modified":"20230925013234695","modifier":"oeyoews","tags":"JavaScript"},{"title":"spotify","text":"spotify 只能通过 jp 节点才能登陆，并且非会员广告不可跳过","type":"text/markdown","created":"20231009130529217","creator":"Lenovo","modified":"20231009130553122","modifier":"Lenovo","tags":""},{"title":"spread-operator","text":"剩余参数语法（Rest Parameters Syntax）和展开运算符（Spread Operator）在使用方式和作用上有所区别。\r\n\r\n1. 剩余参数语法（Rest Parameters Syntax）：`...args`\r\n\r\n剩余参数语法用于将多个参数收集到一个数组中。它在函数定义中使用，以表示函数可以接收任意数量的参数，并将它们作为数组访问。剩余参数语法只能在函数定义中使用，用于接收参数。\r\n\r\n示例：\r\n```javascript\r\nfunction sum(...numbers) {\r\n  // numbers 是一个包含所有参数的数组\r\n  let total = 0;\r\n  for (let num of numbers) {\r\n    total += num;\r\n  }\r\n  return total;\r\n}\r\n\r\nconsole.log(sum(1, 2, 3)); // 输出 6\r\nconsole.log(sum(4, 5, 6, 7)); // 输出 22\r\n```\r\n\r\n2. 展开运算符（Spread Operator）：`...array`\r\n\r\n展开运算符用于在数组或对象字面量中展开数组或对象的元素。它可以在函数调用、数组字面量、对象字面量等地方使用。展开运算符将一个数组或对象拆分成各个元素，作为独立的参数或键值对进行使用。\r\n\r\n示例：\r\n```javascript\r\n// 数组展开\r\nconst numbers = [1, 2, 3];\r\nconsole.log(...numbers); // 输出 1 2 3\r\n\r\n// 函数调用中使用展开运算符\r\nfunction sum(a, b, c) {\r\n  return a + b + c;\r\n}\r\n\r\nconsole.log(sum(...numbers)); // 输出 6\r\n\r\n// 数组拼接\r\nconst array1 = [1, 2, 3];\r\nconst array2 = [4, 5, 6];\r\nconst mergedArray = [...array1, ...array2];\r\nconsole.log(mergedArray); // 输出 [1, 2, 3, 4, 5, 6]\r\n```\r\n\r\n总结：\r\n- 剩余参数语法（Rest Parameters Syntax）用于函数定义中，将多个参数收集到一个数组中。\r\n- 展开运算符（Spread Operator）用于展开数组或对象，在函数调用、数组字面量、对象字面量等地方使用。\r\n\r\n虽然它们在语法上使用了相同的三个点（`...`），但根据它们所在的上下文和使用方式的不同，它们具有不同的作用和效果。","type":"text/markdown","created":"20230625042714181","creator":"oeyoews","modified":"20230726045248776","modifier":"oeyoews","tags":"JavaScript"},{"title":"star-principle","text":"“STAR”法则是在面试中用于回答问题的一种技巧。它代表的是 Situation（情境）、Task（任务）、Action（行动）和 Result（结果）四个单词的缩写。在面试中，当你被问到一个问题时，可以按照这个技巧来回答，从而使回答更加清晰，结构更加明确。具体来说，你需要先描述一个具体的情境，然后说出你需要完成的任务，接着说明你采取了哪些行动，最后阐述你所取得的结果。这样的回答方式能够有效地展示你的思考能力、行动力以及解决问题的能力，从而提高你在面试中的竞争力。","type":"text/markdown","created":"20230605115507835","creator":"oeyoews","modified":"20230726045248777","modifier":"oeyoews"},{"title":"startup-before-after","text":"> https://tiddlywiki.com/dev/#StartupMechanism","type":"text/markdown","created":"20230923124953708","creator":"oeyoews","modified":"20230923125009371","modifier":"oeyoews","tags":"Plugins"},{"title":"state-managent","text":"状态管理对于前端应用的开发非常重要。在一个典型的 Web 应用中，应用的状态通常分散在各个组件中，并且可能会有多种状态，如用户身份认证、UI 布局信息、网络请求数据等。在这种情况下，如果没有一个良好的状态管理方案，就很难维护和扩展应用。\r\n\r\n以下是状态管理的一些重要性：\r\n\r\n简化了组件之间的通信：通过将应用程序的状态放入一个单一的位置，可以减少组件之间的通信和传递 props。\r\n\r\n易于调试和维护：在一个适当的状态管理系统中，可以更轻松地跟踪和理解应用程序的状态，以及对状态的任何更改。同时，它也可以减少由于深度嵌套组件引起的代码复杂性。\r\n\r\n提高了代码的可读性和可测试性：在一个适当的状态管理系统中，可以更容易地理解应用程序的状态和 UI 的变化，从而提高代码的可读性和可测试性。\r\n\r\n更好的用户体验：当应用的状态得到更好的管理时，可以减少因为状态不同步或者不可控制而引起的用户体验问题。\r\n\r\n综上所述，状态管理对于 Web 应用程序的开发和维护都是非常重要的，一个良好的状态管理方案可以提高代码质量、可读性、可维护性和用户体验。","type":"text/markdown","created":"20230430110232552","creator":"oeyoews","modified":"20230430110257866","modifier":"oeyoews","tags":"React Vue"},{"title":"stop-parse-options","text":"```plain\r\n--\r\n```","type":"text/markdown","created":"20230329064233186","creator":"oeyoews","modified":"20230329064246108","modifier":"oeyoews","tags":""},{"title":"stripe","text":"Stripe 是一家全球领先的在线支付处理平台和支付解决方案提供商。它提供了一套开发人员友好的工具和 API，使商家能够轻松地在其网站或应用程序中集成支付功能。\r\n\r\nStripe 的主要特点包括：\r\n\r\n1. 支持多种支付方式：Stripe 支持各种支付方式，包括信用卡、借记卡、Apple Pay、Google Pay 等。它提供了简单而安全的支付流程，使用户能够方便地进行支付。\r\n\r\n2. 简化开发过程：Stripe 提供了丰富的开发工具和文档，使开发人员能够轻松地集成支付功能到他们的网站或应用程序中。它的 API 设计简洁明了，易于使用和理解。\r\n\r\n3. 安全性和合规性：Stripe 非常注重支付数据的安全性和合规性。它采用了多种安全措施，包括数据加密、PCI DSS 合规等，以保护用户的支付信息。\r\n\r\n4. 订阅和重复付款：Stripe 提供了强大的订阅和重复付款功能，使商家能够轻松管理定期付款、订阅计划和会员制度。\r\n\r\n5. 数据和分析：Stripe 提供了丰富的数据和分析工具，使商家能够深入了解他们的支付流程和业务表现。商家可以通过仪表板查看交易数据、收入报告等。\r\n\r\nStripe 的灵活性和易用性使其成为许多企业和开发者的首选支付解决方案。它被广泛应用于电子商务、订阅服务、共享经济等各种在线业务领域。","type":"text/markdown","created":"20230703043108392","creator":"oeyoews","modified":"20230726045248777","modifier":"oeyoews"},{"title":"substr-usage","text":"```js\r\nconst str = \"Hello, World!\";\r\n\r\nconst result1 = str.substr(7);     // 从索引 7 开始提取到字符串的末尾\r\nconsole.log(result1);              // 输出：World!\r\n\r\nconst result2 = str.substr(7, 5);  // 从索引 7 开始提取长度为 5 的子字符串\r\nconsole.log(result2);              // 输出：World\r\n\r\nconst str = \"Hello, World!\";\r\n\r\nconst result1 = str.substr(7, 5);\r\nconsole.log(result1);  // \"World\"\r\n\r\nconst result2 = str.substring(7, 12);\r\nconsole.log(result2);  // \"World\"\r\n```","type":"text/markdown","created":"20230702105542905","creator":"oeyoews","modified":"20230726045248778","modifier":"oeyoews","tags":"TypeScript"},{"title":"super-contructor","text":"在面向对象编程中，`constructor` 和 `super` 是两个重要的概念，尤其是在继承关系中的使用。\r\n\r\n`constructor` 是一个类中的特殊方法，用于初始化对象的实例。当你创建一个对象的实例时，构造函数会被调用，以便执行一些初始化操作，例如设置对象的属性和状态。\r\n\r\n`super` 是一个关键字，用于调用父类的构造函数。在子类中的构造函数中，你可以使用 `super()` 来调用父类的构造函数，从而执行父类的初始化操作。这对于继承来自父类的属性和方法非常有用。\r\n\r\n以下是一个简单的示例代码，演示了如何在子类的构造函数中使用 `super`：\r\n\r\n```javascript\r\nclass Animal {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n}\r\n\r\nclass Dog extends Animal {\r\n  constructor(name, breed) {\r\n    super(name); // 调用父类的构造函数\r\n    this.breed = breed;\r\n  }\r\n}\r\n\r\nconst myDog = new Dog(\"Buddy\", \"Golden Retriever\");\r\nconsole.log(myDog.name);  // 输出: Buddy\r\nconsole.log(myDog.breed); // 输出: Golden Retriever\r\n```\r\n\r\n在这个示例中，`Animal` 是父类，`Dog` 是子类。`Dog` 类的构造函数使用了 `super(name)` 来调用 `Animal` 类的构造函数，并传递了一个参数 `name`。\r\n\r\n总之，`constructor` 用于初始化对象实例，`super` 用于在子类的构造函数中调用父类的构造函数以进行初始化操作。","type":"text/markdown","created":"20230828092302112","creator":"oeyoews","modified":"20230828092318571","modifier":"oeyoews","tags":"JavaScript"},{"title":"svg-png","text":"SVG 和 Image 都是用于在网页上展示图像的技术，但它们的实现方式和呈现效果有所不同。\n\nSVG (Scalable Vector Graphics) 是一种基于 XML 的矢量图形格式，它通过指定绘图指令来描述图像的形状和颜色。与传统的位图图像不同，SVG 图像是由数学公式和几何路径组成的，因此它们可以无限地缩放而不会失真。这是因为当图像缩放时，SVG 根据指定的矢量图形形状重新计算图像的每个元素，而不是像位图那样缩放像素。\n\n相比之下，Image 图像通常是基于像素而构建的，它由一组固定的点阵像素组成。当图像被缩放时，像素被拉伸或压缩，导致图像模糊或失真。\n\n因此，当 SVG 图像被缩放时，图像质量不会降低，因为图像元素是根据矢量指令重新计算的。而当 Image 图像被缩放时，像素被拉伸或压缩，导致图像看起来模糊或失真。\n\n需要注意的是，如果使用的是低分辨率的 SVG 图像，则在高分辨率设备上放大时可能会出现像素化或失真。但是，通过使用矢量图形，SVG 可以在不同的设备和分辨率上呈现清晰、高质量的图像。","type":"text/markdown","created":"20231030080905080","creator":"Lenovo","modified":"20231030080920782","modifier":"Lenovo","tags":"HTML"},{"title":"svg-type","text":"* 如果加了 svg type, tw 会将其识别为 image(在插件中是 icon.svg icon.svg.meta),插件库可以显示图标, 但是 pagecontrol 不会使用对应的 class, \r\n* 如果使用默认类型, 就是 svg 代码, 但是插件库不会识别图片\r\n\r\n> 这是一个半 bug","type":"text/markdown","created":"20230923052431578","creator":"oeyoews","modified":"20230923052737181","modifier":"oeyoews","tags":"TiddlyWiki Plugins Bug"},{"title":"SWR","text":"SWR 是一种用于 React 应用程序的 JavaScript 库，它可以帮助开发人员轻松地处理数据获取和缓存。它的全称是“Stale-While-Revalidate”，意思是“陈旧-同时-重新验证”。这个库的主要目的是在数据获取时提供更好的用户体验和性能。它通过在组件中自动缓存数据并提供实时更新，使得数据获取变得更加高效和快速。此外，它还可以处理离线状态和网络错误等情况，确保用户始终可以访问到最新的数据。SWR 使用了 React 的 hooks API，因此它非常易于集成到现有的 React 应用程序中。它还提供了许多可定制的选项，以帮助开发人员根据具体需求进行配置。","type":"text/markdown","created":"20230622020704465","creator":"oeyoews","modified":"20230726045248778","modifier":"oeyoews"},{"title":"symlink-on-windows","text":"linux 上的相对路径的软连接在 Windows 上竟然可以用(准确来说不是这样)\n\n> 通过 wsl 创建的软连接居然默认是 windows 上的快捷方式而不是软连接, 在 github.dev 上创建的也是快捷方式, 只有在原生 linux 上创建的软连接被 window 上识别成了 symlink, 但是 window 上的快捷方式在 linux 的环境中部署居然可以使用, 离谱\n\n:::bug\nsymlink and shortcut 被 git 认为是一个文件,不能检测到变化\n:::","type":"text/markdown","created":"20231009144215326","creator":"Lenovo","modified":"20231009152343104","modifier":"Lenovo","tags":"windows"},{"title":"tagpie","text":"<!-- add 里面的log 无法在控制台输出 -->\n\n<div class=\"my-8\" >\n<div class=\"dark:hidden\">\n<$echarts $tiddler=\"addon/tagpie.js\" $theme=\"auto\" doughnut=\"yes\" sort=\"descend\" $theme='light'/>\n</div>\n<div class=\"hidden dark:block\">\n<$echarts $tiddler=\"addon/tagpie.js\" $theme=\"auto\" doughnut=\"yes\" sort=\"descend\" $theme='dark'/>\n</div>\n</div>\n","type":"text/markdown","created":"20231010065215150","creator":"Lenovo","modified":"20231027102847951","modifier":"Lenovo","tags":""},{"title":"tags","text":"<div class=\"text-justify\">\n<$list filter=\"[tags[]!prefix[$:/]]\" >\n<span class=\"capitalize\">\n<$transclude $variable='tag'/>\n</span>\n</$list>\n</div>","type":"text/markdown","created":"20231018003649763","creator":"Lenovo","modified":"20231018010847316","modifier":"Lenovo","tags":""},{"title":"Tailwindcss","text":":::note Tailwindcss\n\"Tailwind CSS 是一个高度可定制的 CSS 框架，它通过原子类的方式提供了丰富的样式工具集，使开发者能够快速构建现代化的用户界面。它具有简洁的语法和灵活的设计，让开发者能够轻松地定制样式，提高开发效率，并且可应用于各种项目和设计风格。\n:::\n\n:::warning\ntailwindcss 源代码是开源的, 但是构建 cdn 的相关步骤似乎没有\n:::\n\n<table class=\"\">\n<$list filter=\"[tag[Tailwindcss]!sort[modified]]\">\n<tr>\n<td class=\"p-[4px] bg-neutral-200 capitalize \"> <$link to={{!!title}}><$view field=\"title\"/></$link>\n</td>\n</tr>\n</$list>\n</table>","type":"text/markdown","created":"20230501120326107","creator":"oeyoews","icon":"Tailwindcss.png","modified":"20231018093337875","modifier":"Lenovo","page-icon":"devicon:tailwindcss","tags":""},{"title":"tailwindcss-border-style","text":"tailwindcss 如果禁用预设, border-style 会是 none, 不会显示 border(tw 应该是自己加了)\r\n```html \r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width\" />\r\n    <title>Index 10</title>\r\n    <script src=\"https://cdn.tailwindcss.com\"></script>\r\n    <script>\r\n      tailwind.config = { corePlugins: { preflight: false } };\r\n    </script>\r\n  </head>\r\n  <body>\r\n    <!-- style=\"border: 2px solid red\" -->\r\n    <form\r\n      class=\"p-2 flex justify-between max-w-xl mx-auto border border-2 rounded border-blue-300 border-dashed\"\r\n    >\r\n      demo\r\n    </form>\r\n  </body>\r\n</html>\r\n```","type":"text/markdown","created":"20230909024210947","creator":"oeyoews","modified":"20230909024320696","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"tailwindcss-plugin-bug","text":"tailwindcss plugin 在 vscode 经常不触发提示, webstorm 则没有这个问题","type":"text/markdown","created":"20230831050629131","creator":"oeyoews","modified":"20230831050705311","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"Talk_is_not_cheap","text":"（本文描述的是我长久的经历中形成的看法，跟我现在身边的人和事没有直接联系，请勿对号入座。）\n\n长久以来，我发现挺多 IT 人士学会了一句口头禅，无论你表达什么观点，他们会拿出一副小学老师要检查作业的口气，说：“Talk is cheap. Show me the code!” 或者 “给我看看你做出了什么！”\n\n这类说法包含了两种可能的含义：\n\n1. 说话是没用的，你要做出来我才信。\n2. 你要已经有了重要的成果，才有资格发言。\n\n“Talk is cheap. Show me the code.” 这句话出自 Linus Torvalds 在 linux-kernel mailing list 的一个[回帖](https://lkml.org/lkml/2000/8/25/132)。如果你看了我对微内核和线程的[分析](http://www.yinwang.org/blog-cn/2019/08/19/microkernel)，也许会明白 Jamie Lokier 的话其实是有意义的。如果保持开放的心态，继续的探讨也许会给 Linux 内核带来突破性的改进，然而这种可能性却被 Linus 一句“Talk is cheap. Show me the code.” 给扼杀了。\n\n[![](https://www.yinwang.org/images/talk-is-cheap.jpg)](https://lkml.org/lkml/2000/8/25/132)\n\nLinus 可能当时不耐烦了，你知道这家伙的性格…… 我相信他不是每次都说这样的话，但因为 Linus 形象太高大，这话就被人记下来，作为可以反复拿出来压制言论的手段。管你表达什么，他们都有一句万能的台词：“Talk is cheap. Show me the code.”\n\n“苦干，用代码说话，忽视想法”，是很多程序员的误区。人的思想不一定需要代码来证明，甚至很多的想法无法简单的用代码表示，只有靠人的头脑才能想得清楚。思想是首要的，代码只是对思想的一种实现。我们先得要有思想（算法），才可能有代码。有些人动不动就“show me the code”，却忽视了思考和探讨的重要性。如果你没有好的想法，弄一堆代码出来又有什么用呢？只是死钻进一堆无谓的细节，掩盖了本质。\n\n代码不能代替思想交流和讨论。代码不能清晰的表达一个人的想法，也不能显示一个人的思维深度。任何程序员都可以写出复杂冗长的代码，你有时间去看吗？就算水平很高的程序员，他的代码组织方式你不熟悉，也会看不出来本来的想法。实际的代码里面往往会充斥着因为编程语言，硬件，系统，历史遗留问题导致的各种复杂性。如果每个想法真要“show me the code”才被考虑的话，那效率实在太低了。\n\n我跟同事讨论代码的时候，一般都会先请他们在白板上画个图，用简单的语言解释他们的算法，这比直接看代码要容易很多。很多时候几句话就能说清楚，我在脑子里就能看到它是怎么工作的，根本用不着看代码。我从来不会说“show me the code！” 想法应该在实现之前被讨论清楚，对不可行的想法应该停止于摇篮之中，对可行的想法应该看到各种可能的发展方向…… 这些都应该在实现代码之前沟通弄明白，这会节省我们大量的时间和精力。\n\n这就是 Talk 的价值。\n\n另外，代码和成果不应该成为一个人是否可以表达看法的条件。只要这个人的见解有它的依据，就是有价值的。他不需要有什么重大的成就也应该可以表达自己的看法。这个我在之前一篇[文章](http://www.yinwang.org/blog-cn/2017/11/01/power-of-reasoning)说过。以代码和所谓“成果”来压制人的言论自由是不合理的，而且代码和“成果”其实很难说明一个人的看法是否有价值。\n\n很多人面试程序员都有类似的经验，他们给你看已经写好的代码，根本无法用来鉴别他们的水平。因为代码是可以拷贝的，所以你无法知道这代码是否他自己写出来的。代码可以是冗长晦涩的，所以就算是他自己写出来的，你也不会想花时间去看懂它。\n\n代码是死的，它是对已有问题的解决方案。而你想要知道的是这个人在面对新的问题的时候，他会怎样去解决它。所以你必须知道这个人的思维方式，看清楚他是否真的知道他声称“精通”的那些东西。\n\n一个人说他之前的工作做出了什么样的成果，很多时候也是不可靠的。因为成果是可以虚构或者盗窃的，他可以把别人的成果说成是自己的。如果是管理岗位，“成果”就更加难以鉴定。这人也许只是瞎指挥，对很多人各种发号施令，对不同的人指出 N 种不同的方向，然后瞎蒙对了一个。其中一个方向做出了点东西，当然工作都是手下人做的，具体的想法都是手下人的。然后领导者挂个名字，就成了大家追捧的“技术大牛”。\n\n很多博导都是用这种方法出成果的。招 N 个博士生来，分别给他们每人一个课题。管它有没有可能做出来，有没有价值，都跟你说这个课题很好。只要 N 个博士生有一两个做出东西，他就可以发 paper 升职了。被分配到那些做不出来的方向的学生，他才不管你的死活呢。\n\n有见识的人跟他们对话，就会发现这些人一知半解，还仍然牛逼轰轰的样子。这就是我多次的经历。管他说做过什么代码项目，写了什么书，得了什么奖，一旦当面对话就能显示出真实的水平。代码和书都可以抄来，成果可以盗窃，你甚至可以因此得诺贝尔奖，可是对话没法偷来。对话可以显示出一个人是否有真知灼见。\n\n一个小故事。我以前就职的某公司，有次招了一个 VP，他的 github 上有上百万行的代码，项目有上万的“star”，在领域里很是有点名声。这算是成果了吧？结果一进公司就各种瞎指挥，搞得大家没法工作了。还招进来很多自己圈子里的亲信，也是一群只会吹牛不做事的人，各种打压其他人，浪费大量的人力物力。我都感觉公司快要被搞垮了，最后创始人终于醒悟，费了好大功夫才把这些人赶走或者架空。\n\n所以一个人有再多的代码，成果，都可能是没用的。我不排除它们是真实的情况，但你需要懂得如何去鉴别，而不只是依据这些表面的标准。\n\n对于人的水平，我一般会观察他们说的话，最好是当面的对话。我不会盲目相信他们所谓的“成果”，我不看他们的代码。有真知灼见的人可以毫不犹豫地说出自己的想法和观点，而不需要时间去背诵和计算。我很容易看出一个人是否在说真话，因为说真话的人不需要时间去“计算”他们要说什么，不需要演戏。\n\n可惜，“Talk is cheap”已经成为了很多人用来压制言论的手段。它误导了很多人，让他们无法正确鉴别技术人员的水平，犯下严重的人事错误。招进来一个错误的人，可以毁掉整个公司。\n\n那些被“Talk is cheap”压制的人，变得不敢表达自己的观点，总想默默无闻“做”点什么给大家看。可是对方有什么资格要求这些呢？他们自己做出了什么呢？等你真做了给他们看，他们又会说你的东西不好，不如别人 xx 的。想当年我做的那什么，比你厉害多了…… 其他人也云里雾里，没有鉴别能力，只能随机倒向一边。\n\n受到“show me the code”影响的人，可能还会让别人去看他的代码，而不解释自己的想法。大家工作中也许遇到过有人拒绝解释自己的想法，说：“你看代码就明白我做了什么。” 这其实是不大尊重人的行为。没有人应该被迫去阅读其它人的代码，写出代码的人有义务讲清楚自己代码背后的思想。\n\n由于我对某些领域很在行，不止一次有人 email 联系我：“我做了这个东西，我想知道你对它的评价。” 连基本的想法都不说，甚至称呼和自我介绍都没有，接下来就是一个 github 的代码链接，或者粘贴一大段代码在 email 里面。这种代码我是不看的。我可能 email 都不会回，因为这显示出他们缺乏基本的礼貌和对他人时间的尊重。\n\n代码不是有效的沟通工具，也不应该用来决定一个人是否有发言权。“Talk is cheap”只不过是封嘴的手段。说别人“Talk is cheap”的那些人，他们自己却不断地 talk。\n\n人们应该可以平等自由的表达自己，不受这种无谓的教条压制。每当有人一针见血，指出我迷惑已久的问题的要点，豁然开朗的时候，我会很清楚的记得这个人。我会尊敬他，在合适的时候给予他回报。就算没有给我新的想法，要是他说出一些我曾经琢磨很久才想清楚的点，或者给了我另一个角度的观点，我也会记得他。这些给我指出正确方向的人，我不需要看他们的代码，我不以最终的“成果”来衡量他们的价值。想法和观点在我这里是高于代码的。\n\nTalk 一点都不 cheap，而可以是有很大价值的。中国有句古话，“听君一席话胜读十年书”，说的就是这个道理。当然我们还是应该避免无意义的对话，但不应该笼统的说“Talk is cheap”。\n\n可是我发现并不是每个人都像我这样。有些人，他迷惑的时候你给他指出要点或者方向，最后他却说那是他自己想出来的，甚至说你的话没有价值，我只看结果…… 遇到这种情况，你就知道遇到了错误的人。你不需要向他证明什么，不应该再给他任何有价值的信息。\n\n很多人被“成果”或者代码所蒙蔽，而忽略了那些能够看透问题，用简单的几句话指出正确方向的人。我希望以这篇文章纠正很多业内人士的思维方式。\n\nTalk is not cheap. Talk can be powerful.\n","type":"text/markdown","created":"20231030052200798","creator":"太微搜藏","modified":"20231030052200798","modifier":"太微搜藏","tags":"剪藏","url":"https://www.yinwang.org/blog-cn/2019/09/11/talk-is-not-cheap"},{"title":"terser","text":"```js\nterser vim.js -o vim.min.js -c arguments,arrows=true -m toplevel,keep_classnames,keep_fnames\n```","type":"text/markdown","created":"20230315121249264","creator":"oeyoews","modified":"20231021051111275","modifier":"Lenovo","tags":""},{"title":"The-missing-dev-document-for-tiddlywiki","text":"> tw 的用户文档略显杂多, 开发者文档又极度缺失, 只能找源代码\r\n\r\n> https://github.com/Jermolene/TiddlyWiki5/blob/526e997aa4de03acdc2ff56ac7c19b3ff06cbb64/languages/da-DK/Docs/ModuleTypes.multids#L9\r\n\r\n```plain\r\nallfilter 运算符：“all”过滤器运算符的子运算符。\r\n动画：动画可以与 RevealWidget 一起使用。\r\n位图编辑器操作：位图编辑器工具栏操作。\r\ncommand：可以在Node.js下运行的命令。\r\nconfig：要插入到 `$tw.config` 中的数据。\r\n过滤器运算符：单独的过滤器运算符方法。\r\nglobal：插入到`$tw`中的全局数据。\r\ninfo：通过[[$:/temp/info-plugin]]伪插件发布系统信息。\r\n冰过滤器运算符：“冰”过滤器运算符的操作数。\r\n库：通用 JavaScript 模块的通用模块类型。\r\n宏：JavaScript 宏定义。\r\n解析器：不同内容类型的解析器。\r\n保存程序：保存程序处理从浏览器保存文件的各种方法。\r\n启动：启动功能。\r\nStoryview：Storyview 自定义列表小部件的动画和行为。\r\n文本编辑器操作：文本编辑器工具栏操作。\r\ntidlerserializer：将各种内容类型转换为tiddlers。\r\ntidlerfield：定义单个tiddler 字段的行为。\r\ntidlermethod：向 `$tw.Tiddler` 原型添加方法。\r\nUpgrader：在升级/导入期间使用tiddlers的升级处理。\r\nutils：向 `$tw.utils` 添加方法。\r\nutils-node：将 Node.js 特定方法添加到“$tw.utils”。\r\nwidget：Widgets封装了DOM的渲染和刷新。\r\nwikimethod：向 `$tw.Wiki` 添加方法。\r\nwikirule：主要维基文本解析器的单独解析规则。\r\n```","type":"text/markdown","created":"20230923122352626","creator":"oeyoews","modified":"20230923123558581","modifier":"oeyoews","tags":"TiddlyWiki"},{"title":"thebrain","text":"<!-- {{$:/temp/focussedTiddler}} -->\n<div class=\"z-0 fixed bottom-0 right-0 rounded-tr-lg hidden lg:block\">\n<$echarts $tiddler=\"$:/plugins/Gk0Wk/echarts/addons/TheBrain.js\" aliasField=\"caption\" levels=1 graphTitle=\" \" draggable=\"yes\" previewDelay='100' focusBlur=\"true\" legend='' $width=\"200px\" $height=\"200px\" scale=\"yes\"/>\n</div>","type":"text/markdown","created":"20231013092958847","creator":"Lenovo","modified":"20231016093924972","modifier":"Lenovo","tags":""},{"title":"thesis-summary","text":"> 基于 Node.js 的校园信息交流平台可以分为前端和后端两部分，前端负责用户界面的展示，后端负责处理用户请求和数据存储。以下是该平台的设计和实现步骤：\r\n\r\n1. 设计数据库\r\n\r\n根据功能需求，设计数据库的表结构，包括用户表、帖子表、评论表等。使用 MySQL 数据库管理系统，使用 Node.js 的 ORM 框架来操作数据库。\r\n\r\n> 数据库是整个平台的数据存储和管理中心，我们使用 MySQL 作为数据库管理系统。在设计数据库时，根据平台的功能需求和用户行为习惯，设计合理的数据表结构和数据字段，同时使用 Node.js 的 ORM 框架 Sequelize 来操作数据库，提高开发效率和数据处理能力。\r\n\r\n2. 搭建后端服务器\r\n\r\n使用 Node.js 的 Web 框架 `Express` 搭建后端服务器，处理用户请求和响应。后端服务器需要实现用户登录、注册、发布帖子、评论等功能，同时需要进行身份验证和数据校验，保证安全性和稳定性。\r\n\r\n> 后端服务器是整个平台的逻辑处理和数据交互中心，我们使用 Node.js 的 Web 框架 Express 来搭建后端服务器。在后端服务器中，我们实现了用户登录、注册、发布帖子、评论等功能，同时进行身份验证和数据校验，保证平台的安全性和稳定性。\r\n\r\n3. 实现用户界面\r\n\r\n使用 HTML、CSS 和 JavaScript 等前端技术，实现平台的用户界面。界面需要包括登录、注册、发布帖子、评论等功能的界面元素，同时需要与后端服务器进行交互，实现数据的获取和展示。\r\n\r\n> 用户界面是整个平台的展示中心，我们使用 HTML、CSS 和 JavaScript 等前端技术，实现了平台的用户界面。在用户界面中，用户可以进行登录、注册、发布帖子、评论等操作，同时可以与后端服务器进行交互，实现数据的获取和展示。\r\n\r\n4. 实现用户交互\r\n\r\n使用 JavaScript 和前端框架 `Vue.js` 实现用户交互功能，包括登录、注册、发布帖子、评论等功能的交互逻辑。通过与后端服务器进行交互，实现数据的传输和处理。\r\n\r\n> 用户交互是整个平台的核心部分，我们使用 JavaScript 和前端框架 Vue.js 来实现用户交互功能。通过与后端服务器进行交互，实现数据的传输和处理，同时实现了登录、注册、发布帖子、评论等功能的交互逻辑，提高了用户体验和平台的易用性。\r\n\r\n5. 部署平台\r\n\r\n将信息交流平台的前端和后端部署到本地服务器上, 如果需要, 可以使用 Nginx 等 Web 服务器进行反向代理和负载均衡，提高平台的性能和可扩展性。\r\n\r\n> 我们将平台的前端和后端部署到阿里云服务器上，使用 Nginx 进行反向代理和负载均衡，保证平台的稳定性和可用性。同时，我们进行了安全性、性能优化和代码规范等方面的优化，提高了平台的安全性、性能和可维护性。\r\n\r\n以上是基于 Node.js 的校园信息交流平台的设计和实现步骤，具体实现过程中涉及到安全性、性能优化、代码规范等方面的问题。\r\n\r\n> 总之，我们的基于 Node.js 的校园信息交流平台，通过合理的数据库设计、稳定的后端服务器、优秀的用户界面和交互设计，以及严格的部署和运维管理，为用户提供了一个安全、稳定、易用的校园信息交流平台。\r\n\r\n\r\n\r\n## TODO\r\n\r\n* [x] Auth module","type":"text/markdown","created":"20230411030749170","creator":"oeyoews","modified":"20230726045248778","modifier":"oeyoews","publish":"readonly"},{"title":"This","text":"## JavaScript this 关键字\r\n\r\n### 面向对象语言中 this 表示当前对象的一个引用\r\n\r\n但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。\r\n\r\n在方法中，this 表示该方法所属的对象。\r\n如果单独使用，this 表示全局对象。\r\n在函数中，this 表示全局对象。\r\n在函数中，在严格模式下，this 是未定义的(undefined)。\r\n在事件中，this 表示接收事件的元素。\r\n类似 call() 和 apply() 方法可以将 this 引用到任何对象。\r\n\r\nJavaScript 中的 this 关键字是一个指向当前执行上下文的引用，它的值取决于函数的调用方式。this 关键字可以用于访问当前对象的属性和方法，也可以用于创建新的对象。\r\n\r\n在 JavaScript 中，this 关键字的值取决于函数的调用方式。当函数被作为方法调用时，this 关键字会指向调用该方法的对象。例如：\r\n\r\n```javascript\r\nvar person = {\r\n  firstName: \"John\",\r\n  lastName : \"Doe\",\r\n  fullName : function() {\r\n    return this.firstName + \" \" + this.lastName;\r\n  }\r\n};\r\n\r\nconsole.log(person.fullName()); // 输出 \"John Doe\"\r\n```\r\n\r\n在这个例子中，我们定义了一个名为 person 的对象，该对象包含了 firstName、lastName 和 fullName 三个属性。fullName 属性是一个函数，用于返回 person 对象的完整姓名。当我们调用 person.fullName()方法时，this 关键字会指向 person 对象，因此函数中的 this.firstName 和 this.lastName 都会返回 person 对象的属性值。\r\n\r\n当函数不作为对象的方法调用时，this 关键字会指向全局对象。例如：\r\n\r\n```javascript\r\nfunction myFunction() {\r\n  return this;\r\n}\r\n\r\nconsole.log(myFunction()); // 输出全局对象\r\n```\r\n\r\n在这个例子中，我们定义了一个名为 myFunction 的函数，该函数没有被任何对象调用。当我们调用 myFunction()函数时，this 关键字会指向全局对象，因此函数中的 this 将返回全局对象。\r\n\r\n除了作为方法调用和全局调用之外，this 关键字还可以用于构造函数和事件处理程序等场景。在构造函数中，this 关键字用于创建新的对象。例如：\r\n\r\n```javascript\r\nfunction Person(firstName, lastName) {\r\n  this.firstName = firstName;\r\n  this.lastName = lastName;\r\n  this.fullName = function() {\r\n    return this.firstName + \" \" + this.lastName;\r\n  }\r\n}\r\n\r\nvar person = new Person(\"John\", \"Doe\");\r\nconsole.log(person.fullName()); // 输出 \"John Doe\"\r\n```\r\n\r\n在这个例子中，我们定义了一个名为 Person 的构造函数，用于创建具有 firstName 和 lastName 属性的 Person 对象。当我们使用 new 关键字调用 Person 构造函数时，this 关键字会指向新创建的 Person 对象，因此函数中的 this.firstName 和 this.lastName 都会被设置为新创建的对象的属性值。\r\n\r\n总之，JavaScript 中的 this 关键字是一个非常重要的概念，它的值取决于函数的调用方式，可以用于访问当前对象的属性和方法，也可以用于创建新的对象。在不同的场景中，需要根据具体情况来使用 this 关键字，以确保程序的正确性和可维护性。\r\n\r\n在 JavaScript 中，事件处理程序中的 this 关键字通常指向触发事件的元素。例如，当用户点击一个按钮时，按钮的 click 事件处理程序中的 this 关键字将指向该按钮元素。\r\n\r\n举个例子：\r\n\r\n```html\r\n<button id=\"myButton\">点击我</button>\r\n\r\n<script>\r\ndocument.getElementById(\"myButton\").addEventListener(\"click\", function() {\r\n  console.log(this); // 输出按钮元素\r\n});\r\n</script>\r\n```\r\n\r\n在这个例子中，我们使用 addEventListener()方法将一个 click 事件处理程序绑定到按钮元素上。当用户点击按钮时，该事件处理程序将被触发，此时 this 关键字将指向按钮元素，因此在函数中输出 this 将返回按钮元素。\r\n\r\n需要注意的是，如果事件处理程序使用箭头函数定义，则 this 关键字将不指向当前元素，而是指向定义该函数时的执行上下文。例如：\r\n\r\n```html\r\n<button id=\"myButton\">点击我</button>\r\n\r\n<script>\r\ndocument.getElementById(\"myButton\").addEventListener(\"click\", () => {\r\n  console.log(this); // 输出全局对象\r\n});\r\n</script>\r\n```\r\n\r\n在这个例子中，我们使用箭头函数定义 click 事件处理程序。由于箭头函数没有自己的 this 值，因此在事件处理程序中使用箭头函数定义时，this 关键字将不指向当前元素，而是指向定义该函数时的执行上下文。在这个例子中，事件处理程序中的 this 关键字将指向全局对象，因此在函数中输出 this 将返回全局对象。\r\n\r\n如果需要在事件处理程序中访问当前元素，可以使用 event.target 属性来获取当前触发事件的元素。例如：\r\n\r\n```html\r\n<button id=\"myButton\">点击我</button>\r\n\r\n<script>\r\ndocument.getElementById(\"myButton\").addEventListener(\"click\", function(event) {\r\n  console.log(event.target); // 输出按钮元素\r\n});\r\n</script>\r\n```\r\n\r\n在这个例子中，我们在 click 事件处理程序中使用 event.target 属性来获取当前触发事件的元素，因此在函数中输出 event.target 将返回按钮元素。\r\n\r\n总之，事件处理程序中的 this 关键字通常指向触发事件的元素，但如果使用箭头函数定义事件处理程序，则 this 关键字将指向定义该函数时的执行上下文。如果需要在事件处理程序中访问当前元素，可以使用 event.target 属性来获取当前触发事件的元素。","type":"text/markdown","created":"20230529051917713","creator":"oeyoews","modified":"20230726045248780","modifier":"oeyoews","tags":"JavaScript"},{"title":"thoughts","text":"<$echarts $tiddler=\"addon/tagpie.js\" filter=\"[tag[thoughts]]\"/>","type":"text/markdown","created":"20231011081529001","creator":"Lenovo","modified":"20231011081634068","modifier":"Lenovo","tags":""},{"title":"three-pig","text":"# 三只小猪\r\n\r\n## 题目背景\r\n\r\n你听说过三只小猪的故事吗？这是一个经典的故事。很久很久以前，有三只小猪。第一只小猪用稻草建的房子，第二个小猪用木棍建的房子，第三个小猪则使用砖做为材料。一只大灰狼想吃掉它们并吹倒了稻草和木棍建的房子。但是砖盖的房子很结实，狼最终也没有破坏掉，最后小猪们战胜了大灰狼并把它尾巴烧掉了。\r\n\r\n## 题目描述\r\n\r\n为了自己的安全，小猪们又建造了一个新砖房。但是现在问题出现了，怎样把三个小猪分配到两个房子里呢？第三只小猪是三只小猪中最聪明的一只，为了不浪费任何一个房子，它总共考虑了三种方案，如下图\r\n\r\n ![](https://cdn.luogu.com.cn/upload/pic/6862.png) \r\n\r\n“但是将来怎么办呢？”第三只小猪知道将来随着成员的增多，它们将会盖更多的房子。它想知道给定了房子和猪的数目后，房子的分配方案有多少，但这个问题对于它来说，很明显有点难了，你能帮小猪解决这个问题吗？\r\n\r\n## 输入格式\r\n\r\n输入文件 piggy.in，仅有一行，包含两个整数 n 和 m，分别表示小猪的数目和房间数（1≤n≤50，0≤m≤50）。\r\n\r\n## 输出格式\r\n\r\n输出文件 piggy.out，仅一个整数，表示将 n 只小猪安置在 m 个房间且没有房间空闲的方案数。\r\n\r\n## 样例 #1\r\n\r\n### 样例输入 #1\r\n\r\n```plain\r\n4 2\r\n```\r\n\r\n### 样例输出 #1\r\n\r\n```plain\r\n7\r\n```\r\n\r\n## 样例 #2\r\n\r\n### 样例输入 #2\r\n\r\n```plain\r\n6 7\r\n```\r\n\r\n### 样例输出 #2\r\n\r\n```plain\r\n0\r\n```\r\n\r\n## 题目分析\r\n\r\n可以令$f[i][j]$表示将$i$只小猪分配到$j$个房间里且至少有一个房间空闲的方案数。那么，$f[i][j]$可以通过以下方式计算得出：\r\n\r\n1. 将$i$只小猪分配到$j-1$个房间里，然后从这$j-1$个房间中选择一个房间，将多余的小猪放入这个房间中。这种情况下，有$f[i][j-1]$种方案。\r\n\r\n2. 将$i$只小猪分配到$j-2$个房间里，然后从这$j-2$个房间中选择两个房间，将多余的小猪放入这两个房间中。这种情况下，有$C_{j}^{2}\\times f[i][j-2]$种方案。\r\n\r\n3. ...\r\n\r\n依此类推，我们可以得到以下的递推式：\r\n\r\n$$f[i][j] = \\sum_{k=1}^{j}(-1)^{k+1}C_{j}^{k}\\times (j-k)^{i}$$\r\n\r\n最终，我们需要计算将$n$只小猪分配到$m$个房间里且没有房间空闲的方案数。这个问题可以通过容斥原理来解决，即：\r\n\r\n$$ans = \\sum_{i=1}^{m}(-1)^{i+1}C_{m}^{i}\\times f[n][i]$$\r\n\r\n其中，$ans$表示最终的答案。\r\n\r\n## Python 实现\r\n\r\n```python\r\ndef work(n, m):\r\n    # 初始化一个二维数组，用于记录每种情况下放球的方案数\r\n    f = [[0 for i in range(300)] for i in range(300)]\r\n    \r\n    # 对于只有一个盒子的情况，放置 n 个球只有一种方案\r\n    for i in range(1, n + 1):\r\n        f[i][1] = 1\r\n    \r\n    # 对于多个盒子的情况，使用动态规划求解\r\n    for i in range(2, n + 1):\r\n        for j in range(2, m + 1):\r\n            # 状态转移方程：f[i][j] = f[i - 1][j - 1] + j * f[i - 1][j]\r\n            # 左边的表达式表示 i 个球放到 j 个盒子中的方案数\r\n            # 右边第一部分 f[i - 1][j - 1] 表示将 i-1 个球放在 j-1 个盒子里再加上第 i 个球单独放到一个新盒子中的方案数\r\n            # 右边第二部分 j * f[i - 1][j] 表示将第 i 个球放到 j 个盒子中的方案，即前 i-1 个球任意放在 j 个盒子中（共有 f[i - 1][j] 种情况），再将第 i 个球放入任意一个盒子（共有 j 种情况）\r\n            f[i][j] = f[i - 1][j - 1] + j * f[i - 1][j]\r\n    \r\n    # 返回放置 n 个球到 m 个盒子中的方案数\r\n    return f[n][m]\r\n\r\n\r\ndef main():\r\n    # 从控制台读取两个字符串参数，并转换为整型\r\n    s = input().split()\r\n    n, m = int(s[0]), int(s[1])\r\n    \r\n    # 调用 work 函数计算结果并输出到控制台\r\n    print(work(n, m))\r\n\r\n# 程序入口\r\nif __name__ == '__main__':\r\n    main()\r\n```\r\n\r\n函数 work(n, m) 通过动态规划求解出将 n 个球放入 m 个盒子中的方案数。具体地，使用 f[i][j] 表示将 i 个不同的球放入 j 个不同的盒子中，每个盒子至少有一个球的方案数。\r\n\r\n对于只有一个盒子的情况，显然有将 n 个球全部放入这一个盒子的方案，而其他情况可以使用递推计算。具体的，对于 f[i][j]，需要从 f[i-1][j-1] 和 f[i-1][j] 中计算得到，其中 f[i-1][j-1] 表示将 i-1 个球放在 j-1 个盒子里再加上第 i 个球单独放到一个新盒子中的方案数；f[i-1][j] 表示前 i-1 个球任意放在 j 个盒子中的方案数，再将第 i 个球放入任意一个盒子中（共有 j 种情况）。\r\n\r\n在主函数 main() 中，从控制台读取两个字符串参数，并转换为整型，然后调用 work 函数计算结果并输出到控制台。\r\n\r\n## C++ 实现\r\n\r\n```c++\r\n#include<iostream>\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<string>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\nint f[60][60][60]; // 使用三维数组 f 存放答案，f[i][j][0] 表示 f[i][j] 中位数的位置（即共有多少位数字）\r\n\r\nint _ans[60], _size; // 辅助数组 _ans 和 _size，用于计算高精度加法\r\n\r\nint n, m;\r\n\r\nvoid _change(int x, int y)\r\n{\r\n    if (y > x) return; // 当 y > x 时，无法进行分组放置，直接返回\r\n    if (x == 1 && y == 1) return; // 当 x == 1 && y == 1 时，只有一种情况，即将这个球放在这个盒子里\r\n\r\n    // 将 _ans 数组清零\r\n    for (int i = 1; i <= _size; i++)\r\n        _ans[i] = 0;\r\n    _size = 1;\r\n\r\n    int _x = 0;\r\n\r\n    // 将 f[x-1][y] 相应的位乘上 y，然后加上进位 _x，存入 _ans 数组中\r\n    for (int i = 1; i <= f[x - 1][y][0]; i++)\r\n    {\r\n        _ans[i] = f[x - 1][y][i] * y + _x;\r\n        _x = _ans[i] / 10;\r\n        _ans[i] %= 10;\r\n    }\r\n    _size = f[x - 1][y][0];\r\n\r\n    // 如果进位 _x 不为 0，将其存入 _ans 数组中\r\n    if (_x != 0)\r\n        _ans[++_size] = _x;\r\n\r\n    f[x][y][0] = 1;\r\n    _x = 0;\r\n\r\n    // 对于 f[x-1][y-1] 和 _ans 数组的每一位，进行高精度加法\r\n    while (f[x][y][0] <= f[x - 1][y - 1][0] || f[x][y][0] <= _size)\r\n    {\r\n        f[x][y][f[x][y][0]] = f[x - 1][y - 1][f[x][y][0]] + _ans[f[x][y][0]] + _x;\r\n        _x = f[x][y][f[x][y][0]] / 10;\r\n        f[x][y][f[x][y][0]] %= 10;\r\n        f[x][y][0]++;\r\n    }\r\n\r\n    // 将最后一次的进位存入 f[x][y] 数组中\r\n    f[x][y][f[x][y][0]] = _x;\r\n\r\n    // 如果最高位是 0，同时不是只有一位数，那么将其删除\r\n    if (f[x][y][f[x][y][0]] == 0 && f[x][y][0] > 1)\r\n        f[x][y][0]--;\r\n}\r\n\r\nint main()\r\n{\r\n    scanf(\"%d%d\", &n, &m);\r\n\r\n    // 特判当 m > n 时，无法进行分组放置，直接输出 0\r\n    if (m > n)\r\n    {\r\n        cout << 0;\r\n        return 0;\r\n    }\r\n\r\n    // 当只有一个盒子或一个球时，方案数都是 1\r\n    f[1][1][0] = 1;\r\n    f[1][1][1] = 1;\r\n\r\n    // 对于每个球 i，枚举放在哪个盒子 j 中\r\n    for (int i = 2; i <= n; i++)\r\n        for (int j = 1; j <= min(i, m); j++)\r\n            _change(i, j);\r\n\r\n    // 如果最后得到的结果为 0，说明无法分组放置，直接输出 0\r\n    if (f[n][m][0] == 1 && f[n][m][1] == 0)\r\n    {\r\n        cout << 0;\r\n        return 0;\r\n    }\r\n\r\n    // 将 f[n][m] 数组中存放的数字倒序输出\r\n    for (int i = f[n][m][0]; i >= 1; i--)\r\n        printf(\"%d\", f[n][m][i]);\r\n}\r\n```\r\n\r\n在此代码中，使用了三维数组 f 存储计算结果，其中 f[i][j][0] 表示 f[i][j] 中位数的位置（即由多少位数字组成）。对于一个球 i，将其依次放入 j 个盒子中，使用辅助数组 _ans 和 _size 计算高精度加法，将 f[i-1][j-1][k] 和 _ans[k] 相加，并将进位存入 _x 中，然后将相加的结果存入 f[i][j][k] 中。在计算过程中，如果某个位置 k 超出当前数组存储的位数范围，则认为这一位数字为 0。\r\n\r\n在主函数 main() 中，读入两个整型参数 n 和 m，特判当 m > n 时输出 0。接着，依次枚举所有球和盒子的组合方式，调用辅助函数 _change(i, j) 计算方案数。最后，将得到的结果倒序输出即可。\r\n\r\n需要注意的是，在进行高精度加法时，应该先将 _ans 数组置零，避免多次加法产生错误。同时，在将数字存入 f 数组中时，可以先对其取模再记录进位，并将次高位与进位一起加入下一位的计算中，提高计算效率。","type":"text/markdown","created":"20230524140433277","creator":"oeyoews","modified":"20230726045248783","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&three-pig","publish":"public"},{"title":"throw-try-cache","text":"`throw`和`try...catch`是 JavaScript 中用于处理异常的两种不同机制。\r\n\r\n- `throw`关键字用于在代码中主动抛出异常。您可以使用`throw`关键字创建一个异常对象，并指定错误消息。抛出异常后，程序会立即停止执行当前代码块，并开始查找能够处理该异常的异常处理代码。如果没有找到合适的异常处理代码，程序将终止，并在控制台或浏览器中显示相应的错误消息。`throw`关键字用于主动引发异常，使得代码能够在错误或异常情况下中断正常的执行流程。\r\n\r\n- `try...catch`语句用于捕获和处理异常。您可以使用`try`块将可能抛出异常的代码包装起来，然后使用`catch`块来捕获和处理异常。如果`try`块中的代码抛出了异常，控制流会转到`catch`块，执行其中的代码来处理异常。`catch`块中可以访问异常对象，并根据需要进行处理。使用`try...catch`语句可以使得程序能够在遇到异常时进行适当的处理，而不会直接终止程序的执行。\r\n\r\n总结来说，`throw`关键字用于主动抛出异常，而`try...catch`语句用于捕获和处理异常。`throw`用于异常的产生，而`try...catch`用于异常的捕获和处理。它们是异常处理机制中的两个重要组成部分，可以帮助您编写更健壮和可靠的代码。","type":"text/markdown","created":"20230704055314327","creator":"oeyoews","modified":"20230726045248788","modifier":"oeyoews","tags":"JavaScript"},{"title":"tid-markdown","text":"* tw 的文档格式是以后缀名 tid（tw 里面管这种语法叫做 wikitext）的格式保存的，强烈依赖 wikitext 的语法来进行书写，比如 macro， widget 等语法；\n* 但是我们是用它来保存笔记的，使用 tid 的保存格式，在 tw 里面有很强的灵活性，但同时增加了笔记的记忆心智负担，tid 有一些特殊的语法，并且每个人都可以通过 macro 创建自己的独特写法，这打破了一致性，同时增加了复杂性；\n* wikitext 本质上来说就是 html 和 js 的简单封装，有点低代码的意思，让用户或者开发者较快（我认为不没有，需要不断看文档，有的地方确实不容易懂）写出想要的效果\n* 所以完全没有必要使用 tid 的必要对于普通用户来讲，他们完全不需要了解这些，保持认知上的简单性，就不会让用户觉得 tw 难以入门，否则用户会觉得 tw 会过于复杂，除非有一天用户自己觉得需要使用 wikitex 或者 macro 的写法，他们自然而然的就自己了解学习了，也就不会觉得什么复杂了，有需要再去学习，不用强加\n* 并且 md 对与各个支持 md 的笔记软件或者编辑器都是很友好的，可以说将迁移成本降低到了最小（虽然我认为 tw 是我的第一款也是最后一款笔记软件）\n\n> 在此强烈呼吁： \n\n* 不要使用 wikitext， 请使用 markdown\n* 不要使用 wikitext， 请使用 markdown\n* 不要使用 wikitext， 请使用 markdown\n\n关于 ob： 说实话到目前，我任然觉得 ob 和 typora 或者 marktext 仅仅是一款 md 编辑器，我看过有关于 ob 的一些文章，tw 和 ob 有个同样的的特点， 在没有配置的情况下，都一样的素，对就是不够美观的意思，我曾在不同的的时期多次下载过 ob， 尝试找到它不同于 typora 并且吸引我的特性，哪怕是一点（ob 确实有很多不错的特性，但是我都不是我很感兴趣的， 没有我看到 tw 第一眼就让我眼前一亮的感觉），是的我没有找到；相比于 ob 的插件开发（我对此毫无经验，仅仅知道 ob 又一个 plugin template repo）， 我更喜欢 tw 的开放性，tw 源码可以随时查阅","type":"text/markdown","created":"20231009130613723","creator":"Lenovo","modified":"20231009130624049","modifier":"Lenovo","tags":"markdown"},{"title":"tiddlyhost-bug","text":":::note\n如果你的密码输入错误, 不会得到任何错误提示\n:::\n\n:::bug\n如果网站名字更改, 不会像 github 进行自动重定向\n:::","type":"text/markdown","created":"20231011030948679","creator":"Lenovo","modified":"20231011031753365","modifier":"Lenovo","tags":""},{"title":"TiddlyWiki","text":":::info\n\"TiddlyWiki 是一款功能强大的个人知识管理和笔记工具，可以帮助用户创建、组织和共享信息。\"\n:::\n\n:::example TiddlyWiki5 🚀\n借助 TiddlyWiki5, 我几乎完成了所有关于笔记软件的需求, 也满足了所有关于博客网站的幻想, 可以算得上最后一个笔记软件了\n:::\n\n{{||tagTableTemplate}}","type":"text/markdown","created":"20230611095052116","creator":"oeyoews","modified":"20231018000952605","modifier":"Lenovo"},{"title":"tiddlywiki-bug","text":"`$:/xxxx` 这种文件右键打开, window 会将 $转义","type":"text/markdown","created":"20231014005033800","creator":"Lenovo","modified":"20231014005129797","modifier":"Lenovo","tags":"Bug TiddlyWiki"},{"title":"TiddlyWiki-seo","text":"tw 对于 seo 具有绝对不友好性, 除非构建成 static folder, 否则你写的文章搜索引擎是绝对收录不到的","type":"text/markdown","created":"20230925055321510","creator":"oeyoews","modified":"20230925055451470","modifier":"oeyoews","tags":"TiddlyWiki"},{"title":"tiddlywiki-starter-kit-docker-filestruct","text":"```bash\n📂 wiki(任意目录名字)\n   ├── 🐋 docker-compose.yml(docker compose 配置文件)\n   └── 📂 wiki(wiki目录, 名字由docker-compose.yml决定)\n       ├── 📂 files\n       ├── 🔒 subwiki(私密wiki)\n       ├── 📂 tiddlers(wiki内容)\n       └── 📦 tiddlywiki.info(系统配置信息)\n```","type":"text/markdown","created":"20231017023959440","creator":"Lenovo","modified":"20231017041607472","modifier":"Lenovo","tags":"TiddlyWiki"},{"title":"todo","text":":::todo\n这里是个人的待办事项, 不对外公开\n:::\n\n\n{{||tagTableTemplate}}","type":"text/markdown","created":"20230301074309929","creator":"oeyoews","modified":"20231018000853112","modifier":"Lenovo","tags":""},{"title":"translate-x-y","text":"在 CSS 中，`translate()`函数的坐标原点默认是元素的左上角（0,0）点。通过`translate()`函数的参数可以指定元素相对于原点的平移距离。\r\n\r\n例如，`translate(50px, 50px)`将元素向右平移 50 像素，向下平移 50 像素。\r\n\r\n在 Tailwind CSS 中，你可以使用`-translate-x`和`-translate-y`类来应用`translate()`函数的平移效果。\r\n\r\n```html\r\n<div class=\"transform -translate-x-2 -translate-y-2\">\r\n  <!-- 元素内容 -->\r\n</div>\r\n```\r\n\r\n在上述示例中，我们通过使用`-translate-x-2`和`-translate-y-2`类将元素向左和向上平移 2 个单位。\r\n\r\n你还可以使用`-translate-{value}`类，其中`{value}`可以是具体的像素值或使用 Tailwind CSS 的尺寸缩写（如`-translate-1/2`表示平移元素的一半宽度或高度）。\r\n\r\n注意，`translate()`函数的坐标原点是相对于元素本身的，而非相对于其父容器。如果你需要相对于父容器平移元素，可以使用相对定位或 flex 布局等方法。","type":"text/markdown","tags":"Tailwindcss"},{"title":"translink","text":"<<translink gallary>>","type":"text/markdown","created":"20230614155918502","creator":"oeyoews","modified":"20230726045248789","modifier":"oeyoews","tags":"TiddlyWiki"},{"title":"transparent-png","text":"https://retoucher.online/","type":"text/markdown","created":"20230914030205269","modified":"20230914030216749","tags":""},{"title":"ts-document-unoffical","text":"https://ts.xcatliu.com/","type":"text/markdown","created":"20230530124222069","creator":"oeyoews","modified":"20230726045248789","modifier":"oeyoews","tags":"TypeScript"},{"title":"ts-node-baseurl","text":"* https://typestrong.org/ts-node/docs/paths/\n\nts-node 需要特殊配置， baseurl\n\n> bun 直接运行 ts, 不需要这些坑\n\n```json\n\t\"ts-node\": {\n\t\t// Do not forget to `npm i -D tsconfig-paths`\n\t\t\"require\": [\n\t\t\t\"tsconfig-paths/register\"\n\t\t]\n\t}\n```","type":"text/markdown","created":"20231025132250257","creator":"Lenovo","modified":"20231025132403397","modifier":"Lenovo","tags":"TypeScript"},{"title":"ts-node-tsc","text":"你正在提到\"tsc\"和\"ts-node\"，它们是与 TypeScript 相关的工具。下面是它们的简要说明：\n\n1. **tsc**：这是 TypeScript 编译器的命令行工具。你可以使用它来将 TypeScript 代码编译成 JavaScript 代码。例如，你可以运行以下命令来编译一个 TypeScript 文件：\n\n   ```plain\n   tsc myfile.ts\n   ```\n\n   这将生成一个名为`myfile.js`的 JavaScript 文件。\n\n2. **ts-node**：这是一个 Node.js 运行时(TypeScript)的工具。它允许你直接运行 TypeScript 文件，而不需要事先编译成 JavaScript。你可以使用以下命令运行 TypeScript 文件：\n\n   ```plain\n   ts-node myfile.ts\n   ```\n\n   这将在 Node.js 环境中执行`myfile.ts`文件，而不需要手动编译成 JavaScript。\n\n这两个工具都对 TypeScript 开发者非常有用，tsc 用于编译项目，而 ts-node 用于快速运行 TypeScript 代码而不需要中间步骤。","type":"text/markdown","created":"20231021133046115","creator":"Lenovo","modified":"20231021133059624","modifier":"Lenovo","tags":"JavaScript"},{"title":"ts-private","text":"```ts\r\nclass Test {\r\n  constructor(private array: [], private compare: () => number) {}\r\n\t\r\n  log() {\r\n    const { length } = this.array;\r\n    this.compare();\r\n  }\r\n}\r\n```\r\n\r\nprivate 声明的变量参数,会自动保存为类的成员变量,无需手动赋值绑定\r\n\r\n在 TypeScript 中，`private`、`public` 和 `protected` 是用来限定类成员（属性和方法）的访问权限的修饰符。它们有以下含义：\r\n\r\n1. **private**：私有成员，只能在当前类的内部访问。外部无法访问私有成员，包括继承类也无法访问。\r\n\r\n2. **public**：公共成员，可以在任何地方被访问。默认情况下，类的成员是公共的，如果不明确指定修饰符，默认为 `public`。\r\n\r\n3. **protected**：受保护成员，可以在当前类及其子类中访问，但在类的实例外部无法访问。\r\n\r\n以下是使用这些修饰符的示例：\r\n\r\n```typescript\r\nclass MyClass {\r\n  private privateProp: number = 10;\r\n  public publicProp: string = \"Hello\";\r\n  protected protectedProp: boolean = true;\r\n\r\n  constructor() {\r\n    // 可以在类的内部访问私有、公共和受保护成员\r\n    console.log(this.privateProp);    // 私有成员，可访问\r\n    console.log(this.publicProp);     // 公共成员，可访问\r\n    console.log(this.protectedProp);  // 受保护成员，可访问\r\n  }\r\n}\r\n\r\nclass MySubClass extends MyClass {\r\n  constructor() {\r\n    super();\r\n    // 子类可以访问受保护成员\r\n    console.log(this.protectedProp);  // 受保护成员，可访问\r\n    // 无法访问私有成员，因为私有成员只能在声明它的类内部访问\r\n    // console.log(this.privateProp); // 编译错误\r\n  }\r\n}\r\n\r\nconst instance = new MyClass();\r\n// 在类的实例外部，只能访问公共成员\r\nconsole.log(instance.publicProp);    // 公共成员，可访问\r\n// 无法访问私有和受保护成员\r\n// console.log(instance.privateProp); // 编译错误\r\n// console.log(instance.protectedProp); // 编译错误\r\n```\r\n\r\n在上面的示例中，`privateProp` 是私有成员，只能在 `MyClass` 类内部访问，`publicProp` 是公共成员，可以在任何地方访问，`protectedProp` 是受保护成员，可以在 `MyClass` 及其子类中访问，但在实例外部无法访问。","type":"text/markdown","created":"20230827071421233","creator":"oeyoews","modified":"20230827071546896","modifier":"oeyoews","tags":"TypeScript"},{"title":"Tux","text":"Tux（一只企鹅）是 Linux 个标志。拿企鹅作为 Linux 标志是由林纳斯·托瓦兹提出个。\n\n大多数人相信，“Tux”只名字来源于 Torvalds UniX，而弗是因为伊看起来像是著了一件黑色小礼服（tuxedo）。","type":"text/markdown","created":"20231017060830311","creator":"Lenovo","modified":"20231017060841722","modifier":"Lenovo","tags":"名词"},{"title":"tv-freelinks","text":"```plain\r\n<$set name=\"tv-freelinks\" value={{$:/config/Freelinks/Enable}}>\r\n```\r\n\r\n* 上面的代码设置了一个 `tv-freelinks` 变量,  这是一个全局变量, 可以在 widget 里面通过 this.getVariable('tv-freelinks') 获得\r\n\r\n具体见 [[FreeLinks|$:/plugins/tiddlywiki/freelinks]]","type":"text/markdown","created":"20230611094342821","creator":"oeyoews","modified":"20230726045248790","modifier":"oeyoews","tags":"Plugins TiddlyWiki"},{"title":"tw--load","text":"tw --load 命令有 bug(单文件版本)\r\n\r\nreplace undefined","type":"text/markdown","created":"20230830115617711","creator":"oeyoews","modified":"20230830115702639","modifier":"oeyoews","tags":"TiddlyWiki"},{"title":"tw-bug","text":"5.3.1 又改了 css","type":"text/markdown","created":"20230905074959933","creator":"oeyoews","modified":"20230905075016947","modifier":"oeyoews","tags":""},{"title":"tw-time","text":"tw 如果只给一个 created, 是不会显示在 recent 里面的, 还需加一个 modified","type":"text/markdown","created":"20230908052337174","creator":"oeyoews","modified":"20230908052443356","modifier":"oeyoews","tags":"Plugins"},{"title":"TwEmoji","text":"Twemoji 是一个开源的项目，旨在为网络上的表情符号提供一套标准化的图像资源。它是由 Twitter 开发和维护的，目的是提供一种跨平台、一致性的表情符号图像集，使用户在各种设备和平台上能够显示和共享相同的表情符号。\r\n\r\nTwemoji 基于 Unicode 标准中定义的表情符号字符集。Unicode 是一种用于标准化和表示文本字符的编码标准，它为世界上几乎所有的文字系统提供了唯一的编码，包括表情符号。Twemoji 将 Unicode 中的表情符号字符映射到相应的图像文件，以便在网页、应用程序和操作系统中使用。\r\n\r\nTwemoji 的主要特点和优势包括：\r\n\r\n1. 跨平台支持：Twemoji 提供了一套统一的表情符号图像资源，适用于各种操作系统、浏览器和应用程序。无论你是在桌面、移动设备还是 Web 上使用，Twemoji 都可以确保你看到的表情符号与其他用户保持一致。\r\n\r\n2. 高质量图像：Twemoji 提供了精心设计的高质量表情符号图像，以便在各种显示设备上呈现清晰和细致的细节。这些图像符号经过细致制作，以尽可能准确地呈现原始的表情和情感。\r\n\r\n3. 不断更新：随着 Unicode 标准中表情符号字符集的扩展和更新，Twemoji 也随之更新和发布新的图像资源。这意味着你可以始终使用最新的表情符号，无论是新的表情符号还是修改过的设计。\r\n\r\n4. 开源和定制性：Twemoji 是一个开源项目，你可以自由地使用、修改和贡献代码。如果你希望自定义表情符号的外观或添加自定义符号，你可以通过 Twemoji 的开源代码进行修改。\r\n\r\n要在你的应用程序或网页中使用 Twemoji，你需要引入 Twemoji 的 JavaScript 库，并在需要显示表情符号的地方使用相应的 HTML 实体或 CSS 类来表示表情符号字符。然后，Twemoji 将自动将这些字符替换为相应的图像，使其在用户界面中显示。\r\n\r\n总的来说，Twemoji 是一个开源项目，为网络上的表情符号提供了一套统一的图像资源。通过 Twemoji，你可以确保在各种平台和设备上使用相同的表情符号，提供一致的用户体验。","type":"text/markdown","created":"20230611162055543","creator":"oeyoews","modified":"20230726045248790","modifier":"oeyoews"},{"title":"twitter-thoughts","text":"感觉 twitter 上的技术话题的推，都多多少少带有宣传的感觉，上面的消息几乎都是最新的, 但是也会容易像刷视频一样挺不下来, 暂时没时间刷推了","type":"text/markdown","created":"20231002121355229","creator":"oeyoews","modified":"20231002121751476","modifier":"oeyoews","tags":"twitter"},{"title":"Two-Sum","text":"```js\n/**\nName: two-sum\nOrder: 1\n\n* Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\nYou can return the answer in any order.\n你可以按任意顺序返回答案。\n\n算法的时间复杂度为O(n)，其中n为数组中元素的个数。使用哈希表来存储元素和下标的对应关系; \n**/\n\n// soulation 1\nvar twoSum = function(nums, target) {\n  const map = new Map(); // 创建一个空的哈希表\n  for (let i = 0; i < nums.length; i++) {\n    const diff = target - nums[i]; // 计算目标值与当前元素的差值\n    if (map.has(diff)) { // 在哈希表中查找是否存在值等于差值的元素\n      return [map.get(diff),i]; // 如果存在，则返回这两个元素的下标\n    }\n    map.set(nums[i], i); // 如果不存在，则将当前元素和下标存入哈希表中\n  }\n};\n\n// soulation 2\nfunction twoSum(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n  return [];\n}\n```","type":"text/markdown","created":"20230527151811742","creator":"oeyoews","modified":"20231018062637309","modifier":"Lenovo","tags":"LeetCode"},{"title":"Type-Asserting","text":"在 TypeScript 中，类型断言（Type Assertion）用于告诉编译器某个值的确切类型。它允许开发者在不改变变量的原始类型的情况下，指定变量应该被视为特定类型。\r\n\r\n有两种方式可以进行类型断言：\r\n\r\n1. 尖括号语法：\r\n```typescript\r\nlet value: any = \"Hello World\";\r\nlet length: number = (<string>value).length;\r\n\r\n// 在尖括号内指定类型，将 value 当做 string 类型对待\r\n```\r\n\r\n2. `as` 语法：\r\n```typescript\r\nlet value: any = \"Hello World\";\r\nlet length: number = (value as string).length;\r\n\r\n// 使用 as 关键字将 value 当做 string 类型对待\r\n```\r\n\r\n这两种语法的效果是相同的，只是语法风格有所不同。无论使用哪种方式，类型断言都是告诉编译器相信变量是特定类型，但并不会进行运行时的检查。因此，需要注意类型断言的使用时机，确保断言的类型是类型兼容的。\r\n\r\n需要注意的是，尽量减少类型断言的使用，因为过度使用类型断言可能会破坏类型安全性。只有当你确实知道某个值的类型，并且确定它与已知类型兼容时，才应该使用类型断言。","type":"text/markdown","created":"20230702113507022","creator":"oeyoews","modified":"20230726045248791","modifier":"oeyoews","tags":"TypeScript"},{"title":"typecho","text":"说来惭愧，看过两次 typecho，我都没成功部署过它，难道是因为我没学过 php？","type":"text/markdown","created":"20231009130505655","creator":"Lenovo","modified":"20231009130512236","modifier":"Lenovo","tags":""},{"title":"unicodes","text":"&laquo;  `&laquo;`\r\n\r\n&raquo;  `&raquo;`\r\n\r\n&middot; `&middot`\r\n\r\n&para; `&para;`\r\n\r\nhttps://www.w3schools.com/charsets/ref_html_entities_4.asp","type":"text/markdown","created":"20230624031534207","creator":"oeyoews","modified":"20230726045248792","modifier":"oeyoews"},{"title":"unsplash-example","text":"<$image source=\"https://images.unsplash.com/photo-1484399172022-72a90b12e3c1?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w0NTAyMTB8MHwxfHNlYXJjaHwyMXx8Z2lybHxlbnwwfDB8fHwxNjkzNDA1MzA0fDA&ixlib=rb-4.0.3&q=80&w=1080\" alt=\"Unsplash Image\" fancybox=\"yes\"/>","type":"text/markdown","created":"20230830142134459","creator":"oeyoews","modified":"20230831022455763","modifier":"oeyoews","tags":""},{"title":"update-noconfirm","text":"```bash\r\nsudo pacman -Syu --noconfirm\r\n```","type":"text/markdown","created":"20230930122025422","creator":"oeyoews","modified":"20230930122045391","modifier":"oeyoews","tags":""},{"title":"URLSearchParams","text":"`const params = new URLSearchParams();` 是创建一个新的 URLSearchParams 对象的代码。URLSearchParams 是一个内建的 JavaScript 对象，用于处理 URL 查询参数。\r\n\r\nURLSearchParams 对象提供了一种方便的方式来构建、解析和操作 URL 查询参数。您可以使用它来添加、获取、删除和迭代查询参数。\r\n\r\n以下是一些常见的 URLSearchParams 方法示例：\r\n\r\n- `append(name, value)`: 向 URLSearchParams 对象中添加一个新的查询参数。\r\n- `get(name)`: 获取指定名称的查询参数的值。\r\n- `delete(name)`: 删除指定名称的查询参数。\r\n- `toString()`: 将 URLSearchParams 对象转换为字符串，以便于在 URL 中使用。\r\n\r\n下面是一个使用 URLSearchParams 的示例：\r\n\r\n```javascript\r\nconst params = new URLSearchParams();\r\nparams.append(\"name\", \"John\");\r\nparams.append(\"age\", \"25\");\r\n\r\nconsole.log(params.get(\"name\")); // 输出: \"John\"\r\nconsole.log(params.toString()); // 输出: \"name=John&age=25\"\r\n\r\nparams.delete(\"age\");\r\nconsole.log(params.toString()); // 输出: \"name=John\"\r\n```\r\n\r\n在这个示例中，我们首先创建了一个空的 URLSearchParams 对象，然后使用 `append` 方法添加了两个查询参数：`name` 和 `age`。我们可以使用 `get` 方法获取指定名称的查询参数的值，并使用 `toString` 方法将 URLSearchParams 对象转换为字符串，以便于在 URL 中使用。最后，我们使用 `delete` 方法删除了名为 `age` 的查询参数。\r\n\r\nURLSearchParams 对象在处理 URL 查询参数时非常有用，使得操作和处理查询参数变得更加简单和方便。","type":"text/markdown","created":"20230704055911310","creator":"oeyoews","modified":"20230726045248794","modifier":"oeyoews","tags":"JavaScript"},{"title":"use-dirname-on-esmodule","text":"```js\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n```\n","type":"text/markdown","created":"20231023081613601","creator":"Lenovo","modified":"20231023081839942","modifier":"Lenovo","tags":"HTML"},{"title":"use-github-cli","text":"   plain gh repo clone oeyoews/oeyoews demo-oeyoews -- --depth 1\r\n\t\t\r\n\t\tgplainplainplainplainplainplainplainh auth login","type":"text/markdown","created":"20230407045459273","creator":"oeyoews","modified":"20230726045248795","modifier":"oeyoews"},{"title":"use-journalctl-search","text":"```bash\r\njournalctl --since \"2023-10-02 21:46:00\"\r\n```","type":"text/markdown","created":"20231002135618788","creator":"oeyoews","modified":"20231002135652018","modifier":"oeyoews","tags":"gnome"},{"title":"use-latest-tiddlywiki","text":"> if you want to use latest tiddlywiki, you can use this command, instead of `npm install tiddlywiki`\n\n```shell\nnpm install github:oeyoews/TiddlyWiki5#commitid\n```\n\n:::bug\npnpm 总是弹窗警告, 在 github.dev 环境下就没有这个问题\n:::\n\n:::note editor\n虽然焦点不丢失了, 但是 vim 的 undo 还是失效\n:::","type":"text/markdown","created":"20230221081547068","creator":"oeyoews","modified":"20231009163230176","modifier":"Lenovo","publish":"article","tags":""},{"title":"use-neotw-with-docker","text":"* 随着 neotw 的稳定, 开始将 neotw 导报成 docker 进行使用,  不用每次关心太多的目录","type":"text/markdown","created":"20230912081844482","creator":"Lenovo","modified":"20231018062306785","modifier":"Lenovo","tags":"docs"},{"title":"use-patch-package","text":"use patch-package 打补丁也有点麻烦","type":"text/markdown","created":"20230915034338993","modified":"20230915034403798","tags":""},{"title":"use-ref-state","text":"`useState`和`useRef`是 React 中两个不同的 Hook 函数，它们有不同的用途和区别。\r\n\r\n1. `useState`用于在函数组件中创建和管理状态。它返回一个包含当前状态值和一个用于更新状态的函数的数组。每当状态更新时，React 会重新渲染组件。\r\n\r\n```javascript\r\nimport React, { useState } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const [count, setCount] = useState(0);\r\n  \r\n  const handleIncrement = () => {\r\n    setCount(count + 1);\r\n  };\r\n  \r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <button onClick={handleIncrement}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n在上面的例子中，我们使用`useState`创建了一个名为`count`的状态变量，并将其初始值设置为 0。我们还使用`setCount`函数来更新`count`的值。每当按钮被点击时，`count`的值会增加 1，并且组件会重新渲染。\r\n\r\n2. `useRef`用于在函数组件中创建可变的引用。Ref 对象在整个组件的生命周期中保持不变。它不能直接触发组件的重新渲染。\r\n\r\n```javascript\r\nimport React, { useRef, useEffect } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const inputRef = useRef(null);\r\n  \r\n  useEffect(() => {\r\n    inputRef.current.focus();\r\n  }, []);\r\n  \r\n  return (\r\n    <input ref={inputRef} type=\"text\" />\r\n  );\r\n}\r\n```\r\n\r\n在上面的例子中，我们使用`useRef`创建了一个名为`inputRef`的引用。我们将`inputRef`赋值给`<input>`元素的`ref`属性，以便可以在组件中引用该 DOM 元素。我们还使用`useEffect`钩子来确保在组件挂载后，将焦点设置在`<input>`元素上。\r\n\r\n总结：\r\n\r\n- `useState`用于创建和管理状态，每当状态更新时，组件会重新渲染。\r\n- `useRef`用于创建可变的引用，它在整个组件的生命周期中保持不变，不能直接触发组件的重新渲染。它通常用于访问 DOM 元素、存储组件中的可变值或在函数组件之间共享数据。","type":"text/markdown","tags":"React"},{"title":"use-rss","text":"原来 <$iconify icon=\"simple-icons:rss\" /> 用起来这么爽.\n\n:::todo\n使用 Rss 可以做很多事情， 订阅各个平台的更新， <$iconify icon=\"logos:youtube\" /> 视频的更新， 音乐更新，省去了打开软件的麻烦， 提高效率， 正在摸索相关工作流\n:::\n\n## Why Rss\n\n* 原因有很多，大概是因为 Rss 给了我一种安静的感觉吧\n\n## Backup\n\n* use opml file format\n\n## Rsshub\n\n* https://docs.rsshub.app/\n\n## Apps\n\n* dinorss\n* https://rss.cafe\n* https://www.qireader.com.cn/(mirror)\n* fluent reader(app)\n* netnewswire\n* feeder.co\n* feedbro\n* desktop: rssowl\n* inoreader\n* briefcake(email)\n* feedly.com\n* newblur\n* ego reader(格式似乎有问题)\n* unread\n* newsflash\n* http://webfollow.cc/welcome\n\n\n## Q&A\n\n* 使用过程中发现软件似乎对 rss 源的刷新有一个限制， 并且不会被手动刷新影响（以后再研究吧）, 现在使用 rss 的人确实不多了\n\n<hr>\n\nAtom、JSON Feed 和 RSS 都是用于以标准化方式发布 Web 内容的格式。\n\nAtom 是一种广泛使用的网络提要格式，用于分发经常更新的内容，例如博客文章、新闻文章或播客。它是一种基于 XML 的格式，最初是作为 RSS 的替代品开发的。\n\nJSON Feed 是一种基于 JSON 数据格式的网络订阅源的较新格式。它是为了应对 RSS 和 Atom 的一些限制而创建的，例如缺乏对图像和其他媒体类型的支持。JSON Feed 旨在易于阅读和编写，并且支持广泛的用例。\n\nRSS（Really Simple Syndication）是一种较旧的网络订阅源格式，在早期的博客和内容联合中广泛使用。它是一种基于 XML 的格式，至今仍在使用，尽管它已在很大程度上被 Atom 和 JSON Feed 取代。RSS 提要可用于分发范围广泛的内容，包括博客文章、新闻文章、播客和视频。\n\n综上所述，Atom、JSON Feed、RSS 都是一种标准化的 Web 内容发布格式，只是底层技术不同，支持的特性不同。Atom 是一种基于 XML 的格式，广泛用于 Web 提要，而 JSON Feed 是一种基于 JSON 的较新格式，旨在易于读写。RSS 是一种仍在使用的旧格式，但在很大程度上已被 Atom 和 JSON Feed 取代。\n\n## Links\n\n* https://www.ruanyifeng.com/blog/2006/01/rss.html\n* https://zhuanlan.zhihu.com/p/133452043\n* https://zhuanlan.zhihu.com/p/395100455\n\n## Subscribe Github\n\n```plain\n/* Repo releases */\n\nhttps://github.com/:owner/:repo/releases.atom\n\n/* Repo commits */\n\nhttps://github.com/:owner/:repo/commits.atom\n\n/* Private feed (You can find Subscribe to your news feed in dashboard page after login) */\n\nhttps://github.com/:user.private.atom?token=:secret\n\n/* Repo tags */\n\nhttps://github.com/:user/:repo/tags.atom\n\n/* User activity */\n\nhttps://github.com/:user.atom\n```\n\n* https://ronalds.eu/2020/03/26/rss-feeds-for-your-github-releases-tags-and-activity/\n\n* rsshub 提供一些 rss 源\n* deploy: https://docs.rsshub.app/install/#bu-shu-dao-vercel-zeit-now\n* https://chrome.google.com/webstore/detail/web-monitor/fipadnnmmoiomfllhbbnhjnghopkgfpb?utm_source=official\n\n## <$iconify icon=\"logos:notion\" />\n\n* use notionfeed\n\n## Atom template\n\n* https://github.com/Alinshans/alinshans.github.io/blob/master/atom.xml\n* https://feedburner.google.com/\n\n## Links\n\n* https://feedx.net/","type":"text/markdown","created":"20230329095532069","creator":"oeyoews","modified":"20231018143052455","modifier":"Lenovo","publish":"article","summary":"use rss records"},{"title":"use-strict","text":"\"use strict\" 是 JavaScript 中的一个指令，用于指定在严格模式下执行代码。严格模式是一种更加限制性的代码执行环境，它会强制执行更严格的规则和最佳实践，以帮助开发人员避免一些常见的错误和不安全的行为。\r\n\r\n当使用 \"use strict\" 时，JavaScript 引擎会对代码进行更严格的解析和错误检查，一些原本被视为合法的代码行为将会受到限制或禁止。\r\n\r\n\"use strict\" 可以在全局作用域中使用，也可以放在函数体的开头，以指定在函数内部启用严格模式。\r\n\r\n严格模式下的一些特点和限制包括：\r\n\r\n1. 变量必须声明后再使用：在严格模式下，对未声明的变量进行赋值操作将会引发错误。\r\n2. 禁止删除变量、函数和函数参数：在严格模式下，使用 `delete` 操作符删除变量、函数和函数参数将会引发错误。\r\n3. 禁止对只读属性赋值：在严格模式下，对只读属性进行赋值操作将会引发错误。\r\n4. 禁止使用未声明的变量：在严格模式下，对未声明的变量进行访问将会引发错误。\r\n5. 禁止使用八进制字面量：在严格模式下，以零开头的数字将被解析为八进制数值将会引发错误。\r\n6. 禁止使用 `this` 指向全局对象：在严格模式下，当函数没有明确的调用对象时，`this` 的值将会是 `undefined`，而不是指向全局对象。\r\n\r\n严格模式有助于提高代码的可靠性和安全性，推荐在 JavaScript 开发中使用它。","type":"text/markdown","created":"20230626031121112","creator":"oeyoews","modified":"20230726045248803","modifier":"oeyoews","tags":"JavaScript"},{"title":"use-tw-as-dataset","text":"tiddlyhost 会自动构建 tiddlers.json https://neotw.tiddlyhost.com/tiddlers.json?pretty, 具体参见 tiddlyhost github wiki;\n\n用户也可以在构建的时候同时构建这个 json 文件,并且上传到网站, 所以完全可以使用其他 blog 框架,拿到这个数据源重新进行展示\n\n\n:::warning\n* 不过要注意 tiddler 的纯度, markdown 一定要保证纯文本, 不要包含 macro, widget 或者一些扩展过的 markdown 语法\n* 当前这个网站输出的 tiddler.json 有将近 2M\n:::","type":"text/markdown","created":"20231011081435383","creator":"Lenovo","modified":"20231011115014600","modifier":"Lenovo","tags":"thoughts"},{"title":"useEffect-router","text":"是的，当路由发生变化时，`useEffect`也会触发。\r\n\r\n`useEffect`是 React 中的一个副作用钩子函数，它在组件渲染完成后执行。它接收两个参数：一个是要执行的回调函数，另一个是用于控制它何时执行的依赖数组。\r\n\r\n当依赖数组为空时，`useEffect`只会在组件首次渲染完成后执行一次。但是，如果依赖数组中包含了某些值，那么当这些值发生变化时，`useEffect`也会重新执行。\r\n\r\n当路由发生变化时，通常会导致组件重新渲染。因此，如果你将路由相关的值添加到`useEffect`的依赖数组中，那么每当路由发生变化时，`useEffect`都会触发。\r\n\r\n例如：\r\n\r\n```jsx\r\nimport React, { useEffect } from 'react';\r\nimport { useHistory } from 'react-router-dom';\r\n\r\nfunction MyComponent() {\r\n  const history = useHistory();\r\n\r\n  useEffect(() => {\r\n    console.log(\"Route changed!\");\r\n  }, [history.location.pathname]);\r\n\r\n  // 组件的其他代码...\r\n\r\n  return (\r\n    // 组件的 JSX...\r\n  );\r\n}\r\n\r\nexport default MyComponent;\r\n```\r\n\r\n在上面的示例中，当路由的路径名（`history.location.pathname`）发生变化时，`useEffect`回调函数会被调用，并打印出\"Route changed!\"的消息。这样，你可以在路由发生变化时执行一些逻辑或处理。","type":"text/markdown","tags":"React"},{"title":"useRef","text":"https://react.dev/reference/react/useRef","type":"text/markdown","created":"20230818093406367","creator":"oeyoews","modified":"20230818093420491","modifier":"oeyoews","tags":"React"},{"title":"usestate","text":"useState 和 let 都可以用于在 React 中保存状态，但它们有一些区别。\r\n\r\nuseState 是 React Hooks 中的一种钩子函数，它用于在函数式组件中保存和更新组件的状态。它的工作方式类似于类组件中的 state，但它是一个函数调用，而不是一个类属性。useState 函数接受一个初始状态值，并返回一个数组，数组包含两个元素：当前状态值和一个更新状态值的函数。使用这个函数可以触发组件的重新渲染，同时更新状态的值。由于 useState 是 React 内置的一种机制，因此它可以保证在更新状态时，React 能够自动地重新渲染组件，并尽可能地优化性能。\r\n\r\nlet 是 JavaScript 语言中的一种基本变量声明方式，它用于声明一个可变的变量，并赋给它一个初始值。使用 let 声明的变量，可以在后续的程序中被重新赋值，从而改变其所存储的数据。与 useState 不同，let 变量的生命周期和作用域都由程序员所控制，它并不具有“自动重新渲染”的特性。如果程序中使用 let 变量来保存组件的状态，那么需要手动地检测状态的更新，然后执行重新渲染的操作。通常情况下，这会导致代码变得更加复杂，且容易出错。\r\n\r\n因此，在 React 中推荐使用 useState 来保存组件的状态，而不是 let 变量。虽然 let 变量也可以达到同样的效果，但使用 useState 可以使代码更加清晰、简洁，并且能够享受 React 自动化渲染的好处。\r\n\r\n下面是 `useState` 和 `let` 变量的一些使用示例：\r\n\r\n## `useState` 的用例\r\n\r\n### 基本用法\r\n\r\n```jsx\r\nimport React, { useState } from 'react';\r\n\r\nfunction Counter() {\r\n  const [count, setCount] = useState(0); // 初始化计数器值为 0\r\n\r\n  return (\r\n    <div>\r\n      <p>你点击了 {count} 次</p>\r\n      <button onClick={() => setCount(count + 1)}>增加计数器</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n在这个例子中，我们使用 `useState` 钩子来保存一个计数器状态。初始值为 `0`，每次点击按钮时，通过调用 `setCount` 更新状态值，从而触发组件的重新渲染，并更新页面上的计数器。\r\n\r\n### 使用对象作为状态值\r\n\r\n```jsx\r\nimport React, { useState } from 'react';\r\n\r\nfunction UserInfo() {\r\n  const [user, setUser] = useState({ name: '', age: 0, address: '' }); // 初始化用户信息\r\n\r\n  const handleInputChange = (event) => {\r\n    const { name, value } = event.target;\r\n    setUser((prevUser) => ({\r\n      ...prevUser,\r\n      [name]: value,\r\n    }));\r\n  };\r\n\r\n  return (\r\n    <form>\r\n      <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} />\r\n      <input type=\"number\" name=\"age\" value={user.age} onChange={handleInputChange} />\r\n      <input type=\"text\" name=\"address\" value={user.address} onChange={handleInputChange} />\r\n    </form>\r\n  );\r\n}\r\n```\r\n\r\n在这个例子中，我们使用 `useState` 钩子来保存一个用户对象的状态，用户对象包含三个属性（名字、年龄和地址）。我们使用解构赋值和对象展开运算符来更新用户对象的某个属性。\r\n\r\n## `let` 变量的用例\r\n\r\n### 计数器的实现\r\n\r\n```jsx\r\nimport React, { useState } from 'react';\r\n\r\nfunction Counter() {\r\n  let count = 0; // 初始化计数器值为 0\r\n\r\n  const handleClick = () => {\r\n    count += 1;\r\n    console.log(`你点击了 ${count} 次`);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <p>你点击了 {count} 次</p>\r\n      <button onClick={handleClick}>增加计数器</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n在这个例子中，我们使用 `let` 变量来保存计数器的状态。每次点击按钮时，通过修改 `count` 变量的值，从而改变页面上计数器的显示。\r\n\r\n但是需要注意的是，在实际开发中，不推荐使用 `let` 来保存组件的状态，因为它会使代码变得混乱，且不便于维护。","type":"text/markdown","created":"20230428050536113","creator":"oeyoews","modified":"20230726045248804","modifier":"oeyoews","tags":"React"},{"title":"UX-DX","text":"UX 和 DX 都是缩写词，常用于描述软件或产品设计领域的概念。\r\n\r\nUX 代表用户体验（User Experience），是指用户在使用产品或服务时所感受到的整体体验，包括用户的情感、感觉和行为等方面。UX 设计旨在提高用户的满意度和忠诚度，通过优化用户体验来提高产品或服务的价值。\r\n\r\nDX 代表开发者体验（Developer Experience），是指开发者在开发软件或应用程序时所感受到的整体体验，包括使用的工具、开发环境、文档和支持等方面。DX 设计旨在提高开发者的效率和满意度，通过优化开发者体验来提高软件或应用程序的质量和可靠性。\r\n\r\n在软件或产品设计中，优秀的 UX 和 DX 设计都是非常重要的，因为它们能够提高用户和开发者的满意度，增加产品或服务的价值，同时也能够提高产品或应用程序的市场竞争力。","type":"text/markdown","created":"20230605122504151","creator":"oeyoews","modified":"20230726045248806","modifier":"oeyoews"},{"title":"v2raya-lite","text":"v2raya-lite.service not support manjaro\r\n\r\n```bash\r\nsystemctl --user enable --now v2raya-lite.service\r\n```","type":"text/markdown","created":"20231003025148671","creator":"oeyoews","modified":"20231003025239960","modifier":"oeyoews","tags":"v2raya"},{"title":"vanblog","text":"vanblog 使用 nextjs, nest.js tailwinddcss 等一系列微服务, 是一个不错的博客系统, 但是定制不容易改变, 比如如何在不使用评论系统的时候, 关闭服务(200M),","type":"text/markdown","created":"20230905061156656","creator":"oeyoews","modified":"20230905061326235","modifier":"oeyoews","tags":""},{"title":"vanilla-chatgpt","text":"https://github.com/casualwriter/vanilla-chatgpt","type":"text/markdown","created":"20230701120006927","creator":"oeyoews","modified":"20230726045248806","modifier":"oeyoews"},{"title":"vconsole-bug","text":"```bash\r\nlocalectl status \r\n\r\nsudoedit /etc/vconsole.conf \r\n\r\nloadkeys: Unable to open file: cn: 没有那个文件或目录 -> cn to en 即可\r\n```\r\n\r\n[[keymap|https://wiki.archlinux.org/title/Linux_console_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/Keyboard_configuration_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)]]\r\n\r\n```error\r\n× systemd-vconsole-setup.service - Virtual Console Setup\r\n     Loaded: loaded (/usr/lib/systemd/system/systemd-vconsole-setup.service; static)\r\n     Active: failed (Result: exit-code) since Tue 2023-10-03 16:33:05 CST; 4min 40s ago\r\n       Docs: man:systemd-vconsole-setup.service(8)\r\n             man:vconsole.conf(5)\r\n    Process: 465 ExecStart=/usr/lib/systemd/systemd-vconsole-setup (code=exited, status=1/FAILURE)\r\n   Main PID: 465 (code=exited, status=1/FAILURE)\r\n        CPU: 7ms\r\n\r\n10月 03 16:33:05 oeyoews systemd[1]: Starting Virtual Console Setup...\r\n10月 03 16:33:05 oeyoews systemd-vconsole-setup[494]: loadkeys: Unable to open file: cn: 没有那个文件或目录\r\n10月 03 16:33:05 oeyoews systemd-vconsole-setup[465]: /usr/bin/loadkeys failed with exit status 1.\r\n10月 03 16:33:05 oeyoews systemd[1]: systemd-vconsole-setup.service: Main process exited, code=exited, status=1/FAILURE\r\n10月 03 16:33:05 oeyoews systemd[1]: systemd-vconsole-setup.service: Failed with result 'exit-code'.\r\n10月 03 16:33:06 oeyoews systemd[1]: Failed to start Virtual Console Setup.\r\n```","type":"text/markdown","created":"20231003084321483","creator":"oeyoews","modified":"20231003085113504","modifier":"oeyoews","tags":"gnome"},{"title":"vercel-cron","text":"vercel 的 cron 如果成为正式版就是付费的功能, 而且 cron 只是支持 serverless, 不同于 github actions 的定时触发更新","type":"text/markdown","created":"20230830070831048","creator":"oeyoews","modified":"20230830070947062","modifier":"oeyoews","tags":""},{"title":"vercel-deploy-bug","text":"vercel deploy queue 的问题次数太多了","type":"text/markdown","created":"20231025235825103","creator":"Lenovo","modified":"20231025235854334","modifier":"Lenovo","tags":"Bug"},{"title":"vercel-task","text":"vercel 如果遇到连续提交好几个 commit,仅仅执行最后一次 task","type":"text/markdown","created":"20230906063804679","creator":"oeyoews","modified":"20230906063834782","modifier":"oeyoews","tags":""},{"title":"Videos","text":"<$echarts $tiddler=\"addon/tagpie.js\" filter=\"[tag[video]]\"/>\n<$cards filter=\"[tag[video]!sort[modified]]\" />","type":"text/markdown","created":"20230929145828117","creator":"oeyoews","modified":"20231011065524934","modifier":"Lenovo","page-icon":"logos:youtube-icon","tags":""},{"title":"view-text","text":"在 Taro 中，`View` 组件和 `Text` 组件是两个基础组件，被广泛地用于构建 React Native 应用程序的 UI。它们各自有不同的作用和特点。\r\n\r\n- `View` 组件：`View` 组件是一个容器组件，用于组织和布局其他子组件。类似于 HTML 中的 `div` 标签，`View` 组件没有具体的显示效果，只是一个透明的容器。在 Taro 中使用 `View` 组件可以方便地实现布局和组织结构，例如嵌套、定位和缩放等。与 HTML 的 `div` 标签不同的是，在 React Native 应用程序中，`View` 组件支持滚动和分页等功能，可以使您更轻松地创建复杂的用户界面。\r\n\r\n- `Text` 组件：`Text` 组件用于显示文本。类似于 HTML 中的 `span` 标签，`Text` 组件支持多种样式和排版属性，例如字体大小、颜色、行高、加粗、斜体等。在 Taro 中，使用 `Text` 组件可以方便地定义文本的样式和布局，从而创建更加美观的用户界面。\r\n\r\n总之，`View` 组件和 `Text` 组件是 Taro 中两个常用的基础组件，它们各自有不同的作用和特点。`View` 组件是一个容器，用于组织和布局其他子组件，而 `Text` 组件用于显示文本，并支持多种样式和排版属性。在 Taro 中使用这两个组件可以方便地创建美观、高效的 React Native 应用程序。","type":"text/markdown","created":"20230428062125021","creator":"oeyoews","modified":"20230726045248806","modifier":"oeyoews","tags":"Taro React"},{"title":"virtual-dom","text":"虚拟 DOM(Virtual Dom)就是一个 JS 对象(数组对象)，用来描述真实 DOM。相对通过 html 标签创建的真实 DOM，虚拟 DOM 是保存在客户端内存里的一份 JS 表述 DOM 的数组对象。\r\n\r\n虚拟 DOM 更新性能快的原因并不是因为在内存中(理论上任何软件都是运行在内存中)，而是因为虚拟 DOM 储存的数据格式为 JS 对象，用 JS 来操作(生成/查询/对比/更新)JS 对象很容易。用 JS 操作(生成/查询/对比/更新)真实 DOM 则需要调用 Web Action 层的 API，性能相对就慢。\r\n\r\nreact 运行(更新)步骤，大致为：\r\n\r\n* 定义组件数据变量\r\n* 定义组件模板 JSX\r\n* 数据与模板结合，生成一份虚拟 DOM\r\n* 将虚拟 DOM 转化为真实 DOM\r\n* 将得到的真实 DOM 挂载到 html 中(通过真实 DOM 操作)，用来显示\r\n* 监听变量发生改变，若有改变重新执行第 3 步(数据与模板结合，生成另外一份新的虚拟 DOM)\r\n* 在内存中对比前后两份虚拟 DOM，找出差异部分(diff 算法)\r\n* 将差异部分转化为真实的 DOM\r\n* 将差异化的真实 DOM，通过真实 DOM 操作进行更新\r\n\r\n[ref](https://github.com/puxiao/react-hook-tutorial/blob/master/%E9%99%8401%EF%BC%9AReact%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E5%8F%91-%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A)","type":"text/markdown","created":"20230428093139859","creator":"oeyoews","modified":"20230726045248808","modifier":"oeyoews","tags":"React"},{"title":"vscode-replace-regrep","text":"在 Visual Studio Code 中，您可以使用正则表达式进行替换操作。要将类似于 `**xxxxx**` 的内容替换为 `## xxxx`，可以按照以下步骤进行操作：\n\n1. 打开 Visual Studio Code。\n2. 使用快捷键 `Ctrl + H` 或者点击菜单栏中的 \"编辑\" -> \"查找和替换\"，打开查找和替换面板。\n3. 在查找框中输入正则表达式 `(\\*\\*)(.+?)(\\*\\*)`（不包括引号），这个正则表达式用于匹配 `**xxxxx**` 格式的内容。\n   - `\\*\\*` 表示匹配两个星号字符。\n   - `(.+?)` 表示匹配任意字符，并且使用非贪婪模式，以便在匹配到第二个星号之前停止。\n4. 在替换框中输入替换的内容 `## $2`（不包括引号），其中 `$2` 表示正则表达式中第二个括号捕获的内容。\n   - `##` 是替换后的固定文本。\n   - `$2` 表示正则表达式中第二个括号捕获的内容，即 `xxxxx`。\n5. 点击替换按钮（一个带有箭头的圆圈），或者使用快捷键 `Ctrl + Alt + Enter` 来执行替换操作。\n   - 如果您希望逐个替换，请点击替换单个按钮（一个箭头）或使用快捷键 `Ctrl + Enter`。\n   - 如果您希望替换所有匹配项，请点击替换全部按钮（两个箭头）或使用快捷键 `Ctrl + Alt + Enter`。\n\nVisual Studio Code 将会根据您提供的正则表达式，将所有符合条件的 `**xxxxx**` 替换为 `## xxxx`。请注意，这个操作是不可逆的，所以在进行替换之前，请确保您已经备份了相关文件。\n\n```plain\n^##[^\\u4e00-\\u9fa5a-zA-Z0-9\\s]+\n\n^## (\\*\\*)(.+?)(\\*\\*)\n\n## $2\n\n^(#+)\\s*(\\*+)(.+?)(\\*\\*)\n\n## $3\n\n^(#+)\\s*(\\\\\\*)+(.+?)\n\n\n^.*!\\[\\].*\\n?\n```\n\n在 VS Code 中，你可以使用正则表达式和替换功能来匹配并将多行空行转换为单行。下面是一个简单的步骤：\n\n1. 打开要进行替换操作的文件。\n2. 使用快捷键 `Ctrl + H`（Windows/Linux）或 `Command + H`（Mac）打开替换窗口。\n3. 在替换窗口中，点击右侧的正则表达式按钮（`.*`）以启用正则表达式模式。\n4. 在 \"查找\" 输入框中输入 `\\n\\s*\\n` 或者`\\n\\s{2,}\\n`，表示匹配连续的多个空行。\n   - `\\n` 表示匹配换行符。\n   - `\\s*` 表示匹配零个或多个空格字符。\n5. 在 \"替换为\" 输入框中输入 `\\n\\n`，表示将匹配到的多行空行替换为单个换行符。\n6. 点击 \"全部替换\"（Replace All）按钮，或使用快捷键 `Alt + Enter`（Windows/Linux）或 `Option + Enter`（Mac）执行替换操作。\n\n这样，所有的多行空行都会被替换为单行，并且文件中的空行数量得到了减少。","type":"text/markdown","created":"20231025024155830","creator":"Lenovo","modified":"20231026083402774","modifier":"Lenovo","tags":""},{"title":"web-sql","text":"**Web SQL** is a deprecated API that allowed web developers to interact with a client-side SQL database using JavaScript. It was a part of the HTML5 specification but was not widely adopted by browsers, and has since been superseded by newer technologies like IndexedDB. \r\n\r\nWeb SQL allowed developers to create, read, update and delete records in a structured query language (SQL) database within the browser. It was useful for web applications that needed to store large amounts of structured data and perform complex queries on that data. However, due to its limited support, it is not recommended to use Web SQL in modern web development projects.","type":"text/markdown","created":"20230415011452086","creator":"oeyoews","modified":"20230726045248809","modifier":"oeyoews"},{"title":"webpack","text":"Webpack 和 Babel 是两个常用的前端工具，通常会一起使用，下面对它们分别进行简单介绍。\r\n\r\n### Webpack\r\n\r\nWebpack 是一个模块打包工具，主要用于打包 JavaScript 文件，但也可以处理 CSS、图片等资源文件。它将多个文件打包成一个或多个 bundle 文件，以便在浏览器中使用。Webpack 最重要的功能是代码分割和生成 source map，这些都有助于提高应用程序性能并方便调试。此外，Webpack 还具有插件系统，可以通过插件实现代码压缩、文件拆分、语法检查等功能。\r\n\r\nWebpack 具有以下特点：\r\n\r\n- 模块化：支持 import 和 export 语法。\r\n- 动态加载：提供 import() 方法实现动态加载模块。\r\n- 插件机制：插件可以自定义 webpack 的行为。\r\n- 优化功能：支持 tree shaking、Scope Hoisting、Code Splitting 等优化功能。\r\n\r\n### Babel\r\n\r\nBabel 是一个 JavaScript 编译器，它可以将新版本的 ECMAScript 代码转换为兼容性更好的旧版代码，以便于在老旧的浏览器中运行。Babel 可以将 ES6/7/8 等新语法转换为 ES5 代码，也可以将 React 的 JSX 语法转换为普通的 JavaScript 代码，以便于在浏览器环境中运行。\r\n\r\nBabel 具有以下特点：\r\n\r\n- 插件架构：可以通过插件扩展，满足不同项目的需求。\r\n- 预设：包含一些常用的插件集，例如 babel-preset-env、babel-preset-react 等。\r\n- Polyfill：提供 polyfill 方案，以便在老旧浏览器中支持新 API。\r\n- 编译时转换：转换是在编译时进行的，而不是运行时，因此性能较好。\r\n\r\nWebpack 和 Babel 可以结合使用，Webpack 可以作为 Babel 的执行环境，Webpack 会在打包时调用 Babel 将 ES6 代码转换为 ES5 代码，以便浏览器支持。例如，在 Webpack 配置文件中，可以使用 babel-loader 加载器来处理 JavaScript 文件，这样就能够实现将 ES6 代码转换为 ES5 代码的功能。\r\n\r\n总之，Webpack 和 Babel 是前端开发的两个重要工具，主要用于代码打包和转换。如果需要使用新的 ECMAScript 语法或写 React 代码，那么 Babel 就是必不可少的工具；而在打包和优化工作中，Webpack 则是不可或缺的工具。","type":"text/markdown","created":"20230502054337665","creator":"oeyoews","modified":"20230726045248809","modifier":"oeyoews","tags":"JavaScript"},{"title":"webpack-alias","text":"在 Webpack 的配置文件中，__dirname 变量表示当前模块的绝对路径。如果您的 Webpack 配置文件位于项目根目录下，则 __dirname 的值就是项目根目录的绝对路径。例如，假设您的项目根目录为 /home/user/projects/my-app，则在 Webpack 配置文件中使用 __dirname 时，其值为 /home/user/projects/my-app。\r\n\r\n在上面的配置中，我们使用 path.resolve(__dirname, '..', 'src/components') 来定义 @/components 目录别名。其中，__dirname 表示 Webpack 配置文件所在的目录，.. 表示上一级目录，src/components 表示项目根目录下的 src/components 目录。\r\n\r\n使用 .. 是为了从当前目录（即 Webpack 配置文件所在的目录）向上一级目录（即项目根目录）导航，然后再进入 src/components 目录。这样可以确保我们定义的 @/components 目录别名指向了项目根目录下的 src/components 目录。\r\n\r\n在实际开发中，您可以根据项目的具体目录结构来调整 path.resolve() 方法的参数，以确保定义的目录别名指向正确的目录。","type":"text/markdown","created":"20230429161235671","creator":"oeyoews","modified":"20230726045248811","modifier":"oeyoews","tags":"React"},{"title":"whale-svg","text":"<svg stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" viewBox=\"0 0 512 512\" height=\"1em\" width=\"1em\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M388.81 85.863c-10.106.254-17.64 6.364-22.757 14.442-6.165-4.3-13.264-7.895-21.207-10.39-6.427-2.02-26.645 4.732-45.768 18.536 16.392 6.376 11.844 6.948 16.82 19.672-19.66-1.988-28.31-2.94-30.048-17.138-.314-1.5-.81-2.916-1.467-4.254-15.234 3.722-22.6 8.77-41.026 11.262-4.858 1.226 9.583-18.77 28.99-22.52-17.26-9.138-46.225-9.985-60.945-6.962-38.524 7.91-42.33 52.6-23.88 65.316 3.717-9.353 14.566-12.168 29.5-11.238-6.366 11.284-9.915 22.665-2.81 34.414 12.574-8.952 22.625-20.764 41.436-21.068 9.623 2.09 11.337 1.27 17.832-4.88l15.178 108 14.834-3.673-17.642-88.91s26.496 16.27 32.306 11.938c5.81-4.33 4.52-17.324 2.108-25.986 8.803-10.564 32.432 10.386 50.568 20.367 4.478 2.463 8.11 2.078 11.05.108 5.887 9.216 28.117 16.154 29.333 8.32-7.037-6.56-5.26-19.9-21.938-19.044 3.03-7.668 4.03-16.074 4.03-16.074.157-5.07-.863-10.5-2.957-15.952 4.736 4.108 12.537 8.33 17.173 11.89 13.703-7.19 31.292.545 35.612-7.997-12.8-13.524-33.406-21.83-50.864-15.343-3.113 1.157-4.855 2.447-5.567 3.826-2.825-4.944-6.51-9.768-10.996-14.203 3.144.37 7.633-.016 14.79-1.902 9.453-4.466 11.325-11 10.534-18.26-4.425-1.688-8.496-2.388-12.22-2.295zm-222.017 27.145c-12.067.374-20 12.273-24.922 24.664 8.988 1.977 24.257 1.042 30.202-7.024 4.057-5.503 4.395-16.866-2.81-17.558a19.48 19.48 0 0 0-2.47-.082zm5.135 30.133c-1.324-.01-3.125.28-5.475.854-9.398 2.297-10.538 15.336-11.94 24.58 5.744-4.33 14.544-9.105 18.26-16.855 2.788-5.814 3.125-8.546-.845-8.58zm-22.887 73.38c-11.094.18-46.64 9.46-55.977 17.11-2.352 1.925-6.47 11.213-8.688 11.042-3.068-.237-5.27-10.055-5.27-10.055-22.123-12.38-60.006-10.56-59.652-8.71.858 4.478 4.636 49.63 63.166 65.92 9.884 67.545 64.372 95.08 134.497 98.36-19.497 13.367-75.48 18.697-67.775 30.55 12.604 10.522 83.862 4.593 124.504-8.34 14.09-4.484 28.865-8.31 44.047-11.637 43.23 10.56 111.83 23.66 151.36 10.984 13.348-4.28 7.064-20.362 1.054-18.262-14.39 5.03-63.573 1.735-91.79-3.49 34.826-5.05 69.914-8.652 102.325-12.45 9.162-20.386 12.522-54.712 11.545-79.774-1.878-48.145-32-52.028-101.092-44.247-104.013 11.715-145.852 43.226-218.777 61.837-11.118 2.838-47.684-4.157-63.373-29.783 36.728-17.253 50.916-61.758 43.005-68.545-.44-.378-1.524-.536-3.11-.51zm220.81 141.173c-1.616 4.194-4.184 8.546-11.72 9.526-7.538.978-11.46-3.26-13.696-8.824 8.47 1.463 16.944 1.146 25.416-.703z\"></path></svg>","type":"text/markdown","created":"20230615134418982","creator":"oeyoews","modified":"20230726045248811","modifier":"oeyoews"},{"title":"What’s_Tailwind_Oxide_Engine__The_Next_Evolution_of_Tailwind_CSS","text":"[![Marek Bombera](https://miro.medium.com/v2/resize:fill:88:88/1*qwfc2GZ5r3n1fw88Hd15Dw.jpeg)](https://medium.com/@bomber.marek?source=post_page-----32e7ef8e19a1--------------------------------)\n\n![](https://miro.medium.com/v2/resize:fit:1050/1*yLDpP5bJTVWcoi_4UBJmGg.png)\n\nTailwind CSS, with its fast utility-first approach to styling, amazing design systems, and the ability to be consistent across projects and teams, has emerged as a game-changer in the web development space.Tailwind CSS 凭借其快速的实用程序优先的样式方法、令人惊叹的设计系统以及跨项目和团队保持一致的能力，已成为 Web 开发领域的游戏规则改变者。\n\nWith over 25 million downloads per month and brands like Shopify, OpenAI, Netflix, Nike, Mr. Beast’s Feastables, and many many more using it (more than 5 million of open-source projects on Github), its popularity is more than clear.每月下载量超过 2500 万次，Shopify，OpenAI，Netflix，Nike，Mr. Beast's Feastables 等品牌使用它（Github 上有超过 500 万个开源项目），它的受欢迎程度非常明显。\n\nBuilding on this foundation, [Adam Wathan](https://adamwathan.me/) and [Tailwind Labs](https://www.linkedin.com/company/tailwind-labs/) are now working on the Tailwind Oxide Engine, a significant evolution that simplifies the toolchain, boosts performance, and streamlines configuration.在此基础上，Adam Wathan 和 Tailwind Labs 现在正在研究 Tailwind Oxide Engine，这是一项重大演变，可简化工具链、提高性能并简化配置。\n\n**Table of Contents**: 目录\n\n· [Will Oxide break my app?](#a2f7)·氧化物会破坏我的应用程序吗？\\\n· [What is Tailwind Oxide Engine?](#bf00)·什么是顺风氧化物发动机？\\\n∘ [1) Unified toolchain](#3ed8)∘ 1） 统一工具链\\\n∘ [2) Oxide under the hood — ⚡ ️Lightning CSS](#16ba)∘ 2） 引擎盖下的氧化物 — ⚡ ️闪电 CSS\\\n∘ [3) Simplified Configuration](#ec3c)∘ 3） 简化配置\\\n· [Conclusion — The Impact of the Oxide Engine on Tailwind](#c318)·结论 — 氧化物发动机对顺风的影响\n\n## **Will Oxide break my app?氧化物会破坏我的应用程序吗？**\n\nShort answer: No, it will not.简短的回答：不，它不会。\n\nFirst of all, Oxide is not some new paradigm shift in how developers write Tailwind CSS but rather a set of upgrades to what’s going on under the hood.首先，Oxide 不是开发人员编写 Tailwind CSS 的新范式转变，而是对引擎盖下发生的事情的一系列升级。\n\nIt’s also worth mentioning that all these changes should be **backwards compatible** since that’s the team’s goal.还值得一提的是，所有这些更改都应该向后兼容，因为这是团队的目标。\n\n## **What is Tailwind Oxide Engine?什么是顺风氧化物发动机？**\n\nAs mentioned earlier, Oxide is designed to unify the toolchain, boost performance, and streamline configuration.如前所述，Oxide 旨在统一工具链、提高性能并简化配置。\n\nSo let’s start with the toolchain first.因此，让我们先从工具链开始。\n\n## 1) Unified toolchain 1） 统一工具链\n\nThe term “toolchain” refers to the set of software development tools used in combination to complete complex tasks.术语“工具链”是指组合用于完成复杂任务的一组软件开发工具。\n\nIn the context of Tailwind CSS, the toolchain includes dependencies like:在 Tailwind CSS 的上下文中，工具链包括以下依赖项：\n\n1. [**PostCSS**](https://postcss.org/): This is the foundation which Tailwind CSS is built upon. It transforms styles with JavaScript, allowing for features like variables, nesting, and mixins.PostCSS：这是 Tailwind CSS 的基础。它使用 JavaScript 转换样式，允许变量、嵌套和混合等功能。\n2. [**AutoPrefixer**](https://github.com/postcss/autoprefixer): A PostCSS plugin that automatically adds vendor prefixes CSS. This makes styles work across different browsers (even those that require specific prefixes for certain CSS features).AutoPrefixer：一个 PostCSS 插件，可以自动添加供应商前缀 CSS。这使得样式可以在不同的浏览器上工作（即使是那些需要某些 CSS 功能的特定前缀的浏览器）。\n3. [**PostCSS Import**](https://github.com/postcss/postcss-import): This plugin allows to use @import rules in CSS for a more modular CSS structure. These rules are then processed at build time.PostCSS 导入：此插件允许在 CSS 中使用@import 规则来实现更模块化的 CSS 结构。然后在生成时处理这些规则。\n4. [**PostCSS Preset Env**](https://github.com/csstools/postcss-preset-env): This plugin automatically adds necessary fallbacks for older browsers and handles compatibility issues.PostCSS 预设环境：此插件会自动为旧版浏览器添加必要的回退并处理兼容性问题。\n\nBut that means developers have to manage these dependencies and everything that comes with it themselves.但这意味着开发人员必须自己管理这些依赖项以及随之而来的所有内容。\n\nIn essence, Oxide integrates these functionalities by incorporating the logic of these separate tools into its own codebase. This allows Oxide to provide the same functionalities as these tools without requiring them as separate dependencies.从本质上讲，Oxide 将这些独立工具的逻辑合并到自己的代码库中来集成这些功能。这允许 Oxide 提供与这些工具相同的功能，而无需将它们作为单独的依赖项。\n\n## 2) Oxide under the hood — ⚡ ️Lightning CSS2） 引擎盖下的氧化物 — ⚡ ️闪电 CSS\n\nNow let’s look at how Oxide improves Tailwind’s performance.现在让我们看看 Oxide 如何提高 Tailwind 的性能。\n\nOxide is powered by a Rust-based CSS transformation tool called Lightning CSS, developed by the Parcel team. Essentially, Lightning CSS handles all the features that would typically require a separate PostCSS plugin.Oxide 由基于 Rust 的 CSS 转换工具（称为 Lightning CSS）提供支持，该工具由 Parcel 团队开发。从本质上讲，Lightning CSS 处理了通常需要单独 PostCSS 插件的所有功能。\n\nLightning CSS is super fast, outperforming comparable JavaScript-based tools by over 100 times and also does a better job at minifying which reduces the final .css file size even more as well.Lightning CSS 非常快，性能比同类基于 JavaScript 的工具高出 100 倍以上，并且在缩小方面也做得更好，从而进一步减小了最终.css 文件大小。\n\n![Lighting CSS performance chart](https://miro.medium.com/v2/resize:fit:1050/1*Il4X5gZ2aa082CN6Rk8kUQ.png)\n\nIt can process and minify 2.7 million lines of code per second on a single thread, but it’s leveraging Rust’s ability to use multithreading and parallelization to be **blazingly fast**.它可以在单个线程上每秒处理和缩小 270 万行代码，但它利用了 Rust 使用多线程和并行化的能力，速度非常快。\n\nOxide makes Tailwind more than 2x faster during build time than the current version.氧化物使 Tailwind 在构建期间比当前版本快 2 倍以上。\n\n![Chart comparing tailwind 3.3 and 3.4 build time](https://miro.medium.com/v2/resize:fit:1050/1*hjzq1BkdTUKlZ9FiyJ_Jsw.png)\n\nIn addition, Lightning CSS supports CSS modules, which locally scope classes, ids, @keyframes, CSS variables, and more. This feature is particularly useful in preventing unintended name clashes between different CSS files.此外，Lightning CSS 还支持 CSS 模块，这些模块在本地作用域类、id、@keyframes、CSS 变量等。此功能在防止不同 CSS 文件之间意外的名称冲突方面特别有用。\n\nLook at [**Lightning CSS**](https://lightningcss.dev/docs.html) docs if you want to learn more.如果您想了解更多信息，请查看 Lightning CSS 文档。\n\n## 3) Simplified Configuration3） 简化配置\n\nRight now, there are two config files that developers need to manage, and that’s `tailwind.config.js` and `postcss.config.js`.现在，开发人员需要管理两个配置文件，那就是 `tailwind.config.js` 和 `postcss.config.js` 。\n\nBut there is also the `app.css` file which is used for importing Tailwind's base, components, and utilities, adding custom styles or overrides, and with Oxide, defining your theme and fonts directly in your CSS.但是还有用于 `app.css` 导入 Tailwind 的基础，组件和实用程序，添加自定义样式或覆盖的文件，以及使用 Oxide 直接在 CSS 中定义主题和字体的文件。\n\nThe goal here is to make Tailwind CSS feel **native** so that you just install it, it works, and you go (or at least mitigate the configuration needed as much as possible).这里的目标是让 Tailwind CSS 感觉原生，这样你只需安装它，它就可以工作了，然后你就可以了（或者至少尽可能减轻所需的配置）。\n\nLet’s quickly look at app.css first since we will come back to it again a little later in conjunction with tailwind.config.js.让我们快速看一下 app.css 首先，因为我们稍后会结合 Tailwind.config.js 再次回到它。\n\n**— app.css — 应用.css**\n\nIn the app.css file you need to use directives like `@tailwind base;`, `@tailwind components;`, and `@tailwind utilities;` to import different parts of Tailwind CSS into your project.在 app.css 文件中，您需要使用 、 `@tailwind components;` 等 `@tailwind base;` 指令，并将 `@tailwind utilities;` Tailwind CSS 的不同部分导入到项目中。\n\n```plain\n \n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@import \"./fonts\" layer(base)\n```\n\nThat is now reduced only to 现在只减少到\n\n```plain\n \n@import 'tailwindcss';\n\n@import \"./fonts\" layer(base)\n```\n\nVery minor but nice quality of life change.非常小，但生活质量的变化很好。\n\nNow we’ll look at tailwind.config.js.现在我们来看看 tailwind.config.js。\n\n**— tailwind.config.js — 顺风配置.js**\n\n```plain\n\nmodule.exports = {\n  content: [\n    './src/app/**/*.{js,ts,jsx,tsx}',\n    './src/pages/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      fontFamily: {\n        sans: ['Roboto', 'sans-serif'],\n        monument: ['Monument', 'sans-serif'],\n      },\n      colors: {\n        primary: '#0D6EFD',\n        secondary: '#6D28D9',\n      },\n    },\n  },\n  plugins: [],\n}\n```\n\nOne of the most common, annoying, but very simple problem developers are running into is they are forgetting to update their **content array** in tailwind.config.js.开发人员遇到的最常见、最烦人但非常简单的问题之一是他们忘记在 tailwind.config.js 中更新他们的内容数组。\n\nThey then waste time debugging, trying to figure out why is the class not being applied when it’s there in the code.然后，他们浪费时间进行调试，试图找出为什么当类在代码中存在时没有应用该类。\n\nThe answer to this is **automatic content detection**.答案是自动内容检测。\n\nSince the engine is rewritten in Rust, it can do more work and way faster than it was possible before.由于引擎是用 Rust 重写的，它可以做更多的工作，并且比以前更快。\n\nThe team came up with some “smart algorithms” that can make educated guesses about where files are located based on existing files, their locations, and the extensions used.该团队提出了一些“智能算法”，可以根据现有文件、文件的位置和使用的扩展名对文件的位置进行有根据的猜测。\n\nThat means you can get rid of the content array completely.这意味着您可以完全摆脱内容数组。\n\n```plain\n\nmodule.exports = {\n  theme: {\n    extend: {\n      fontFamily: {\n        sans: ['Roboto', 'sans-serif'],\n        monument: ['Monument', 'sans-serif'],\n      },\n      colors: {\n        primary: '#0D6EFD',\n        secondary: '#6D28D9',\n      },\n    },\n  },\n  plugins: [],\n}\n```\n\nThe team is also **prototyping** and **experimenting** with CSS-based configuration (theme) in tailwind.config.js.该团队还在 tailwind.config.js 中对基于 CSS 的配置（theme）进行原型设计和试验。\n\nAgain the goal is to make Tailwind feel more native and right now we are wrapping these CSS values in Javascript and putting them in a config file.同样，我们的目标是让 Tailwind 感觉更原生，现在我们正在将这些 CSS 值包装在 Javascript 中并将它们放在配置文件中。\n\nWe basically have CSS where it shouldn’t be and overall have an awkward Javascript layer on top of it.我们基本上在不应该的地方有 CSS，并且总体上有一个尴尬的 Javascript 层。\n\nSo the idea is to get rid of `tailwind.config.js` completely and move all the stuff to** app.css**.所以这个想法是 `tailwind.config.js` 完全摆脱并将所有的东西移动到应用程序.css。\n\nSo in the future we will be able to do something like this 所以将来我们将能够做这样的事情\n\n```plain\n\n\n@import 'tailwindcss';\n\n@import \"./fonts\" layer(base)\n\n:root {\n  --font-family-sans: 'Roboto', 'sans-serif';\n  --font-family-monument: 'Monument', 'sans-serif';\n\n  --color-primary: #0D6EFD;\n  --color-secondary: #6D28D9;\n}\n```\n\nThis to me definitely feels like a way nicer developer experience since we don’t have this weird separation of CSS in some config file anymore and the code is exactly where I would be expecting it to be.对我来说，这绝对是一种更好的开发人员体验，因为我们在某些配置文件中不再有这种奇怪的 CSS 分离，而且代码正是我期望它的位置。\n\n**— postcss.config.js**\n\nHere the idea of feeling more native is the same and as we mentioned before Oxide integrates all postCSS plugins you could think of in itself.在这里，感觉更原生的想法是相同的，正如我们之前提到的，Oxide 集成了您自己可以想到的所有 postCSS 插件。\n\nThere are also some rules about the order of having these plugins in the config file because each plugin transforms the CSS code in a specific way, and the order of transformations can affect the final result.关于在配置文件中使用这些插件的顺序也有一些规则，因为每个插件都以特定的方式转换 CSS 代码，并且转换的顺序会影响最终结果。\n\nManaging that is just unnecessary **mental overhead** and is prone to errors.管理它只是不必要的精神开销，并且容易出错。\n\nThis is an example of how postcss.config.js could look like 这是 postcss.config.js 的示例。\n\n```plain\n\nmodule.exports = {\n  plugins: {\n    'postcss-import': {},\n    'postcss-css-variables': {},\n    'postcss-nested': {},\n    tailwindcss: {},\n    autoprefixer: {},\n    'postcss-preset-env': {},\n  },\n}\n```\n\nWell with Oxide all you’ll need and all you’ll have to worry about is this.有了氧化物，您所需要的只是这个。\n\n```plain\n\nmodule.exports = {\n  plugins: {\n    tailwindcss: {},\n  },\n}\n```\n\nBut the team is also apparently collaborating with some major frameworks and build tools (that’s all we know for now) to get Tailwind **detected** so that we don’t even need the postcss.config.js file.但是该团队显然也在与一些主要的框架和构建工具（这就是我们现在所知道的）合作，以检测 Tailwind，这样我们甚至不需要 postcss.config.js 文件。\n\n## Conclusion — The Impact of the Oxide Engine on Tailwind 结论 — 氧化物发动机对顺风的影响\n\nThe introduction of the Oxide Engine marks a significant milestone in the evolution of Tailwind CSS.Oxide Engine 的推出标志着 Tailwind CSS 发展的一个重要里程碑。\n\nBy enhancing the strengths of Tailwind and addressing some of its complexities, Oxide is set to make Tailwind a more powerful, efficient, and user-friendly tool for web developers.通过增强 Tailwind 的优势并解决其一些复杂性，Oxide 将使 Tailwind 成为 Web 开发人员更强大，高效和用户友好的工具。\n\nThe performance improvements brought about by the integration of Lightning CSS, coupled with the simplification of the development process through automatic content detection and CSS-based configuration, are poised to really enhance the Tailwind experience. These features not only streamline the development process but also make Tailwind more intuitive and accessible.Lightning CSS 集成带来的性能改进，加上通过自动内容检测和基于 CSS 的配置简化开发过程，有望真正增强 Tailwind 体验。这些功能不仅简化了开发过程，还使 Tailwind 更加直观和易于访问。\n\nMoreover, Oxide’s focus on making Tailwind feel more native to CSS brings Tailwind closer to the core of CSS development. This is a significant step towards integrating Tailwind more seamlessly into the web development process.此外，Oxide 专注于让 Tailwind 感觉更原生于 CSS，这使得 Tailwind 更接近 CSS 开发的核心。这是将 Tailwind 更无缝地集成到 Web 开发过程中的重要一步。\n\nOverall Oxide promises to enhance the efficiency of development cycles, simplify the development process, and make Tailwind a more integrated part of the web development toolkit. The future of Tailwind, powered by the Oxide Engine, looks promising and exciting for the web development community.总体而言，Oxide 有望提高开发周期的效率，简化开发过程，并使 Tailwind 成为 Web 开发工具包中集成性更强的一部分。由氧化物引擎驱动的 Tailwind 的未来对于 Web 开发社区来说看起来很有希望和令人兴奋。\n","type":"text/markdown","created":"20231022094715136","creator":"太微搜藏","modified":"20231022094747031","modifier":"Lenovo","tags":"剪藏 Tailwindcss","url":"https://medium.com/@bomber.marek/whats-tailwind-oxide-engine-the-next-evolution-of-tailwind-css-32e7ef8e19a1"},{"title":"when-to-use-reduce","text":"在某些特定情况下，使用 `reduce()` 方法可能更适合。以下是一些可能的情况：\n\n1. 累加操作：如果你需要对数组中的元素进行累加操作，例如计算总和、计算平均值或找到最大/最小值等，那么使用 `reduce()` 方法可以更直接地实现这些操作。\n\n2. 复杂的数据转换：如果你需要对数组中的元素进行复杂的转换操作，并且每次转换都依赖于前一次转换的结果，那么使用 `reduce()` 方法可以提供更灵活的处理方式。\n\n3. 自定义聚合操作：如果你需要进行自定义的聚合操作，而不仅仅是简单的过滤或映射，那么使用 `reduce()` 方法可以让你更好地控制聚合的逻辑。\n\n需要注意的是，在这些情况下，使用 `reduce()` 方法可能会比较适合，但也要考虑代码的可读性和维护性。如果使用 `reduce()` 方法导致代码变得复杂、难以理解，或者与团队内其他开发人员的编码习惯不一致，那么可以选择使用 `filter()` 和 `map()` 方法来保持代码的清晰性。","type":"text/markdown","created":"20231103081109138","creator":"Lenovo","modified":"20231103081123092","modifier":"Lenovo","tags":"JavaScript"},{"title":"Why_I_Won't_Use_Next.js","text":"You’ve got a new project to work on. Or you’ve got an existing project you’re motivated to upgrade to a more modern approach. Or perhaps you’re dissatisfied with your current modern framework or second-guessing yourself and you’re investigating alternatives. In any case, you’ve got a decision to make.你有一个新项目要处理。或者你有一个现有的项目，你有动力升级到更现代的方法。或者，也许你对当前的现代框架不满意，或者对自己进行了二次猜测，你正在研究替代方案。无论如何，你都必须做出决定。\n\nThere are lots of “modern” frameworks to choose from. Even if you’re not facing this choice right now, you may be trying to decide which framework to invest time learning to make yourself more marketable and productive in the future.有很多“现代”框架可供选择。即使你现在没有面临这个选择，你也可能试图决定投入时间学习哪个框架，以使自己在未来更有市场和生产力。\n\nI’ve been using Remix since it was first released in 2020. I loved it so much I joined the company a year later to help get the community going and 10 months later I left to work on EpicWeb.dev full time where I teach people what they need to know to build full stack applications. And Remix is a big part of that. Remix is a full stack web framework and strives to solve problems faced by people building web applications–much like Next.js.自 2020 年首次发布以来，我一直在使用 Remix。我非常喜欢它，一年后我加入了公司，帮助社区发展，10 个月后，我离开了全职工作 EpicWeb.dev 教人们构建全栈应用程序所需的知识。而 Remix 是其中的重要组成部分。Remix 是一个全栈 Web 框架，致力于解决构建 Web 应用程序的人面临的问题——就像 Next.js 一样。\n\nAs Next.js is an alternative to Remix, people ask me why I chose Remix instead of Next.js for the framework I use when teaching full stack development on EpicWeb.dev. These people are probably facing one of those scenarios I mentioned. So this post is for those people.由于 Next.js 是 Remix 的替代品，人们问我为什么选择 Remix 而不是 Next.js 因为我在 EpicWeb.dev 上教授全栈开发时使用的框架。这些人可能正面临我提到的其中一种情况。所以这篇文章是为这些人准备的。\n\nI like to focus most of my time and attention on the **positive side** of software development. I would much rather write a post titled “Why I Use Remix” and written about the things I love about Remix (I have already done this). But a lot of people have asked me specifically about Next.js and this post is for them.我喜欢把大部分时间和注意力集中在软件开发的积极方面。我宁愿写一篇题为“我为什么使用 Remix”的文章，并写下我喜欢 Remix 的事情（我已经这样做了）。但是很多人专门问我关于 Next.js 的问题，这篇文章就是为他们准备的。\n\nI’m not here to “bash on Next.js.” I’m just here to add an honest take of my personal perception and experience with Next.js. If you’d rather not hear negative things about Next.js, then I invite you to stop reading now, go outside, and touch some grass.我不是来“抨击 Next.js”的。我在这里只是为了诚实地表达我对 Next.js 的个人看法和体验。如果你不想听到关于 Next.js 的负面消息，那么我邀请你现在停止阅读，走出去，摸摸草。\n\nBefore I go on, I need to acknowledge the fact that you’re reading this on a site that’s built with Next.js (you can check in the browser console and you’ll find a global `__NEXT_DATA__` variable rather than a `__remixContext` one). This is because the [EpicWeb.dev](http://epicweb.dev/) site is built by [a team](https://www.epicweb.dev/credits) that has been building software with Next.js for years and they make their own decisions.在我继续之前，我需要承认这样一个事实，即您是在使用 Next.js 构建的网站上阅读本文（您可以在浏览器控制台中查看，您会发现一个全局 `__NEXT_DATA__` 变量而不是 `__remixContext` 一个变量）。这是因为 EpicWeb.dev 网站是由一个多年来一直使用 Next.js 构建软件的团队构建的，他们自己做出决定。\n\nThis actually gives me an opportunity to make another important point before we get started:这实际上给了我一个机会，在我们开始之前提出另一个重要的观点：\n\n**Whatever you use is probably fine.无论你使用什么，都可能没问题。**\n\nYour tool choice matters much less than your skill at using the tool to accomplish your desired outcome (a great user experience).您的工具选择远不如您使用工具实现预期结果（出色的用户体验）的技能重要。\n\nIn this post, I’m going to argue for why I won’t be using Next.js because I think Remix is a better tool for creating excellent user experiences. But that does not mean you are a failure or a bad person if you are using Next.js. (That said, I do think you would be happier and more productive if you used Remix, otherwise I wouldn’t bother writing this).在这篇文章中，我将争论为什么我不会使用 Next.js，因为我认为 Remix 是创造出色用户体验的更好工具。但这并不意味着如果你使用的是 Next.js，你就是一个失败者或坏人。（也就是说，我确实认为如果你使用 Remix，你会更快乐、更有效率，否则我不会费心写这篇文章）。\n\nFinally, I want to mention that I’ve been an outsider to the Next.js framework for years. It’s been a long time since I shipped something with Next.js myself. But before you dismiss my opinion as uninformed, you may want to know that [this article has resonated](https://twitter.com/kentcdodds/status/1717274167123526055) with a lot of people's actual experiences with the framework, so you'll have to dismiss all of their experience as well (I do not recommend this).最后，我想提一下，多年来我一直是 Next.js 框架的局外人。我已经很久没有自己用 Next.js 发布过东西了。但在你认为我的观点不知情之前，你可能想知道这篇文章已经引起了很多人对框架的实际体验的共鸣，所以你也必须驳回他们所有的经验（我不建议这样做）。\n\nAlso, I keep up with Next.js developments and hear of the experience of others. My past experience as a web developer gives me an intuition on the approach frameworks take and I can get a good sense for where a framework doesn’t align with my sensibilities.此外，我还关注 Next.js 的发展，并听取其他人的经验。我过去作为 Web 开发人员的经验让我对框架所采用的方法有一种直觉，我可以很好地了解框架与我的感受不一致的地方。\n\nSo, with that out of the way, let’s get into why I won’t use Next.js.所以，说完这些，让我们来看看为什么我不会使用 Next.js。\n\n## The Web Platform 网络平台\n\nI’ve been deploying stuff via HTTP for over a decade. I dabbled in native development (desktop and mobile), but I really found my home on the web. I want to explain why you should care about your framework embracing the web platform with a quick story.十多年来，我一直在通过 HTTP 部署东西。我涉足原生开发（桌面和移动），但我真的在网络上找到了自己的家。我想用一个简短的故事来解释为什么你应该关心你的框架拥抱 Web 平台。\n\nYears ago, I was working in React and I became dissatisfied with the de facto standard for testing my React components: enzyme. To make a long story short, [I decided](https://twitter.com/kentcdodds/status/974278185540964352) to build [Testing Library](https://testing-library.com/) which is now the recommended testing utility for React and other UI libraries.几年前，我在 React 工作，我对测试我的 React 组件的事实标准感到不满：酶。长话短说，我决定构建测试库，它现在是 React 和其他 UI 库的推荐测试工具。\n\nOne of the primary differences between enzyme and Testing Library is that while enzyme gave you [a wrapper](https://twitter.com/kentcdodds/status/949339902893871104) with a bunch of (overly) helpful (dangerous) utilities for interacting with rendered elements, Testing Library gave you the elements themselves. To boil that down to a principle, I would say that instead of wrapping the platform APIs, Testing Library exposed the platform APIs.酶和测试库之间的主要区别之一是，虽然酶为您提供了一个包装器，其中包含一堆（过于）有用（危险）的实用程序，用于与渲染的元素进行交互，但测试库为您提供了元素本身。为了将其归结为一个原则，我想说的是，测试库不是包装平台 API，而是公开了平台 API。\n\nThe primary benefit to this is **transferability**. By focusing on the standard APIs, Testing Library helps people become familiar with those APIs which helps them in their work elsewhere. And the utilities available in other tools that rely on the standard APIs integrate with Testing Library without a special adapter and vice versa.这样做的主要好处是可转移性。通过专注于标准 API，测试库帮助人们熟悉这些 API，这有助于他们在其他地方工作。其他工具中提供的依赖于标准 API 的实用程序无需特殊适配器即可与测试库集成，反之亦然。\n\nEvery library has its own APIs for things, of course. Testing Library has `findByRole` for example, and you need to understand the inputs to that. But the point is that it operates directly on the DOM and returns DOM nodes back to you. Rather than wrapping the APIs, it exposes those APIs to you. It’s a balance of usefulness and transferability.当然，每个库都有自己的 API。例如，测试库有 `findByRole` ，您需要了解其输入。但关键是它直接在 DOM 上运行，并将 DOM 节点返回给你。它不是包装 API，而是向你公开这些 API。这是实用性和可转移性的平衡。\n\nNext.js is like enzyme. Where Next.js has utilities to allow you to interact with the request, headers, cookies, etc, Remix exposes those APIs directly to you through its `loader`s and `action`s. In Remix, these functions accept a web fetch `Request` and return a `Response`. If you need to understand how to return JSON with some set headers, you go to MDN (the de facto standard web platform documentation) rather than the Remix docs. There are many such examples. As you get better at Remix, you get better at the web and vice versa.Next.js 就像酶。Next.js 具有允许您与请求、标头、cookie 等交互的实用程序，而 Remix 通过其 s 和 `loader` `action` s 直接向您公开这些 API。在 Remix 中，这些函数接受 Web 获取 `Request` 并返回 `Response` .如果你需要了解如何返回带有一些设置标头的 JSON，你可以转到 MDN（事实上的标准 Web 平台文档）而不是 Remix 文档。这样的例子还有很多。当你在 Remix 上变得更好时，你在网络上也会变得更好，反之亦然。\n\nWhen Next.js was having trouble with static build times, instead of recommending using the web platform's [Stale While Revalidate Cache Control directive](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control), they invented a highly complicated feature called [Incremental Static Regeneration (ISR)](https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration) to accomplish the same goal (which they point out in their own docs accomplishes the same thing as SWR).当 Next.js 在静态构建时间方面遇到问题时，他们没有推荐使用 Web 平台的 Stale While Revalidate Cache Control 指令，而是发明了一种高度复杂的功能，称为增量静态重新生成（ISR）来实现相同的目标（他们在自己的文档中指出，这与 SWR 完成相同的操作）。\n\nWhen I transitioned from Angular.js to React, I left a lot of Angular.js behind me. All of the time I had invested at getting really good at Angular.js felt like a huge waste. I don’t want that to ever happen to me again. So I prefer to focus on a framework that can not only give me what I want from the user experience perspective, but can also **give me skills** that I can use wherever I develop for the web.当我从 Angular.js 过渡到 React 时，我留下了很多 Angular.js。我花在真正擅长 Angular.js 上的所有时间都感觉像是巨大的浪费。我不希望这种情况再次发生在我身上。因此，我更愿意专注于一个框架，它不仅可以从用户体验的角度为我提供我想要的东西，还可以为我提供可以在任何地方为网络开发的技能。\n\n## Independence 独立\n\nHave you heard of [OpenNext](https://open-next.js.org/)? If not, here’s how it describes itself:你听说过 OpenNext 吗？如果没有，它是这样描述自己的：\n\n> OpenNext takes the Next.js build output and converts it into a package that can be deployed to any functions as a service platform. As of now only AWS Lambda is supported.OpenNext 获取 Next.js 生成输出，并将其转换为可部署到任何功能即服务平台的包。截至目前，仅支持 AWS Lambda。\n>\n> While Vercel is great, it's not a good option if all your infrastructure is on AWS. Hosting it in your AWS account makes it easy to integrate with your backend. And it's a lot cheaper than Vercel.虽然 Vercel 很棒，但如果您的所有基础设施都在 AWS 上，那么它就不是一个好的选择。将其托管在您的 AWS 账户中，可以轻松地与您的后端集成。而且它比 Vercel 便宜很多。\n>\n> Next.js, unlike Remix or Astro, doesn't have a way to self-host using serverless. You can run it as a Node application. This however doesn't work the same way as it does on Vercel.Next.js 与 Remix 或 Astro 不同，它没有办法使用无服务器进行自托管。您可以将其作为 Node 应用程序运行。然而，这与在 Vercel 上的工作方式不同。\n\nOpenNext exists because Next.js is difficult to deploy anywhere but Vercel. I'm not making moral judgements here. I appreciate the company’s incentives to make their own hosting offering as attractive as possible, but it’s evident that this incentive has deprioritized making Next.js easy to deploy anywhere.OpenNext 之所以存在，是因为 Next.js 很难部署在除 Vercel 之外的任何地方。我不是在这里做道德判断。我很欣赏该公司的激励措施，使他们自己的托管产品尽可能有吸引力，但很明显，这种激励措施已经降低了使 Next.js 易于在任何地方部署的优先级。\n\nI know the Netlify team spent a LOT of time getting Next.js support and keeping up with changes in Next.js. I understand that other infra hosts are the best ones to build adapters for frameworks (Vercel manages the Remix adapter). But I've consistently heard from these hosts that Next.js is particularly difficult to support and maintain.我知道 Netlify 团队花了很多时间获得 Next.js 支持，并跟上 Next.js 的变化。我知道其他基础设施主机是为框架构建适配器的最佳主机（Vercel 管理 Remix 适配器）。但是我一直从这些主机那里听到 Next.js 特别难以支持和维护。\n\nI have also heard from many individuals that hosting Next.js yourself as a regular Node.js application is a huge pain as well. Interestingly when this was first published I had several people say they just throw Next.js in a docker container and call it a day. Easy peasy. And I'm glad that's worked out for them.我还从许多人那里听说，将自己托管 Next.js 作为常规的 Node.js 应用程序也是一个巨大的痛苦。有趣的是，当这篇文章首次发布时，有几个人说他们只是将 Next.js 扔到 docker 容器中，然后收工。简单易行。我很高兴这为他们解决了。\n\nBut part of the problem is that the line between Next.js and Vercel is very thin so if you're not deploying on Vercel, you're actually using a different framework from what's documented in the Next.js docs and it's not always clear what those differences are because Vercel isn't incentivized to invest time in that.但部分问题在于 Next.js 和 Vercel 之间的界限非常薄，所以如果你没有在 Vercel 上部署，你实际上使用的框架与 Next.js 文档中记录的框架不同，并且并不总是清楚这些差异是什么，因为 Vercel 没有动力投入时间。\n\nWe can argue about whether Vercel is right or wrong about their current approach. But the fact remains that if Vercel’s pricing or other things become a problem for you, getting off of Vercel will also be a problem. It comes back down to the incentives.我们可以争论 Vercel 对他们目前的做法是对还是错。但事实仍然是，如果 Vercel 的定价或其他事情对您来说成为问题，那么下车 Vercel 也将是一个问题。这又回到了激励措施。\n\nAnd unfortunately, I keep hearing that Vercel's pricing has become a big problem for a lot of folks.不幸的是，我一直听说 Vercel 的定价已成为很多人的大问题。\n\nAdd this to the fact that Vercel is still allegedly not yet profitable (even after 8 years they're still growing aggressively, for sure, but I question their **unit economics**). This should give you great concern when putting all your eggs in that basket.再加上 Vercel 据称仍未盈利的事实（即使在 8 年后，他们仍在积极增长，当然，但我质疑他们的单位经济效益）。当把所有的鸡蛋都放在那个篮子里时，这应该会让你非常担心。\n\nFrom the beginning, Remix was built to deploy anywhere you can run JavaScript. This is helped in large part by the emphasis on standards. I definitely appreciate this aspect of Remix.从一开始，Remix 就被构建为部署在可以运行 JavaScript 的任何地方。这在很大程度上得益于对标准的重视。我非常欣赏 Remix 的这一方面。\n\nRemix was acquired by Shopify which has been a terrific steward of the project. The Remix team started shipping faster when they joined Shopify in large part because of the wide variety of environments where Shopify is utilizing Remix (marketing pages, ecommerce, internal and external apps, etc.). Additionally, getting acquired by Shopify has allowed the Remix team to focus all of their time and attention on the framework rather than figuring out how to leverage the framework to make money.Remix 被 Shopify 收购，Shopify 一直是该项目的出色管理者。Remix 团队加入 Shopify 后开始更快地发货，这在很大程度上是因为 Shopify 使用 Remix 的环境种类繁多（营销页面，电子商务，内部和外部应用程序等）。此外，被 Shopify 收购使 Remix 团队能够将所有时间和注意力集中在框架上，而不是弄清楚如何利用框架赚钱。\n\n## Next.js is eating React 下一个 .js 正在吃 React\n\nMy misgivings of Meta as a company always made me feel a little uneasy about Meta owning React. However, as Vercel has been hiring many of the React team members, this hasn’t really helped things for me. Ever since then, the React team has felt much less collaborative.我对 Meta 作为一家公司的疑虑总是让我对 Meta 拥有 React 感到有些不安。然而，由于 Vercel 一直在招聘许多 React 团队成员，这对我并没有真正的帮助。从那时起，React 团队的协作性就大大降低了。\n\nI know for myself, it seems like Vercel is trying to blur the lines between what is Next.js and what is React. There is a lot of confusion for people on what is React and what is Next.js, especially with regard to the [server components](https://twitter.com/ryanflorence/status/1714411614802501838) and [server actions](https://twitter.com/flybayer/status/1716574294728126869) features.我自己知道，Vercel 似乎试图模糊 Next.js 和 React 之间的界限。对于什么是 React 和什么是 Next.js，人们有很多困惑，特别是在服务器组件和服务器操作功能方面。\n\nI would feel more comfortable if React belonged to an open foundation. But short of that, it would be nice at least if they were [more collaborative](https://twitter.com/ryanflorence/status/1714855479120461994) than they’ve been since joining Vercel.如果 React 属于一个开放的基础，我会感觉更舒服。但除此之外，至少如果他们比加入 Vercel 以来更加协作，那就太好了。\n\nI guess you could say this is a point in favor of Next.js because at least they’re reaping the benefits of closer collaboration with React. But in my experience, a team not being collaborative is a bad sign for their software.我想你可以说这是支持 Next.js 的观点，因为至少他们正在收获与 React 更紧密合作的好处。但根据我的经验，一个团队不合作对他们的软件来说是一个不好的迹象。\n\nRedwood and Apollo maintainers have had a big problem with this lack of collaboration:Redwood 和 Apollo 的维护者在缺乏协作方面遇到了一个大问题：\n\n**Update**: [Matt Carroll](https://twitter.com/mattcarrollcode) (developer advocate on the React team) [reached out to me](https://twitter.com/mattcarrollcode/status/1717278830589546616) at the same time I published this post so that's a good sign!更新：Matt Carroll（React 团队的开发倡导者）在我发布这篇文章的同时联系了我，所以这是一个好兆头！\n\n## Experimenting on my users 在我的用户身上进行试验\n\nI’m highly concerned by some questionable decisions made by the Next.js team primarily in the marketing of experimental features as stable. Features that Next.js is shipping as stable are in the canary release of React. Honestly, it’s pretty funny and also sad……我非常关注 Next.js 团队做出的一些有问题的决定，主要是在将实验性功能营销为稳定功能方面。Next.js 作为稳定版发布的功能在 React 的金丝雀版本中。老实说，这很有趣，也很可悲……\n\nDo you know what “canary” refers to? It refers to [sentinel species](https://en.wikipedia.org/wiki/Sentinel_species) which are “used to detect risks to humans by providing advance warning of a danger.” So Next.js is building into itself a canary feature, calling it stable, and then sending it off to all your users effectively turning your app into the sentinel species. You may not see it this way, and maybe it’s just a messaging problem, but I’ve heard from a lot of people who have tried that their experience with Next.js’s App Router has been far from positive and I think it’s largely because of its incompleteness. They’re the canaries.你知道“金丝雀”指的是什么吗？它指的是“通过提供危险预警来检测人类风险”的哨兵物种。因此，Next.js 正在构建一个金丝雀功能，称其为稳定版，然后将其发送给所有用户，从而有效地将您的应用程序转变为哨兵物种。你可能不这么看，也许这只是一个消息传递问题，但我听说很多人尝试过，他们对 Next.js 应用程序路由器的体验远非积极，我认为这主要是因为它的不完整。他们是金丝雀。\n\nAnd while some people report having a great time with the App Router, I’m convinced that a lot of their enjoyment is coming from dropping the weight of the `pages` directory and getting the nested routing feature, not necessarily these canary features.虽然有些人报告说在 App Router 上玩得很开心，但我相信他们的很多乐趣来自于减轻 `pages` 目录的重量并获得嵌套路由功能，而不一定是这些金丝雀功能。\n\nYes, React Server Components are very cool and I look forward to being able to use them when they’re [production ready](https://twitter.com/ryanflorence/status/1714340925865148902) (they’ll allow Remix to [offload a lot of work](https://twitter.com/ryanflorence/status/1686757173202997249)).是的，React Server 组件非常酷，我期待能够在它们准备好生产时使用它们（它们将允许 Remix 卸载大量工作）。\n\nFor more on these problems, check this thread:有关这些问题的更多信息，请查看此线程：\n\n## Too much magic 太多的魔力\n\nHave you heard of the [principle of least surprise](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)? It states:你听说过最小惊喜原则吗？它指出：\n\n> A component of a system should behave in a way that most users will expect it to behave, and therefore not astonish or surprise users.系统组件的行为方式应与大多数用户期望的方式相同，因此不会让用户感到惊讶或惊讶。\n\nThis bit could probably exist under the “web platform” heading because the best way to avoid surprising people is by following the web platform APIs as well as possible and reducing the amount of “magic” your software does on top of that. Magic is nice, and can reduce boilerplate etc, but I want to opt-into that magic so it’s clear what’s going on rather than this happening automatically for me.这一点可能存在于“Web 平台”标题下，因为避免让人们感到惊讶的最好方法是尽可能遵循 Web 平台 API，并减少您的软件在此基础上所做的“魔术”数量。魔术很好，可以减少样板等，但我想选择加入这种魔术，这样就很清楚发生了什么，而不是自动发生。\n\nNext.js violates this principle in many ways. One example of this is the decision to [override the global `fetch`](https://nextjs.org/docs/app/api-reference/functions/fetch) function to add automatic caching. To me, this is a huge red flag. And it’s decisions like this one that make me pause and wonder what else they’re doing that I would be surprised by if I decided to adopt Next.js.Next.js 在很多方面都违反了这一原则。这方面的一个例子是决定覆盖全局 `fetch` 函数以添加自动缓存。对我来说，这是一个巨大的危险信号。正是这样的决定让我停下来，想知道他们还在做什么，如果我决定采用 Next.js，我会感到惊讶。\n\nMost of us learned from the MooTools days that overriding built-in features of the platform leads to problems (it’s the reason we have [`String.prototype.includes`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes) instead of [`String.prototype.contains`](https://github.com/mootools/mootools-core/issues/2402)). Doing this has negative impacts on the future of the web platform, and it also means that when you go to debug why something isn’t working you have to sift through the resources available to find the “Next.js version of fetch” vs “the web platform version of fetch.”我们大多数人都从 MooTools 时代了解到，覆盖平台的内置功能会导致问题（这是我们的原因 `String.prototype.includes` ，而不是 `String.prototype.contains` ）。这样做会对 Web 平台的未来产生负面影响，这也意味着当您调试某些东西不起作用的原因时，您必须筛选可用资源以找到“Next.js 版本的 fetch”与“fetch 的 Web 平台版本”。\n\n## Complexity 复杂性\n\nI keep hearing from people they’re finding Next.js is getting overly complex. This factors into the “too much magic” bit as well. React has [server actions](https://twitter.com/reactjs/status/1716573234160967762) as well as the new experimental [“taint” API](https://react.dev/reference/react/experimental_taintObjectReference) which became the subject of many jokes (also where I learned the alternative definition of \"taint\" 🤦‍♂️).我不断听到人们发现 Next.js 变得过于复杂。这也导致了“太多的魔力”部分。React 有服务器操作以及新的实验性“污点”API，它成为许多笑话的主题（也是我学到“污点”🤦 ♂️的替代定义的地方）。\n\nI’m excited about the prospect of React adding built-in support for mutations. But I’m definitely concerned about them [changing semantics](https://twitter.com/ryanflorence/status/1715459904474104104) of how web forms work. Each of these things increases the level of complexity.我对 React 添加对突变的内置支持的前景感到兴奋。但我绝对担心它们会改变 Web 表单工作方式的语义。这些事情中的每一个都会增加复杂性。\n\nI really appreciate that the Remix team is led by people who [share my principles](https://twitter.com/ryanflorence/status/1715469260380926242) and will ensure once these types of features are included, they don’t go down the same road of added complexity. In fact, [the Remix team is committed to *reduce* overall API footprint](https://twitter.com/ryanflorence/status/1697374545139953702) in the future rather than increase it. This leads me to my next point.我真的很感谢 Remix 团队由与我有共同原则的人领导，并将确保一旦包含这些类型的功能，它们就不会走上增加复杂性的同一条道路。事实上，Remix 团队致力于在未来减少整体 API 占用空间，而不是增加它。这就引出了我的下一点。\n\n## Stability 稳定性\n\nNext.js is on version 13. React Router (built by the same team as Remix) has been around for ***much longer*** and is only version 6. Remix was on version 1 for almost two years and only a month ago hit version 2. And it’s famously the most [boring major version bump](https://twitter.com/ryanflorence/status/1715017282374787261) of a web framework ever thanks to Remix team’s emphasis on stability.Next.js 版本为 13。React Router（由与 Remix 相同的团队构建）已经存在了更长的时间，并且只是第 6 版。Remix 在第 1 版上已经使用了将近两年，仅在一个月前才发布了第 2 版。众所周知，这是有史以来最无聊的 Web 框架的主要版本碰撞，这要归功于 Remix 团队对稳定性的强调。\n\nI need to acknowledge that the Next.js team has cared a lot about making upgrade paths easier with codemods. And I appreciate the need for a framework to evolve over time. But I've seen a lot of people complain about instability in what the Next.js team has pushed out in Next 13 and wrapping a canary feature and calling it stable just doesn't sit right with me.我需要承认，Next.js 团队非常关心使用 codemods 使升级路径更容易。我理解需要一个随着时间的推移而发展的框架。但是我看到很多人抱怨 Next.js 团队在 Next 13 中推出的内容不稳定，包装金丝雀功能并称其为稳定并不适合我。\n\nEarlier this year, the Remix team shared their plans for getting version 2 features released as an opt-in part of version 1 using a strategy called “[future flags](https://remix.run/blog/future-flags).” This played out extremely well and a huge number of actively developed Remix apps were upgraded in less than a day.今年早些时候，Remix 团队分享了他们的计划，即使用一种称为“未来标志”的策略将版本 2 功能作为版本 1 的选择加入部分发布。这非常顺利，大量积极开发的 Remix 应用程序在不到一天的时间内就得到了升级。\n\nThe Remix team cares a great deal about stability. This is why they didn’t jump on the band wagon years ago and implement [support for React Server Components](https://remix.run/blog/react-server-components) even though everyone was asking them to. This is also why there has effectively only been [a single breaking change](https://twitter.com/ryanflorence/status/1715023981340967214) in 8 years of React Router.Remix 团队非常关心稳定性。这就是为什么他们几年前没有加入潮流并实现对 React 服务器组件的支持，即使每个人都要求他们这样做。这也是为什么在 React Router 的 8 年中实际上只发生了一次重大更改的原因。\n\nThat kind of stability has a major impact on me and the apps I build. There are some libraries that I’m always terrified to upgrade because I’ve had a history of hours of confusion as I try to update all of my code to adapt to the new version. For something as impactful as a web framework, I would prefer to not have that feeling. Remix has been a gift in this regard.这种稳定性对我和我构建的应用程序产生了重大影响。有些库我总是害怕升级，因为我在尝试更新所有代码以适应新版本时有过数小时的混乱历史。对于像 Web 框架这样有影响力的东西，我宁愿没有这种感觉。在这方面，Remix 是一份礼物。\n\n## Capability 能力\n\nYou may have expected this blog post to be a comparison of the features and capabilities of Next.js vs other frameworks like Remix. But the fact is that you can build awesome things with both frameworks. I want to point out that features matter less than capabilities. I personally feel like the pit of success with Remix is wider than with Next.js, but I’m not going to go to great pains to describe why. A lot of this stuff is pretty subjective anyway.您可能已经期望这篇博文比较 Next.js 与其他框架（如 Remix）的特性和功能。但事实是，你可以用这两个框架来构建很棒的东西。我想指出的是，功能不如功能重要。我个人觉得 Remix 的成功比 Next.js 更宽，但我不会费力地描述原因。无论如何，很多东西都是非常主观的。\n\nWhen the Remix team rewrote the Next.js ecommerce demo to answer the “[Remix vs Next.js](https://remix.run/blog/remix-vs-next)” question, it demonstrated really well that Remix resulted in a better user experience with much less code (which is an important input in user experience). Since then, Next.js has updated it to use the App Router (which they are calling stable, but relies on canary features as I’ve already mentioned) so I think it's worth making another comparison. Remix has also learned some new tricks since that article was written, like out-of-order streaming.当 Remix 团队重写 Next.js 电子商务演示以回答“Remix vs Next.js”问题时，它很好地证明了 Remix 以更少的代码带来了更好的用户体验（这是用户体验中的重要输入）。从那以后，Next.js 已将其更新为使用应用程序路由器（他们称之为稳定，但正如我已经提到的，依赖于金丝雀功能），因此我认为值得再做一次比较。自那篇文章撰写以来，Remix 还学到了一些新技巧，比如乱序流媒体。\n\n## Conclusion 结论\n\nYou may agree or disagree with things I’ve said. You may think I’ve been unfair. You may wish I had said more or less. That’s your prerogative and I welcome you to share your opinions on my take on 𝕏, YouTube, Twitch etc. Just remember that if you dismiss my experience, you're also dismissing the experience of many others for whom this article truly resonated.你可能同意或不同意我所说的话。你可能会认为我不公平。你可能希望我或多或少说过。这是你的特权，我欢迎你分享你对我对 X、YouTube、Twitch 等的看法。请记住，如果你不屑一顾我的经历，你也就不屑一顾这篇文章真正引起共鸣的许多其他人的经历。\n\n[Lee Robinson](https://twitter.com/leeerob) (VP of DX at Vercel) posted [a thoughtful response on his blog](https://leerob.io/blog/using-nextjs) you may be interested in reading. Lee and I are friends and I admire him a lot. The post touches on many of the concerns I brought up, but doesn't satisfy my concerns personally.Lee Robinson（Vercel DX 副总裁）在他的博客上发表了一篇深思熟虑的回应，您可能有兴趣阅读。李和我是朋友，我非常钦佩他。这篇文章触及了我提出的许多问题，但并不能满足我个人的担忧。\n\nI just wanted to share why I’m recommending and teaching Remix instead of Next.js so next time someone asks me I can simply point them to this article.我只是想分享为什么我推荐和教授 Remix 而不是 Next.js，所以下次有人问我时，我可以简单地将他们指向这篇文章。\n\nIn short, the answer is I feel like both are highly capable frameworks, but Remix aligns better with my own sensibilities on what makes software maintainable and a joy to work with long term. I also feel like between the two frameworks, you’ll walk away from [EpicWeb.dev](http://epicweb.dev/) with more transferrable knowledge than if I taught Next.js instead.简而言之，答案是我觉得两者都是功能强大的框架，但 Remix 更符合我自己对软件可维护性和长期使用的乐趣的感受。我还觉得，在这两个框架之间，你会带着比我教 Next 更多的可转移知识离开 EpicWeb.dev.js 相反。\n\nIn the summer of 2023, I hosted an 8 week long live presentation of the [EpicWeb.dev](http://epicweb.dev/) workshop series. Gwen Shapira, one of the attendees, [told me](https://twitter.com/gwenshap/status/1710115518353658191) months later:2023 年夏天，我主持了为期 8 周的 EpicWeb.dev 研讨会系列现场演示。几个月后，与会者之一格温·夏皮拉（Gwen Shapira）告诉我：\n\n> …… I'm now building mostly on the NextJS stack and I still feel your class gave me the mental framework I needed to quickly ramp up and feel competent……我现在主要在 NextJS 堆栈上构建，我仍然觉得您的课程给了我快速提升并感到有能力所需的心理框架。\n>\n> Foundations are everything.基础就是一切。\n\nSo whether you’re using Next.js and plan to stay, or you’re hoping to adopt Remix, or even if you’d like to use some other web framework, my hope is that by choosing to teach Remix, I’ve equipped you to take on any challenge you face on the full stack web.因此，无论你是使用 Next.js 并计划留下来，还是希望采用 Remix，或者即使你想使用其他 Web 框架，我希望通过选择教授 Remix，我已经准备好迎接你在全栈 Web 上面临的任何挑战。\n\nBecause at the end of the day, I just want to make the world a better place by teaching you how to build quality software.因为归根结底，我只是想通过教你如何构建高质量的软件，让世界变得更美好。\n","type":"text/markdown","created":"20231103051220628","creator":"太微搜藏","modified":"20231103051220629","modifier":"太微搜藏","tags":"剪藏","url":"https://www.epicweb.dev/why-i-wont-use-nextjs"},{"title":"Why_I'm_Using_Next.js","text":"October 28, 2023 (1mo ago)2023 年 10 月 28 日 （1 个月前）\n\n<!--$-->\n\n55,923 views 55,923 次浏览\n\n<!--/$-->\n\nKent C. Dodds recently published a new article [Why I Won't Use Next.js](https://www.epicweb.dev/why-i-wont-use-nextjs).Kent C. Dodds 最近发表了一篇新文章《为什么我不会使用 Next.js》。\n\nIn the post, Kent shares his opinions on why he's recommending using Remix instead of Next.js. I wanted to share my thoughts on the post and make the case that:在这篇文章中，Kent 分享了他为什么建议使用 Remix 而不是 Next.js 的观点。我想分享我对这篇文章的看法，并说明：\n\n* Learning Next.js helps you learn [the web platform](#the-web-platform)学习 Next.js 可帮助您学习 Web 平台\n* All Next.js features work [self-hosted](#independence)所有 Next.js 功能都自托管工作\n* Server Components and Server Actions are [independent of Vercel](#open-source-and-framework-boundaries)服务器组件和服务器操作独立于 Vercel\n* The React canary channel is stable for [frameworks like Next.js to adopt](#stability)React Canary 通道对于像 Next.js 这样的框架来说是稳定的\n* Server Components are [production ready](#stability)服务器组件已准备好用于生产\n\n## [](#background)Background 背景\n\n[Kent](https://twitter.com/kentcdodds) is a prolific educator and previously a co-founder of Remix. His new course, [EpicWeb.dev](https://www.epicweb.dev/), helps you learn how to build full-stack web applications using Remix.Kent 是一位多产的教育家，曾是 Remix 的联合创始人。他的新课程 EpicWeb.dev 可帮助您学习如何使用 Remix 构建全栈 Web 应用程序。\n\nKent is an incredible member of the React community. I've learned a lot from him over the years (especially his material on testing) and this blog actually uses a library he created, `mdx-bundler`, so thank you.Kent 是 React 社区中一位了不起的成员。这些年来，我从他那里学到了很多东西（尤其是他关于测试的材料），这个博客实际上使用了他创建的库， `mdx-bundler` 所以谢谢。\n\nExcited to go on with [@leeerob](https://twitter.com/leeerob) for the keynote at [@reactathon](https://twitter.com/reactathon) in person! Catch the live stream right now!很高兴能亲自@leeerob@reactathon 的主题演讲！立即观看直播！\n\nIf you're new here, I'm Lee. I work on Next.js. I've also made some courses about using Next.js before I joined Vercel.如果你是新来的，我是李。我在 Next.js 上工作。在我加入 Vercel 之前，我还制作了一些关于使用 Next.js 的课程。\n\nBoth Kent and I are passionate about the tools that we use. As Kent shared in his post:Kent和我都对我们使用的工具充满热情。正如肯特在他的帖子中分享的那样：\n\n> As Next.js is a very popular alternative to Remix, people ask me why I chose Remix instead of Next.js for the framework I teach on EpicWeb.dev. These people are probably facing one of those scenarios I mentioned. So this post is for those people.由于 Next.js 是 Remix 的一个非常流行的替代品，人们问我为什么选择 Remix 而不是 Next.js 因为我在 EpicWeb.dev 上教授的框架。这些人可能正面临我提到的其中一种情况。所以这篇文章是为这些人准备的。\n\nSimilarly, I'm often asked about my opinions on Next.js versus other frameworks. This post is for the folks in the Next.js community who are wondering about some of the points Kent brings up.同样，我经常被问到我对 Next.js 与其他框架的看法。这篇文章是为 Next.js 社区中想知道 Kent 提出的一些观点的人准备的。\n\n## [](#the-web-platform)The Web Platform 网络平台\n\nFirst, it's important to call out that Remix has pushed the React community forward in it's understanding of the web platform and web APIs.首先，需要指出的是，Remix 推动了 React 社区对 Web 平台和 Web API 的理解。\n\nNext.js v1 was released in 2016 (just had the 7-year anniversary) and at the time, the Node.js [request](https://nodejs.org/api/http.html#class-httpincomingmessage)/[response](https://nodejs.org/api/http.html#class-httpserverresponse) objects were the de-facto way to build a server-rendered JavaScript framework. We were writing React class components, as well.Next.js v1 于 2016 年发布（刚刚迎来 7 周年纪念日），当时 Node.js 请求/响应对象是构建服务器渲染的 JavaScript 框架的事实上的方式。我们也在编写 React 类组件。\n\nRemix v1 was released in 2021. [A lot has changed since then](https://leerob.io/blog/javascript). The web platform is more powerful than ever, and there's an entire new generation of developers learning the web `Request` and `Response` APIs first instead. They're able to learn once, and write the same JavaScript everywhere, reusing their existing knowledge. I love that.Remix v1 于 2021 年发布。从那时起，很多事情都发生了变化。Web 平台比以往任何时候都更强大，新一代的开发人员首先学习 Web `Request` 和 `Response` API。他们只需学习一次，就可以在任何地方编写相同的 JavaScript，重复使用他们现有的知识。我喜欢这一点。\n\nKent talks about how he prefers tools that give access to the underlying primitives, rather than wrappers, based on his past experience. I can empathize.Kent 谈到了根据他过去的经验，他更喜欢能够访问底层基元的工具，而不是包装器。我能感同身受。\n\n> Where Next.js has utilities to allow you to interact with the request, headers, cookies, etc, Remix exposes those APIs directly to you through its `loader`s and `action`s. In Remix, these functions accept a `Request` and return a `Response`. If you need to understand how to return JSON with some set headers, you go to MDN (the de facto standard web platform documentation) rather than the Remix docs.Next.js 具有允许您与请求、标头、cookie 等交互的实用程序，而 Remix 通过其 s 和 `loader` `action` s 直接向您公开这些 API。在 Remix 中，这些函数接受 a `Request` 并返回 `Response` .如果你需要了解如何返回带有一些设置标头的 JSON，你可以转到 MDN（事实上的标准 Web 平台文档）而不是 Remix 文档。\n\nThis is absolutely true for the Next.js Pages Router. However, a lot has changed since then. Let me explain.对于 Next.js 页面路由器来说，这是绝对正确的。然而，从那时起，很多事情都发生了变化。让我解释一下。\n\n### [](#nextjs-pages-router)Next.js Pages Router 下一页 .js 页面路由器\n\nThe Next.js Pages Router was introduced in 2016. You'll notice many parts of the framework that feel closer to Node.js than web APIs. For example, you've been able to eject from the default Next.js server to have [your own Express server](https://nextjs.org/docs/pages/building-your-application/configuring/custom-server) since the beginning.Next.js Pages 路由器于 2016 年推出。你会注意到框架的许多部分感觉更接近 Node.js 而不是 Web API。例如，您从一开始就能够从默认的 Next.js 服务器弹出，以拥有自己的 Express 服务器。\n\nThis design choice continued for many years. Next.js 9, released in 2019, introduced [API Routes](https://nextjs.org/blog/next-9#api-routes). These endpoints built on the Node.js request and response APIs. The API is similar to Express, as many folks were familiar with this API at the time.这种设计选择持续了很多年。Next.js 9 于 2019 年发布，引入了 API 路由。这些端点基于 Node.js 请求和响应 API 构建。该 API 类似于 Express，因为当时很多人都熟悉这个 API。\n\n```plain\nexport default function handler(req, res) {\n  res.status(200).json({ message: 'Hello from Next.js!' });\n}\n```\n\nAPI Routes and the ejected server still work today. But frameworks must evolve over time based on community feedback, how the ecosystem moves, and new functionality available in the web platform.API 路由和弹出的服务器今天仍然有效。但是，框架必须根据社区反馈、生态系统的移动方式以及 Web 平台中可用的新功能随着时间的推移而发展。\n\nThat's why Next.js 12, released in 2021, introduced [Middleware](https://nextjs.org/blog/next-12#introducing-middleware), which is built on the Web `Request`, `Response`, and `fetch`. It didn't make sense to build new APIs that weren't embracing the now standardized web APIs. Note: this was the same year Remix v1 was released. We agree!这就是为什么 2021 年发布的 Next.js 12 引入了基于 Web `Request` 、 `Response` 和 `fetch` 的中间件。构建不包含现在标准化的 Web API 的新 API 是没有意义的。注意：这是 Remix v1 发布的同一年。我们同意！\n\n### [](#nextjs-app-router)Next.js App Router 下一个 .js 应用路由器\n\nI mentioned evolution, right? Kent mentions in the post:我提到了进化，对吧？肯特在帖子中提到：\n\n> I've been an outsider to the Next.js framework for years. It's been a long time since I shipped something with Next.js myself.多年来，我一直是 Next.js 框架的局外人。我已经很久没有自己用 Next.js 发布过东西了。\n\nTotally fair. There's only so many hours in the day for family, work, and fun. So I don't expect Kent (or anyone really) to have kept up with the chronology of Next.js here like I have. But let me explain further about where we're headed.完全公平。一天中只有那么多时间用于家庭、工作和娱乐。所以我不指望肯特（或任何人）像我一样跟上 Next.js 的年表。但让我进一步解释一下我们的前进方向。\n\nAfter 6 years of feedback, Next.js 13 introduced a new foundation for the framework with the App Router. The Pages Router didn't go anywhere, but again, the framework must evolve with the times.经过 6 年的反馈，Next.js 13 通过应用路由器为框架引入了新的基础。Pages Router 没有去任何地方，但同样，框架必须与时俱进。\n\nIf you were designing a new framework, how would you handle reading values from the incoming request, like cookies, or headers? And how would you allow developers to write custom API endpoints?如果您正在设计一个新框架，您将如何处理从传入请求中读取值，例如 cookie 或标头？您将如何允许开发人员编写自定义 API 端点？\n\nWell, you'd use the standard web APIs, of course. Going back to Kent's feedback:当然，你会使用标准的 Web API。回到 Kent 的反馈：\n\n> Where Next.js has utilities to allow you to interact with the request, headers, cookies, etc, Remix exposes those APIs directly to you through its `loader`s and `action`s.Next.js 具有允许您与请求、标头、cookie 等交互的实用程序，而 Remix 通过其 s 和 `loader` `action` s 直接向您公开这些 API。\n\nAgain, definitely true for the Pages Router. Inside `getServerSideProps`, the equivalent for a Remix `loader`, you can't use web APIs to access headers or cookies. It's Node.js APIs still.同样，对于页面路由器来说绝对是正确的。在内部 `getServerSideProps` ，相当于 Remix `loader` ，您不能使用 Web API 访问标头或 cookie。它仍然是 Node.js API。\n\n```plain\nexport async function getServerSideProps({ req, res }) {\n  res.setHeader(\n    'Cache-Control',\n    'public, s-maxage=10, stale-while-revalidate=59'\n  );\n \n  return { props: {} };\n}\n```\n\nSo you're designing this framework. You want to use web standard APIs. And you also want to make it easy for developers to do the right thing. Kent says:所以你正在设计这个框架。您希望使用 Web 标准 API。此外，您还希望让开发人员能够轻松地做正确的事情。肯特 说：\n\n> To boil that down to a principle, I would say that instead of wrapping the platform APIs, Testing Library exposed the platform APIs.为了将其归结为一个原则，我想说的是，测试库不是包装平台 API，而是公开了平台 API。\n\nWe agree. But why couldn't we have both?我们同意。但为什么我们不能两者兼而有之呢？\n\nIn the Next.js App Router, let's say you want to create an arbitrary API endpoint. These are now called [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers). Here's what they look like:在 Next.js 应用路由器中，假设您要创建任意 API 终结点。这些现在称为路由处理程序。以下是它们的样子：\n\n```plain\nexport async function GET(request: Request) {\n  const res = await fetch('https://api.leerob.io/...', { ... } )\n  const data = await res.json()\n \n  return Response.json({ data })\n}\n```\n\nRoute Handlers accept a web `Request` and produce a web `Response`. But what about cookies, headers, and more?路由处理程序接受 Web 并生成 Web `Request` `Response` 。但是 Cookie、标题等呢？\n\nSince you have access to the web APIs directly, you can browse MDN and reuse all of the knowledge you've learned from Next.js. Also, ChatGPT is *really* good at creating these APIs.由于您可以直接访问 Web API，因此您可以浏览 MDN 并重用您从 Next.js 学到的所有知识。此外，ChatGPT 非常擅长创建这些 API。\n\n```plain\nexport async function GET(request: Request) {\n  // Read headers\n  const token = await getToken(request.headers);\n  // Set cookies\n  return new Response('Hello, Next.js!', {\n    status: 200,\n    headers: { 'Set-Cookie': `token=${token.value}` },\n  });\n}\n```\n\nWe can also provide abstractions that can be composed, allowing you to write reusable functions without having to pass headers as a function parameter. You can choose whichever you prefer.我们还可以提供可以组合的抽象，允许您编写可重用的函数，而无需将标头作为函数参数传递。您可以选择您喜欢的任何一种。\n\n```plain\nimport { cookies, headers } from 'next/headers';\n \nexport async function GET(request: Request) {\n  const cookieStore = cookies();\n  const headersList = headers();\n  const token = cookieStore.get('token');\n  const referer = headersList.get('referer');\n}\n```\n\nThat [`cookies()` function](https://nextjs.org/docs/app/api-reference/functions/cookies) returns the same underlying `Headers` web API. It can be used in both Route Handlers, as well as other server-side code in the App Router, like Server Actions or Server Components:该 `cookies()` 函数返回相同的基础 `Headers` Web API。它可以在路由处理程序以及应用路由器中的其他服务器端代码中使用，例如服务器操作或服务器组件：\n\n```plain\n'use server';\n \nimport { cookies } from 'next/headers';\n \nexport function serverAction() {\n  cookies().set('name', 'leerob');\n}\n```\n\nI strongly agree with Kent. I can't imagine new web frameworks being released that don't embrace web APIs. That's why Remix, SvelteKit, Nuxt, Solid, Astro, Next.js, and many more are doing this.我非常同意肯特的观点。我无法想象发布的新 Web 框架不包含 Web API。这就是为什么 Remix，SvelteKit，Nuxt，Solid，Astro，Next.js 等等都在这样做。\n\n## [](#independence)Independence 独立\n\nKent mentions a project called OpenNext, which as quoted in the post, describes itself as:Kent 提到了一个名为 OpenNext 的项目，正如帖子中引用的那样，该项目将自己描述为：\n\n> OpenNext takes the Next.js build output and converts it into a package that can be deployed to any functions as a service platform. As of now only AWS Lambda is supported.OpenNext 获取 Next.js 生成输出，并将其转换为可部署到任何功能即服务平台的包。截至目前，仅支持 AWS Lambda。\n\nThe maintainers of OpenNext are building a platform for easily deploying serverless applications on AWS. I would argue that this package is trying to be an open-source infrastructure as code tool, not an open-source framework. Naming is hard.OpenNext 的维护者正在构建一个平台，以便在 AWS 上轻松部署无服务器应用程序。我认为这个包试图成为一个开源的基础设施即代码工具，而不是一个开源框架。命名很难。\n\nKent then says: 肯特接着说：\n\n> OpenNext exists because Next.js is difficult to deploy anywhere but Vercel. I appreciate the company's incentives to make their own hosting offering as attractive as possible, but it's evident that this incentive has deprioritized making Next.js easy to deploy anywhere.OpenNext 之所以存在，是因为 Next.js 很难部署在除 Vercel 之外的任何地方。我很欣赏该公司的激励措施，使他们自己的托管产品尽可能有吸引力，但很明显，这种激励措施已经降低了使 Next.js 易于在任何地方部署的优先级。\n\nWe're always looking to improve self-hosting Next.js. For example, I made a [video](https://www.youtube.com/watch?v=Pd2tVxhFnO4) and [example](https://github.com/vercel/next.js/tree/canary/examples/with-docker) showing how to deploy with Docker to whichever service you prefer.我们一直在寻求改进自托管 Next.js。例如，我制作了一个视频和示例，展示了如何使用 Docker 部署到您喜欢的任何服务。\n\n`next start` is how Walmart, TikTok, ChatGPT, Starbucks, Target, Doordash, and many others self-host Next.js.`next start` 是沃尔玛、TikTok、ChatGPT、星巴克、塔吉特、Doordash 和许多其他公司自行托管 Next.js 的方式。\n\nNow you might be thinking: but Lee, that's not what Kent is talking about. He's talking about *serverless* platforms. Why wouldn't Next.js build first-party adapters for every deployment target?现在你可能会想：但是李，这不是肯特在说的。他谈论的是无服务器平台。为什么 Next.js 不为每个部署目标构建第一方适配器？\n\n### [](#open-source-and-framework-boundaries)Open Source and Framework Boundaries 开源和框架边界\n\nFrom my post earlier this year on [funding open source](https://leerob.io/blog/funding-open-source):从我今年早些时候关于资助开源的帖子中：\n\n> Developers don't want walled gardens. They want the freedom to eject and self-host. It's about control. This is why all Next.js features work self-hosted. Vercel provides [infrastructure](https://vercel.com/enterprise) and a [workflow](https://vercel.com/workflow) on top of Next.js. You can [host Next.js elsewhere](https://nextjs.org/docs/deployment#self-hosting), if you want.开发商不想要围墙花园。他们想要弹出和自我托管的自由。这是关于控制。这就是为什么所有 Next.js 功能都是自托管工作的原因。Vercel 在 Next.js 之上提供基础设施和工作流。如果需要，可以在其他地方托管 Next.js。\n>\n> I'm a fan of the model Next.js uses. It's clear how it's funded (through Vercel) and the incentive is aligned (I want to deploy Next.js at some point, maybe I will [try Vercel](https://vercel.com/templates/next.js)). It's a similar story for Svelte. You want to deploy SvelteKit, maybe you'll [try Vercel](https://vercel.com/templates/svelte).我是 Next.js 使用的模型的粉丝。很明显它是如何资助的（通过 Vercel），激励是一致的（我想在某个时候部署 Next.js，也许我会尝试 Vercel）。对于 Svelte 来说，这是一个类似的故事。你想部署 SvelteKit，也许你会尝试 Vercel。\n\nVercel, the maintainers of Next.js who invest heavily in its [research and development](https://twitter.com/dan_abramov/status/1654688751342301184), are focused on maintaining and building a default deployment output for Next.js. We aren't doing adapters, although I love this for other frameworks.Vercel 是 Next.js 的维护者，他们在研发方面投入了大量资金，专注于维护和构建 Next.js 的默认部署输出。我们不是在做适配器，尽管我喜欢其他框架。\n\nNext.js has over 850,000 monthly active developers. And those developers expect things to work well, to have bugs fixed quickly, for new features to be released, for us to respond to their questions in a timely manner, and more.Next.js 每月有超过 850,000 名活跃开发人员。这些开发人员希望事情运行良好，快速修复错误，发布新功能，我们及时回答他们的问题，等等。\n\nI keep hearing how hosting Next.js yourself as a nodejs application is a huge pain, and I have no idea where this is coming from. What's difficult? Containerizing it? Creating a deploy pipeline? If you said yes to either, then you likely have trouble hosting *any* app yourself.我一直听说将 Next.js 自己作为 nodejs 应用程序托管是一个巨大的痛苦，我不知道这是从哪里来的。 有什么难的？容器化？正在创建部署管道？如果您对其中任何一个都说“是”，那么您可能自己无法托管*任何*应用程序。\n\nI get asked about this a lot (especially since the launch of Epic Web), so I've written it down. Here's why I won't use Next.js: epicweb.dev/why-i-wont-use……我经常被问到这个问题（尤其是自从 Epic Web 推出以来），所以我把它写下来了。 这就是为什么我不会使用 Next.js： epicweb.dev/why-i-wont-use……\n\nWe want the default build output of Next.js to work well when self hosting, and also well on Vercel. And guess what? They're the same output. Well, almost. Let me clarify.我们希望 Next.js 的默认构建输出在自托管时运行良好，并且在 Vercel 上也能运行良好。你猜怎么着？它们是相同的输出。嗯，差不多。让我澄清一下。\n\nIt took us a while at Vercel to figure out the correct format and boundary between open source framework and infrastructure platform. Our philosophy is called [framework defined infrastructure](https://vercel.com/blog/framework-defined-infrastructure). And critically, the specification that Vercel uses for frameworks is open source. It's called the [Build Output API](https://vercel.com/docs/build-output-api/v3).在 Vercel，我们花了一段时间才弄清楚开源框架和基础设施平台之间的正确格式和边界。我们的理念是框架定义的基础设施。至关重要的是，Vercel 用于框架的规范是开源的。它称为生成输出 API。\n\nThis output format powers Next.js, as well as Remix, SvelteKit, and many other frameworks on Vercel. We actually maintain our own Remix adapter too, which transforms the Remix output into this format, plus [some other features](https://vercel.com/blog/vercel-remix-integration-with-edge-functions-support).这种输出格式支持 Next.js，以及 Remix、SvelteKit 和 Vercel 上的许多其他框架。我们实际上也维护了自己的 Remix 适配器，它将 Remix 输出转换为这种格式，以及一些其他功能。\n\nWe'll soon be making the default output of Next.js match the Build Output API directly, without the intermediate step. We agree with the importance of keeping these pieces open and accessible, which is why we even open sourced the intermediate step.我们很快就会使 Next.js 的默认输出直接与生成输出 API 匹配，而无需中间步骤。我们同意保持这些部分开放和可访问的重要性，这就是为什么我们甚至开源了中间步骤。\n\n### [](#pricing-correlation-or-causation)Pricing: Correlation or causation?定价：相关性还是因果关系？\n\nKent mentions: Kent 提到：\n\n> We can argue about whether Vercel is right or wrong about their current approach. But the fact remains that if Vercel's pricing or other things become a problem for you, getting off of Vercel will also be a problem. It comes back down to the incentives.我们可以争论 Vercel 对他们目前的做法是对还是错。但事实仍然是，如果 Vercel 的定价或其他事情对您来说成为问题，那么下车 Vercel 也将是一个问题。这又回到了激励措施。\n\nThere are improvements I'd like to make to Vercel's pricing. And we'll have some updates soon! Some pricing changes have already rolled out, like [lower prices](https://vercel.com/changelog/vercel-postgres-is-now-available-for-pro-users) for our storage products and [spend controls](https://vercel.com/blog/introducing-spend-management-realtime-usage-alerts-sms-notifications). But I understand the sentiment.我想对 Vercel 的定价进行一些改进。我们很快就会有一些更新！一些定价变化已经推出，例如我们的存储产品价格降低和支出控制。但我理解这种情绪。\n\nUnfortunately, this sentiment does not equal causation.不幸的是，这种情绪并不等于因果关系。\n\n[Replying to @](https://twitter.com/dev_bogdan/status/1649132186472263680)\n\n<!-- -->\n\n[dev\\_bogdan 回复@dev\\_bogdan](https://twitter.com/dev_bogdan/status/1649132186472263680)\n\nOnly exposing a full route refresh seems like a ploy on Vercel's part to needlessly re-render SC's --> Increased compute --> $$$ :) I worry about that a bit with NextJS, actually. That NextJS technical approaches may optimize for their profit when deployed there.仅公开完整的路由刷新似乎是 Vercel 的策略，以不必要地重新渲染 SC 的 --> 增加计算 --> $$$ :) 实际上，我对 NextJS 有点担心。NextJS 技术方法在部署在那里时可能会优化其利润。\n\n[Replying to @](https://twitter.com/matt_kruse/status/1649141645844049939)\n\n<!-- -->\n\n[matt\\_kruse 回复@matt\\_kruse](https://twitter.com/matt_kruse/status/1649141645844049939)\n\nit’s the other way around. Next has rewritten their entire framework under the technical direction and vision from the React team. including changing some APIs to something less Next-specific. we care a lot about this kind of stuff and getting it right.反之亦然。Next 在 React 团队的技术指导和愿景下重写了他们的整个框架。包括将某些 API 更改为不太特定于 Next 的 API。我们非常关心这种东西，并把它做好。\n\n[Replying to @](https://twitter.com/dan_abramov/status/1649214795571134465)\n\n<!-- -->\n\n[dan\\_abramov 回复@dan\\_abramov](https://twitter.com/dan_abramov/status/1649214795571134465)\n\nwhile Vercel obviously has incentives to take best advantage of React’s abilities and architectural model, the idea of designing a worse API so that Vercel could make a profit sounds both repulsive and shortsighted. i can vouch for everyone involved in App Router design.虽然 Vercel 显然有动力充分利用 React 的能力和架构模型，但设计一个更糟糕的 API 以便 Vercel 能够获利的想法听起来既令人反感又短视。我可以为参与 App Router 设计的每个人担保。\n\nIf you want to self-host, all Next.js features will work. So, why would someone choose [Vercel for Next.js](https://vercel.com/docs/frameworks/nextjs), then? The same reason they'd choose it for Astro, SvelteKit, or even Remix.如果要自托管，所有 Next.js 功能都可以使用。那么，为什么有人会选择 Vercel 作为 Next.js 呢？他们为 Astro、SvelteKit 甚至 Remix 选择它的原因相同。\n\nIf you don't want to worry about infrastructure, Vercel takes care of that for you (plus some other stuff, but that's besides the point). And thanks to [framework defined infra](https://vercel.com/blog/framework-defined-infrastructure), you're not writing a bunch of CDK code or bespoke infra-as-code solutions. You're writing Next.js code that's open and portable to any server, on any platform.如果您不想担心基础设施，Vercel 会为您处理（以及其他一些事情，但这不是重点）。多亏了框架定义的基础设施，您不必编写一堆 CDK 代码或定制的基础设施即代码解决方案。您正在编写 Next.js 代码，这些代码可以开放并移植到任何平台上的任何服务器。\n\nNext.js is like Kubernetes, and Vercel is like [Google Kubernetes Engine](https://cloud.google.com/kubernetes-engine).Next.js 就像 Kubernetes，Vercel 就像 Google Kubernetes Engine。\n\n## [](#relationship-with-react)Relationship with React 与 React 的关系\n\nKent mentions: Kent 提到：\n\n> I know for myself, it seems like Vercel is trying to blur the lines between what is Next.js and what is React. There is a lot of confusion for people on what is React and what is Next.js, especially with regard to the server components and server actions features.我自己知道，Vercel 似乎试图模糊 Next.js 和 React 之间的界限。对于什么是 React 和什么是 Next.js，人们有很多困惑，特别是在服务器组件和服务器操作功能方面。\n\nDefinitely not intentional.绝对不是故意的。\n\nNext.js is placing a [large bet](https://twitter.com/dan_abramov/status/1650923730233700354) on the future of React. The App Router builds on many features the React team has been working on for years. Building and supporting a framework requires a non-trivial amount of work. [Redwood is doing the same](https://tom.preston-werner.com/2023/05/30/redwoods-next-epoch-all-in-on-rsc).Next.js 对 React 的未来下了很大的赌注。App Router 建立在 React 团队多年来致力于的许多功能之上。构建和支持框架需要大量的工作。红木也在做同样的事情。\n\nIn retrospect, we could have worked more closely with the Meta team on making some docs changes directly to the React docs versus the Next.js docs. Thankfully, this has picked up a lot and we are actively collaborating with the team at Meta. Shoutout to Meta's Learning & Advocacy team.回想起来，我们本可以与 Meta 团队更紧密地合作，直接对 React 文档进行一些文档更改，而不是 Next.js 文档。值得庆幸的是，这已经回升了很多，我们正在与 Meta 的团队合作。向 Meta 的学习与宣传团队致敬。\n\nAPIs that Next.js uses, like [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus), are now documented in the React docs. Even experimental React APIs like [tainting](https://react.dev/reference/react/experimental_taintUniqueValue) are now documented. They're publishing a *lot* of great docs on their [new site](https://react.dev/learn) (which they worked on for many years).Next.js 使用的 API，如 `useFormStatus` ，现在记录在 React 文档中。甚至实验性的 React API，如污染，现在也被记录在案。他们在他们的新网站上发布了许多很棒的文档（他们工作了很多年）。\n\nWe'll keep improving here and making the boundaries more clear.我们将在这里不断改进，使界限更加清晰。\n\n## [](#stability)Stability 稳定性\n\nKent mentions some concerns about the stability of Next.js, specifically:Kent提到了一些关于 Next.js 稳定性的担忧，特别是：\n\n> So Next.js is building into itself a canary feature, calling it stable, and then sending it off to all your users effectively turning your app into the sentinel species.因此，Next.js 正在构建一个金丝雀功能，称其为稳定版，然后将其发送给所有用户，从而有效地将您的应用程序转变为哨兵物种。\n\nHe's referring to the [React canary channel](https://react.dev/blog/2023/05/03/react-canaries), which the Next.js App Router (not Pages) builds on. From the React post:他指的是 React Canary 通道，Next.js App Router（不是 Pages）基于该通道构建。来自 React 帖子：\n\n> We'd like to offer the React community an option to adopt individual new features as soon as their design is close to final, before they're released in a stable version—similar to how Meta has long used bleeding-edge versions of React internally. We are introducing a new officially supported [Canary release channel](https://react.dev/community/versioning-policy#canary-channel). It lets curated setups like frameworks decouple adoption of individual React features from the React release schedule.我们希望为 React 社区提供一个选项，即在设计接近最终阶段时采用单独的新功能，然后再以稳定版本发布——类似于 Meta 长期以来在内部使用 React 的前沿版本的方式。我们正在引入一个新的官方支持的 Canary 发布频道。它允许像框架这样的精心策划的设置将单个 React 功能的采用与 React 发布计划分离。\n\nThe canary channel is stable for frameworks to adopt. Then, the framework itself should use semver. This might be another correlation ≠ causation moment, because there *is* some community pain here.金丝雀通道对于框架来说是稳定的。然后，框架本身应该使用 semver。这可能是因果时刻≠另一种相关性，因为这里有一些社区痛苦。\n\nThe App Router rollout has had bumps. Some bugs, things that didn't work, and places where the performance could be better.App Router 的推出遇到了一些坎坷。一些错误，不起作用的东西，以及性能可以更好的地方。\n\nThis is on me. Not React. And our messaging to the community could have been better. There's a lot more I wanted to say about this, which is what we shared in the [2023 Next.js Conf Keynote](https://youtu.be/8q2q_820Sx4?t=1385).这是在我身上。不做出反应。我们向社区传达的信息本来可以更好。关于这一点，我想说的还有很多，这就是我们在 2023 年 Next.js Conf 主题演讲中分享的内容。\n\nIn short, performance and reliability are still a major focus for Next.js. Kent goes on to mention:简而言之，性能和可靠性仍然是 Next.js 的主要关注点。Kent 接着提到：\n\n> Yes, React Server Components are very cool and I look forward to being able to use them when they're production ready 是的，React 服务器组件非常酷，我期待能够在它们准备好生产时使用它们\n\nReact Server Components are ready. There's now [thousands of the top sites on the web](https://twitter.com/leeerob/status/1700202503034515779) using Server Components in production. The experience getting there could have been better, but they're in production.React 服务器组件已准备就绪。现在，网络上有数以千计的顶级站点在生产中使用服务器组件。到达那里的体验本来可以更好，但它们正在生产中。\n\n## [](#is-nextjs-too-magical)Is Next.js Too Magical?Next.js 太神奇了吗？\n\nKent talks about how he's not a fan of Next.js extending the web `fetch` API.Kent 谈到他不喜欢 Next.js 扩展 Web `fetch` API。\n\nI agree with part of this, specifically on adding Next.js specific extensions to the `fetch` API. We're looking to move away from this direction based on community feedback.我同意其中的一部分，特别是向 `fetch` API 添加 Next.js 特定的扩展。我们希望根据社区的反馈来摆脱这个方向。\n\nIn Next.js 14, for example, if you want to opt-out of caching, you would use [`noStore()`](https://nextjs.org/docs/app/api-reference/functions/unstable_noStore) versus `cache: 'no-store'` on the `fetch`. And if you want to use more programatic caching and revalidating features, those will soon be standalone APIs as well.例如，在 Next.js 14 中，如果要选择退出缓存，则可以在 `noStore()` `fetch` . `cache: 'no-store'` 如果您想使用更多的编程缓存和重新验证功能，这些功能也将很快成为独立的 API。\n\n## [](#complexity--stability)Complexity & Stability 复杂性和稳定性\n\nKent mentions: Kent 提到：\n\n> I keep hearing from people they're finding Next.js is getting overly complex.我不断听到人们发现 Next.js 变得过于复杂。\n\nThe App Router is a very different model from the Pages Router. It's almost like a new framework. This was one of the many reasons why we needed to ensure you could [incrementally adopt](https://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration) this new router, and that the existing router and foundation would be stable and maintained for many releases in the future.应用程序路由器与页面路由器的模型截然不同。这几乎就像一个新框架。这是我们需要确保您可以逐步采用这种新路由器的众多原因之一，并且现有的路由器和基础将在未来的许多版本中保持稳定和维护。\n\nIt's also why we just created a [new free course](https://nextjs.org/learn) to teach the model.这也是为什么我们刚刚创建了一门新的免费课程来教授该模型的原因。\n\nKent then goes on to mention:肯特接着提到：\n\n> Next.js is on version 13. React Router (built by the same team as Remix) has been around for ***much longer*** and is only version 6. Remix was on version 1 for almost two years and only a month ago hit version 2.Next.js 版本为 13。React Router（由与 Remix 相同的团队构建）已经存在了更长的时间，并且只是第 6 版。Remix 在第 1 版上已经使用了将近两年，仅在一个月前才发布了第 2 版。\n\nI don't think the number of major versions correlates to whether a framework is stable or not, especially when we've tried to take great care in publishing [codemods](https://nextjs.org/docs/app/building-your-application/upgrading/codemods) and [upgrade guides](https://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration) when moving between versions.我不认为主要版本的数量与框架是否稳定有关，尤其是当我们在版本之间移动时试图非常小心地发布代码模组和升级指南时。\n\nWe publish major versions when a Node.js version is no longer supported (i.e. when their security lifetime has expired). With [Next.js 14](https://nextjs.org/blog/next-14), for example, the Node.js version was bumped to `18.17`.当不再支持 Node.js 版本时（即，当其安全生存期已过期时），我们会发布主要版本。例如，在 Next.js 14 中，Node.js 版本被提升到 `18.17` .\n\nWe also care deeply about backwards compatibility. The core APIs from day one still work today.我们也非常关心向后兼容性。从第一天起的核心 API 今天仍然有效。\n\n7 years ago today [vercel.com/blog/next](https://vercel.com/blog/next) A walk down memory lane 🧵 The pictured code still works without change……7 年前的今天 vercel.com/blog/next 走在记忆的小路🧵上 图中的代码仍然可以正常工作，无需更改...\n\nKent shares: Kent 分享：\n\n> Earlier this year, the Remix team shared their plans for getting version 2 features released as an opt-in part of version 1 using a strategy called “future flags”.今年早些时候，Remix 团队分享了他们的计划，即使用一种称为“未来标志”的策略将版本 2 功能作为版本 1 的选择加入部分发布。\n\nI love this. We have a similar process in Next.js with experimental flags. We've also done future flags before in [previous releases](https://nextjs.org/blog/next-10-1#3x-faster-refresh). Their [future flags](https://remix.run/blog/future-flags) blog post mentioned is worth reading.我喜欢这个。我们在 Next.js 中有一个类似的过程，带有实验性标志。在以前的版本中，我们也做过未来的标志。他们提到的未来旗帜博客文章值得一读。\n\n## [](#remix-vs-nextjs-for-ecommerce)Remix vs. Next.js for EcommerceRemix vs. Next.js 电子商务\n\nKent mentions an older blog post the Remix team wrote comparing with Next.js:Kent提到了 Remix 团队写的一篇较旧的博客文章，与 Next.js 进行了比较：\n\n> When the Remix team rewrote the Next.js ecommerce demo to answer the “**[Remix vs Next.js](https://remix.run/blog/remix-vs-next)**” question, it demonstrated really well that Remix resulted in a better user experience with much less code (which is an important input in user experience).当 Remix 团队重写 Next.js 电子商务演示以回答“Remix vs Next.js”问题时，它很好地证明了 Remix 以更少的代码带来了更好的用户体验（这是用户体验中的重要输入）。\n\nI'm thankful for the Remix team pushing us to improve Next.js Commerce. The Pages Router version needed some work.我很感谢 Remix 团队推动我们改进 Next.js Commerce。Pages Router 版本需要一些工作。\n\nI'd recommend [re-reading their original blog post](https://remix.run/blog/remix-vs-next) and then viewing the [codebase for Next.js Commerce](https://github.com/vercel/commerce) and [updated demo](https://demo.vercel.store/) so you can [make your own assessment](https://twitter.com/championswimmer/status/1683875753681911816). I wanted to include a link to the Remix demo, but it [appears to be down](https://remix-ecommerce.fly.dev/).我建议重新阅读他们的原始博客文章，然后查看 Next.js Commerce 的代码库和更新的演示，以便您可以进行自己的评估。我想包含一个指向 Remix 演示的链接，但它似乎已关闭。\n\n> I think it's worth making another comparison. Remix has also learned some new tricks since that article was written, like out-of-order streaming.我认为值得再做一次比较。自那篇文章撰写以来，Remix 还学到了一些新技巧，比如乱序流媒体。\n\nThe Next.js App Router [has out-of-order streaming as well](https://gal.hagever.com/posts/out-of-order-streaming-from-scratch), it's fantastic. It's worked [very well](https://twitter.com/rauchg/status/1687591561377525760) for [Next.js Commerce](https://demo.vercel.store/).Next.js 应用程序路由器也有无序流媒体，这太棒了。它对 Next.js Commerce 非常有效。\n\n## [](#conclusion)Conclusion 结论\n\nPhew, that turned out to be a long one. As Kent mentions:呸，原来是很长的。正如 Kent 所提到的：\n\n> I feel like both are highly capable frameworks 我觉得两者都是功能强大的框架\n\nWe agree. You can make great web experiences with both.我们同意。您可以使用两者获得出色的 Web 体验。\n\nWhile I spent most of the post referencing points from Kent, I'd like to end with general reasons why I love using Next.js:虽然我在文章中的大部分时间都引用了肯特的观点，但我想以我喜欢使用 Next.js 的一般原因来结束：\n\n* I never need to write separate backends for projects I want to create. I can build my entire project with Next.js.我永远不需要为我想创建的项目编写单独的后端。我可以用 Next.js 构建我的整个项目。\n* I never have to worry about bundler, compiler, or frontend infrastructure. I get to focus on making great products through React components. And I'm able to use the latest React features, which I personally find to have a great developer experience.我从来不用担心打包器、编译器或前端基础设施。我开始专注于通过 React 组件制作出色的产品。而且我能够使用最新的 React 功能，我个人认为这些功能具有出色的开发人员体验。\n* I am able to update to the latest versions of Next.js and things continue to improve. Performance gets faster and new features get added. The iteration velocity is high. If there are changes, codemods and upgrade guides are provided.我能够更新到最新版本的 Next.js，并且情况继续改善。性能更快，并添加了新功能。迭代速度高。如果有更改，则提供 codemod 和升级指南。\n* Next.js provides a bunch of components that help me keep my site fast. [Images](https://nextjs.org/docs/app/building-your-application/optimizing/images), [fonts](https://nextjs.org/docs/app/building-your-application/optimizing/fonts), [scripts](https://nextjs.org/docs/app/building-your-application/optimizing/scripts), and now even [properly loading third-parties](https://nextjs.org/docs/app/building-your-application/optimizing/third-party-libraries).Next.js 提供了一堆组件来帮助我保持网站快速。图像、字体、脚本，现在甚至可以正确加载第三方。\n\nI was using Next.js before I joined Vercel, and will likely continue to after Vercel as well. I hope my work in the Next.js community can help push the web forward.在加入 Vercel 之前，我一直在使用 Next.js，在加入 Vercel 之后，我也可能会继续使用。我希望我在 Next.js 社区的工作可以帮助推动网络向前发展。\n\nHopefully this post helped share some insight into how Next.js has been evolving and where we see the framework heading in the future.希望这篇文章有助于分享一些关于 Next.js 如何发展以及我们看到框架未来的发展方向的见解。\n","type":"text/markdown","created":"20231103052234862","creator":"太微搜藏","modified":"20231103054937855","modifier":"Lenovo","qrcode":"yes","tags":"剪藏","url":"https://leerob.io/blog/using-nextjs"},{"title":"why-browser-judge","text":"widget 代码一定是跑在 brower 的吗 ???","type":"text/markdown","created":"20230923135352753","creator":"oeyoews","modified":"20230923135520591","modifier":"oeyoews","tags":"?"},{"title":"why-center-tag-deprecated","text":"center 元素已被弃用，因为它定义了其内容的呈现 – 它没有描述其内容。\n\n一种居中的方法是将元素的 margin-left 和 margin-right 属性设置为 auto，然后将父元素的 text-align 属性设置为 center。这将保证元素将集中在所有现代浏览器中。","type":"text/markdown","created":"20231022014825489","creator":"Lenovo","modified":"20231022014854615","modifier":"Lenovo","tags":"HTML"},{"title":"why-tailwindcss","text":"tailwind 的设计思路解决了 css 入门选手对写复杂 css 的恐惧，让新手以一个非常舒适的方式去设计 UI。","type":"text/markdown","created":"20230820070547478","creator":"oeyoews","modified":"20230820070601467","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"why-usereffect","text":"在 React 中，条件判断通常需要使用 `useEffect` 的原因是因为组件的渲染是基于状态和属性的，而不是直接在条件判断中进行的。\r\n\r\n在函数组件中，每当组件的状态或属性发生变化时，组件将重新渲染。这意味着在组件的顶层代码中进行条件判断，可能会导致无限循环的问题。\r\n\r\n使用 `useEffect` 可以在组件��染后执行副作用代码，例如订阅事件、发送网络请求等。在 `useEffect` 中进行条件判断可以确保条件判断的代码只在组件渲染后执行一次，而不会导致无限循环的问题。\r\n\r\n以下是一个示例，演示了在 `useEffect` 中进行条件判断的情况：\r\n\r\n```javascript\r\nimport React, { useEffect } from 'react';\r\n\r\nfunction MyComponent({ value }) {\r\n  useEffect(() => {\r\n    if (value === 'something') {\r\n      // 条件判断的代码只会在组件渲染后执行一次\r\n      console.log('Condition is true');\r\n    }\r\n  }, [value]);\r\n\r\n  return <div>My Component</div>;\r\n}\r\n```\r\n\r\n在上述示例中，当 `value` 属性发生变化时，`useEffect` 将执行条件判断的代码。这样可以确保条件判断只在组件渲染后执行一次，并且在 `value` 发生变化时重新进行判断。\r\n\r\n需要注意的是，不是所有的条件判断都需要使用 `useEffect`。只有在需要在组件渲染后执行条件判断的情况下才需要使用 `useEffect`。如果条件判断不依赖于组件的状态或属性，可以直接在组件的顶层代码中进行判断，而无需使用 `useEffect`。","type":"text/markdown","created":"20230709131022745","creator":"oeyoews","modified":"20230726045248813","modifier":"oeyoews","tags":"React"},{"title":"wifi-slow","text":"电脑连接蓝牙耳机后, 网速就变的很慢 :thinking:","type":"text/markdown","created":"20230612035909008","creator":"oeyoews","modified":"20230726045248813","modifier":"oeyoews","tags":"[[🤔 Thinking]]"},{"title":"wikitext-template","text":"如果你发现你每个条目都要写一段和其他条目里面相同的 wikitext, 你可以使用模板条目来实现自己的模板复用(不需要级联), macro 和 template 有不同的使用场景","type":"text/markdown","created":"20231018001309394","creator":"Lenovo","modified":"20231018001527155","modifier":"Lenovo","tags":"TiddlyWiki"},{"title":"window-global","text":"```js\r\nfunction main() {\r\n  demo = 2;\r\n  console.log(demo);\r\n}\r\n\r\nmain();\r\nconsole.log(demo);\r\n``` \r\n\r\n\r\ndemo = 2 === window.demo = 2","type":"text/markdown","created":"20230920101156217","modified":"20230920101227465","tags":"JavaScript"},{"title":"windows-linux-path-slate","text":"在 windows 上写成 Linux 的路径, 会自动转换, 反过来就对有的命令行不行","type":"text/markdown","created":"20231019122826256","creator":"Lenovo","modified":"20231019122908310","modifier":"Lenovo","tags":""},{"title":"Windows11-comilot","text":"windows11 的 copilot(preview) 拿到又是一个 bing ??? 为什么还有个 preview, 难道还要向 copilot 那样收费吗,感觉很鸡肋\n\n> 但是支持接入系统操作","type":"text/markdown","created":"20231009150050482","creator":"Lenovo","modified":"20231010060647736","modifier":"Lenovo","tags":"windows"},{"title":"windows11-notes","text":":::tip\n<iconify-icon icon=\"fluent:leaf-two-20-regular\" style=\"color: #2c8d11;\" />\nWindows 更新致力于帮助减少碳排放.\n:::\n\n:::note windows notes\n下面是体验糟糕的 windows 的一些糟糕体验笔记\n:::\n\n## windows software\n\n* cloc\n* calibre\n* nodejs  git github-desktop\n* vscode chrome\n* qq wechat \n* v2raya marktext(还是不习惯, 还是用 vscode 吧)  \n* windows terminal\n* flameshot\n\n## NOTES\n\n* winget 的速度还是可以的, 不过有些东西还是从 GitHub 上下载\n\n:::note bluetooth\n- [ ] 蓝牙键盘不能识别到\n:::\n\n:::bug proxy\n- [ ] wsl 代理不能用 v2raya\n- [ ] 同样 uwp 也没有网络,听说 clash 使用 tun 模式可以\n:::\n\n:::tip\n建议直接 install window11, 从 10 升上去真的好久\nwindow11 自带了一些新的字体比如 emoji\n:::\n\n:::tip\nwindows11 自带解压,不需要下载 bandzip 解压缩软件\n:::\n\n:::tip font\n* window 上 edge 的视觉比 Google chrome 字体支持好一点\n:::error\n* maple font 解压失败\n:::\n:::\n\n:::error edge\n\nedge://flage naviagtion to disable\n\n* 即使禁止左右滑动, 但是页面仍然还是抖动\n* edge 的垂直标签还是不习惯\n:::\n\n:::tip onedrive\nonedrive 的自动备份还是挺好用的\n:::\n\n:::note slow on windows\nwsl 或者 windows 不适合写代码, 延迟真的很大, 对于我个人使用惯了 linux 的速度,真的很难接受\n::: \n\n:::note virtualbox\n* virtualbox need efi for manjaro(maybe), 如果直接放大会导致黑屏, 体验也不好, 显示会花屏, 由于 v2raya 在 windows 上不能透明代理, 虚拟机还需要单独设置(放弃了)\n:::\n\n:::example ohmyposh\nhttps://ohmyposh.dev/docs/\n:::note\n配置 ohpyposh 后, 启动会耗时, 在 vscode 中很明显\n* 不支持自动提示\n:::\n:::\n\n:::note git\nuse ssh not https,  ssh-keygen 不是很好用, 总是没有权限\n:::\n\n:::note memory\n软件几乎没开,内存就占了一半了\n:::\n\n:::note music \n~~开一个网易云, 直接占 20%的内存, 离谱, 还不如开个网页,~~ electron 这么吃内存吗,开一个 vscode 就直接飙到 80%\n:::\n\n* darkmode 发虚还不那么明显\n\n\n* 软件管家下载绿色软件自然不会创建快捷方式\n\n:::bug\n电脑修好后的第三天, tw 的 vim(怀疑是 vim 的 bug) 卡掉了, 然后就是浏览器提示无响应, 网易云音乐停止播放, 鼠标无响应,然后绿屏\n* https://answers.microsoft.com/zh-hans/windows/forum/all/%E6%9C%8D%E5%8A%A1%E5%99%A8-8cfc164f-4be5-4fdd/47c8b73e-57c4-4217-8232-8d9b03153bfc?page=1\n* https://www.hanboshi.com/articles/128.html\n* 内存暴了会导致蓝屏?? \n:::\n\n* 新版的 window11 似乎增加了一些 emoji 和一些字体的支持, 不会很模糊了\n* 动画有延迟\n* 鼠标移动不够平滑, 似乎是没有开启平滑启动的区别","type":"text/markdown","created":"20231009123203438","creator":"Lenovo","modified":"20231026093616881","modifier":"Lenovo","tags":""},{"title":"windows11-window-manager","text":":::info komorebi\n不顺手, 动画不流畅自然, 需要搭配 autohotkey, 没有完全集成\n:::\n\n```js\nwinget install komorebi\n```\n\n## Usage\n\n* https://github.com/LGUG2Z/komorebi/wiki/README-zh","type":"text/markdown","created":"20231022133617251","creator":"Lenovo","modified":"20231023060606244","modifier":"Lenovo","tags":""},{"title":"windows环境好恶劣","text":"* windows 下的环境好恶劣, emacs 还没用上, 一堆环境问题, 在 linux 几乎不用关心这些问题, 完全没有在 window 折腾软件的心思, 感觉 windows 才是让我停止了折腾软件.每次下个软件, 都要去每个软件的官网, arch 的 aur 无所不有, 都不用考虑","type":"text/markdown","created":"20231026132016717","creator":"Lenovo","modified":"20231026132409154","modifier":"Lenovo","tags":""},{"title":"winget","text":":::note\nwinget 默认安装 c 盘, winget settings 可以打开配置文件\n:::\n\n```bash\n winget export --accept-source-agreements --output D:\\packages.json\n```\n\n```json\n{\n\t\"$schema\" : \"https://aka.ms/winget-packages.schema.2.0.json\",\n\t\"CreationDate\" : \"2023-10-10T18:10:45.948-00:00\",\n\t\"Sources\" : \n\t[\n\t\t{\n\t\t\t\"Packages\" : \n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"MarkText.MarkText\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"GitHub.GitHubDesktop\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Git.Git\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Google.Chrome\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Lenovo.LeAppStore\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.Edge\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.EdgeWebView2Runtime\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.DevHome\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.WindowsTerminal\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"JanDeDobbeleer.OhMyPosh\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Tencent.WeChat\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Tencent.QQ\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.WindowsInstallationAssistant\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Microsoft.VisualStudioCode\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"v2rayA.v2rayA\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"PackageIdentifier\" : \"Flameshot.Flameshot\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"SourceDetails\" : \n\t\t\t{\n\t\t\t\t\"Argument\" : \"https://cdn.winget.microsoft.com/cache\",\n\t\t\t\t\"Identifier\" : \"Microsoft.Winget.Source_8wekyb3d8bbwe\",\n\t\t\t\t\"Name\" : \"winget\",\n\t\t\t\t\"Type\" : \"Microsoft.PreIndexed.Package\"\n\t\t\t}\n\t\t}\n\t],\n\t\"WinGetVersion\" : \"1.6.2771\"\n}\n```","type":"text/markdown","created":"20231010101301338","creator":"Lenovo","modified":"20231010101419804","modifier":"Lenovo","tags":""},{"title":"WYSWYG","text":"\"WYSIWYG\" 是 \"What You See Is What You Get\" 的缩写，中文翻译为\"所见即所得\"。这个术语通常用于描述一类计算机程序或编辑器，它们允许用户在编辑文档、网页或其他内容时，直接看到最终的呈现效果，而不需要了解或使用复杂的编程代码或标记语言。\n\n\"WYSIWYG\" 编辑器通常提供一个直观的用户界面，使用户可以像编辑纸质文档一样编辑内容，而不必担心后续的格式或排版问题。这种编辑方式对于非技术用户和初学者来说非常友好，因为他们可以轻松地创建内容，而不必深入研究底层技术。\n\n总之，\"WYSIWYG\" 强调了用户在编辑时能够看到最终输出的外观，这一概念在文档处理、网页设计和其他创作领域中得到广泛应用。\n\n:::note WYSWYG\n其实我是不喜欢这类软件的, 因为无法直接修改某个文本, 只能通过键盘或者鼠标进行修改,效率很慢, 看到的永远都不是真实的节点, 这种操作是不透明的, 用户不能明确知道自己做了什么\n:::","type":"text/markdown","created":"20231011104830944","creator":"Lenovo","modified":"20231011105843377","modifier":"Lenovo","tags":"名词"},{"title":"xampp","text":"XAMPP 是一个流行的开源 Web 服务器软件包，适用于 Windows、Linux、Mac OS X 和其他操作系统。它的名字代表\"X\"（代表跨平台）、\"Apache\"（Web 服务器）、\"MySQL\"（数据库）和\"PHP\"（脚本语言）。\r\n\r\nXAMPP 可以让用户在本地计算机上创建和运行 Web 应用程序。它包含了 Apache 服务器、MySQL 数据库、PHP 解释器以及 Perl 语言。使用 XAMPP，您可以搭建一个完整的开发环境，用于开发和测试网站、Web 应用程序和动态内容。\r\n\r\nXAMPP 的安装非常简单，一般只需要下载适用于您操作系统的安装包，然后按照指示进行安装即可。安装完成后，您可以启动 XAMPP 控制面板，从中启动或停止 Apache 和 MySQL 等服务。\r\n\r\n总之，XAMPP 是一个方便的工具，可用于创建和测试 Web 应用程序，以及在本地环境中模拟服务器环境。","type":"text/markdown","created":"20230828070523861","creator":"oeyoews","modified":"20230828070658830","modifier":"oeyoews","tags":""},{"title":"yarn-pnpm","text":"如果 package.json 的 name 有空格获取其他不规范命名, yarn 会检查报错, pnpm 不会","type":"text/markdown","created":"20230831095405451","creator":"oeyoews","modified":"20230831095445457","modifier":"oeyoews","tags":""},{"title":"一次糟糕的体验","text":"* 由于系统多次卡死， 一番折腾后也没找到原因， 直接黑屏了, 开始拿出两年前的 ventoy, 重新安装系统，本来是打算安装 windows 的\r\n\r\n* 下面又是一番折腾\r\n\r\n> ps: usb 一定要买 3.0 的， 读取 iso 真的挺慢的\r\npss: 想要不折腾使用 unxi 的系统的， 经济支持建议直接 mbp\r\npss: 在 linxux 上制作 window 启动盘没有成功过, 后来 ventoy 制作的也报错， 后来使用 etcher 重新 flash,听说 woeusb-ng 是不错的选择， 只是后来卡死了","type":"text/markdown","created":"20231001113545560","creator":"oeyoews","modified":"20231001114458495","modifier":"oeyoews","tags":"gnome"},{"title":"三体","text":"## 刘慈欣 2018 克拉克奖获奖感言\r\n\r\n未来像盛夏的大雨，在我们还不及撑开伞时就扑面而来。\r\n\r\n他从未长大，但从未停止成长”。\r\n\r\n### 第一章 科学边界\r\n\r\n‘科学边界’试图开辟一条新的思维途径，简单地说就是试图用科学的方法找出科学的局限性，试图确定科学对自然界的认知在深度和精度上是否存在一条底线——底线之下是科学进入不了的。\r\n\r\n那你的生活是一种偶然，世界有这么多变幻莫测的因素，你的人生却没什么变故。\r\n\r\n### 第二章 台球\r\n\r\n她像一颗星星，总是那么遥远，照到我身上的光也总是冷的。\r\n\r\n### 第三章 射手和农场主\r\n\r\n“射手”假说：有一名神枪手，在一个靶子上每隔十厘米打一个洞。设想这个靶子的平面上生活着一种二维智能生物，它们中的科学家在对自己的宇宙进行观察后，发现了一个伟大的定律：“宇宙每隔十厘米，必然会有一个洞。”它们把这个神枪手一时兴起的随意行为，看成了自己宇宙中的铁律。“农场主假说”则有一层令人不安的恐怖色彩：一个农场里有一群火鸡，农场主每天中午十一点来给它们喂食。火鸡中的一名科学家观察这个现象，一直观察了近一年都没有例外，于是它也发现了自己宇宙中的伟大定律：“每天上午十一点，就有食物降临。”它在感恩节早晨向火鸡们公布了这个定律，但这天上午十一点食物没有降临，农场主进来把它们都捉去杀了。\r\n\r\n“三天后，也就是十四日，在凌晨一点钟至五点钟，整个宇宙将为你闪烁。”\r\n\r\n### 第五章 叶文洁\r\n\r\n“可只有她一个女人，女人应该像水一样的，什么样的地方都能淌得过去啊。”\r\n\r\n### 第七章 疯狂年代\r\n\r\n在中国，任何超脱飞扬的思想都会砰然坠地的，现实的引力太沉重了。\r\n\r\n### 第八章 寂静的春天\r\n\r\n也许，人类和邪恶的关系，就是大洋与漂浮于其上的冰山的关系，它们其实是同一种物质组成的巨大水体，冰山之所以被醒目地认出来，只是由于其形态不同而已，而它实质上只不过是这整个巨大水体中极小的一部分……人类真正的道德自觉是不可能的，就像他们不可能拔着自己的头发离开大地。要做到这一点，只有借助于人类之外的力量。\r\n\r\n### 第九章 红岸之一\r\n\r\n风中的森林气息文洁很熟悉，她认识这风，这风也认识她，这是大兴安岭的风。\r\n\r\n### 第十章 宇宙闪烁之二\r\n\r\n越透明的东西越神秘，宇宙本身就是透明的，只要目力能及，你想看多远就看多远，但越看越神秘。\r\n\r\n### 第十一章 大史\r\n\r\n要是杀你们有用，它早就把你们杀光了，但最有效的办法还是扰乱你们的思想，人死了还会有别人，但思想乱了，科学就完了。”\r\n\r\n### 第十二章 三体、墨子、烈焰\r\n\r\n小汪啊，其实，你到了我这个年纪，就会发现当年以为天要塌下来的那些大事，其实没有什么的。”\r\n\r\n大家都喜欢念念叨叨地回忆往事，但都希望别人听自己的，而对别人说的都厌烦。\r\n\r\n### 第十四章 红岸之三\r\n\r\n已阅，狗屁不通！大字报在地上贴就行了，不要发到天上去，文革领导组今后不要介入红岸。这样重要的信件应慎重起草，最好成立一个专门小组，并在政治局会议上讨论通过。\r\n\r\n### 第十五章 红岸之四\r\n\r\n地球生命真的是宇宙中偶然里的偶然，宇宙是个空荡荡的大宫殿，人类是这宫殿中唯一的一只小蚂蚁。这想法让我的后半辈子有一种很矛盾的心态：有时觉得生命真珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值一提。反正日子就在这种奇怪的感觉中一天天过去，不知不觉人就老了……”\r\n\r\n### 第十七章 三体问题\r\n\r\n空不是无，空是一种存在，你得用空这种存在填满自己。\r\n\r\n。世界就要发生突变了，每个人能尽量平安地打发完余生，就是大幸了，别的不要想太多，反正没用。”\r\n\r\n### 第十八章 三体、牛顿、冯·诺伊曼、秦始皇、三日连珠\r\n\r\n每个人如此简单的行为，竟产生了如此复杂的大东西！欧洲人骂朕独裁暴政，扼杀了社会的创造力，其实在严格纪律约束下的大量的人，合为一个整体后也能产生伟大的智慧。”\r\n\r\n### 第二十章 三体、爱因斯坦、单摆、大撕裂\r\n\r\n仰望着三体纪念碑气势磅礴的摆动，汪淼问自己：它是表达对规律的渴望，还是对混沌的屈服？\r\n\r\n### 第二十二章 地球叛军\r\n\r\n人类社会已经不可能依靠自身的力量解决自己的问题，也不可能凭借自身的力量抑制自己的疯狂；所以，应该请主降临世界，借助它的力量，对人类社会进行强制性的监督和改造，以创造一个全新的、光明完善的人类文明。\r\n\r\n### 第二十三章 红岸之五\r\n\r\n叶文洁不知道，就在这时，地球文明向太空发出的第一声能够被听到的啼鸣，已经以太阳为中心，以光速飞向整个宇宙。恒星级功率的强劲电波，如磅礴的海潮，此时已越过了木星轨道。这时，在 12000 兆赫波段上，太阳是银河系中最亮的一颗星。\r\n\r\n### 第二十四章 红岸之六\r\n\r\n对人类本质的思考，使叶文洁陷入了深重的精神危机。她首先面临的，是一种奉献目标的缺失，她曾是一个理想主义者，需要将自己的才华贡献给一个伟大的目标，现在却发现，自己以前做的一切全无意义，以后也不可能有什么有意义的追求。这种心态发展下去，她渐渐觉得这个世界是那样的陌生，她不属于这里，这种精神上的流浪感残酷地折磨着她，在组成家庭后，她的心灵反而无家可归了。\r\n\r\n叶文洁感到这条无限长的曲线就是宇宙的抽象，一头连着无限的过去，另一头连着无限的未来，中间只有无规律无生命的随机起伏，一个个高低错落的波峰就像一粒粒大小不等的沙子，整条曲线就像是所有沙粒排成行形成的一维沙漠，荒凉寂寥，长得令人无法忍受。你可以沿着它向前向后走无限远，但永远找不到归宿。\r\n\r\n### 第二十六章 雷志成、杨卫宁之死\r\n\r\n冷静、毫不动感情地做了。我找到了能够为之献身的事业，付出的代价，不管是自己的还是别人的，都不在乎。同时我也知道，全人类都将为这个事业付出史无前例的巨大牺牲，这仅仅是一个微不足道的开始。\r\n\r\n### 第二十七章 无人忏悔\r\n\r\n在叶文洁的记忆中，这段日子不像是属于自己的，仿佛是从别的人生中飘落的片断，像一片羽毛般飞入自己的生活。这段记忆被浓缩成一幅幅欧洲古典油画，很奇怪，不是中国画，就是油画，中国画上空白太多，但齐家屯的生活是没有空白的，像古典的油画那样，充满着浓郁得化不开的色彩。一切都是浓烈和温热的：铺着厚厚乌拉草的火坑、铜烟锅里的关东烟和莫合烟、厚实的高粱饭、六十五度的高粱酒……但这一切，又都在宁静与平和中流逝着，像屯子边上的小溪一样。\r\n\r\n### 第二十八章 伊文斯\r\n\r\n这就是文明的游戏规则，首先要保证人类的生存和他们舒适的生活，其余都是第二位的。\r\n\r\n### 第二十九章 第二红岸基地\r\n\r\n。即使在宇宙尺度上是近在咫尺的四光年，对脆弱的生命来说也是不可想象的遥远，在这太空的江之头和江之尾，任何联系都细若游丝。\r\n\r\n### 第三十章 地球三体运动\r\n\r\n麦克·伊文斯的一句话已成为降临派的座右铭：我们不知道外星文明是什么样子，但知道人类。\r\n\r\n### 第三十一章 两个质子\r\n\r\n在宇宙间，一个技术文明等级的重要标志，是它能够控制和使用的微观维度。\r\n\r\n### 第三十二章 古筝行动\r\n\r\n如果他们能够跨越星际来到我们的世界，说明他们的科学已经发展到相当的高度，一个科学如此昌明的社会，必然拥有更高的文明和道德水准。\r\n\r\n### 第三十三章 监听员\r\n\r\n他感到这条无限长的线就是宇宙的抽象，一头连着无限的过去，另一头连着无限的未来，中间只有无规律无生命的随机起伏，一个个高低错落的波峰就像一粒粒大小不等的沙子，整条线就像是所有沙粒排成行形成的一维沙漠，荒凉寂寥，长得令人无法忍受。你可以沿着它向前向后走无限远，但永远找不到归宿。\r\n\r\n### 第三十四章 智子\r\n\r\n科学技术的全面发展取决于基础科学的发展，而基础科学的基础又在于对物质深层结构的探索，如果这个领域没有进展，科学技术整体上就不可能产生重大突破。\r\n\r\n### 第三十五章 虫子\r\n\r\n把人类看做虫子的三体人似乎忘记了一个事实：虫子从来就没有被真正战胜过。\r\n\r\n### 第三十六章 尾声·遗址\r\n\r\n碑是那么小，与其说是为了纪念，更像是为了忘却。\r\n\r\n### 后记\r\n\r\n城市就是森林，每一个男人都是猎手，每一个女人都是陷阱。\r\n\r\n### 序章\r\n\r\n第一，生存是文明的第一需要；第二，文明不断增长和扩张，但宇宙中的物质总量保持不变。\r\n\r\n### 上部 面壁者\r\n\r\n六十岁和十六岁一样，是人生最美好的年龄，在这个岁数上，四五十岁时的负担已经卸下，七八十岁时的迟缓和病痛还没有来临，是享受生活的时候。\r\n\r\n字幕：这种思维透明度的差别，使我们更坚定了消灭人类的决心。请你们帮助我们消灭人类，最后我们再消灭你们。\r\n\r\n“技术公有化”运动受挫所产生的影响是深远的，它使人们认识到，即使在毁灭性的三体危机面前，人类大同仍是一个遥远的梦想。\r\n\r\n你看经济学的基本公理就是人类的唯利是图，没有这个前提，整个经济学就将崩溃；社会学的基本设定还没有定论，但可能比经济学的更黑暗，真理总沾着灰尘……\r\n\r\n宇宙逃亡根本不可能实现，关键是谁走谁留啊？这不是一般的不平等，这是生存权的问题，不管是谁走，精英也好，富人也好，普通老百姓也好，只要是有人走有人留，那就意味着人类最基本的价值观和道德底线的崩溃！人权和平等观念已经深入人心，生存权的不公平是最大的不公平，被留下的人和国家绝不可能看着别人踏上生路而自己等死，两方的对抗会越来越极端，最后只能是世界大乱，谁也走不了！\r\n\r\n我在工作中有一个原则：从不进行道德判断。\r\n\r\n“北海啊，你还差得远，这么说是因为我现在还能轻易地理解你。能让我理解，说明你的思想还简单，还不够深，等到我看不透搞不懂你，而你能轻易理解我的那一天，你才算真正长大了。”\r\n\r\n当罗辑所乘的飞机飞越海岸时，在他一万米的下方，吴岳和章北海再次注视着建造中的“唐”号。在以前和以后所有的时间里，这是罗辑距这两位军人最近的一次。\r\n\r\n如果你的城府真够深，那就不能显示出任何城府来，和电影上看到的不同，真正老谋深算的人不是每天阴着脸装那副鸟样儿，他们压根儿就不显出用脑子的样儿来，看上去都挺随和挺单纯的，有人显得俗里俗气婆婆妈妈，有人则大大咧咧没个正经……关键的关键是让别人别把你当回事，让他们看不起你轻视你，觉得你碍不了事，像墙角的扫把一样可有可无，最高的境界是让他们根本注意不到你，就当你不存在，直到他们死在你手里前的一刹那才回过味来。”\r\n\r\n“这冷静来自于我的玩世不恭，这世界上很难有什么东西让我在意。”\r\n\r\n大部分人的爱情对象也只是存在于自己的想象之中。他们所爱的并不是现实中的她（他），而只是想象中的她（他），现实中的她（他）只是他们创造梦中情人的一个模板，他们迟早会发现梦中情人与模板之间的差异，如果适应这种差异他们就会走到一起，无法适应就分开，就这么简单。\r\n\r\n只要该想的想到了，该做的做到了，整个过程中要真发生什么，那也随它去，谁也没办法，对不对？别净跟自个儿过不去。\r\n\r\n面壁者所承担的，将是人类历史上最艰难的使命，他们是真正的独行者，将对整个世界甚至整个宇宙，彻底关闭自己的心灵，他们所能倾诉和交流的、他们在精神上唯一的依靠，只有他们自己。他们将肩负着这伟大的使命孤独地走过漫长的岁月，在这里，让我代表人类社会向他们表示深深的敬意。\r\n\r\n因为当一个人成为面壁者后，一层无形的不可穿透的屏障就立刻在他与普通人之间建立起来，他的一切行为就具有了面壁计划的意义，正像那对面壁者的微笑所表达的含义：\r\n我们怎么知道您是不是已经在工作了？\r\n\r\n不不，别说在哪儿！一知道在哪儿，世界就变得像一张地图那么小了；不知道在哪儿，感觉世界才广阔呢。\r\n\r\n我真的不是一名合格的军人，只愿意投身于有胜利希望的战争的军人，不是合格的军人。\r\n\r\n“罗辑的破壁人就是他自己，他需要自己找出他对主的威胁所在。”秦始皇说。\r\n\r\n罗辑特别注意到这里一幅风景画都没有，这是很成熟的审美情调：这幢房子就坐落在绝美的伊甸园中，风景画挂在这里就像往大海中加一桶水那样多余。\r\n\r\n“我说的智力是广义的，除了传统意义上的逻辑推理能力外，还包括学习的能力、想象力和创新能力，包括人在一生中在积累常识和经验的同时仍保持思想活力的能力，还包括加强思维的体力，也就是使大脑不知疲倦地长时间连续思考——这里甚至可以考虑取消睡眠的可能性……”\r\n\r\n我还大概记得《银河英雄传说》中杨威利的一句话：国家兴亡，在此一战，但比起个人的权利和自由来，这些倒算不得什么，各位尽力而为就行了。”\r\n\r\n“我正变成死亡，世界的毁灭者。”艾伦脱口而出。\r\n\r\n她有知识，但那些知识还没有达到学问的程度去僵化她，只是令她对世界和生活更敏感。”\r\n\r\n如果我们不能向后走，就坚定地向前走。\r\n\r\n“爸爸说过，对大自然的美很敏感的人，本质上都是善良的，他们不善良，所以感受不到美。”\r\n\r\n“庄颜，你的工作就是：使自己幸福快乐。”\r\n庄颜睁大了双眼。\r\n“你成为世界上最幸福最快乐的女孩儿，是面壁计划的一部分。”\r\n\r\n你看，仇恨，这比黄金和钻石都宝贵的财富，这世界上最犀利的武器，现在没有了，您也给不了我们，所以，组织和我一样，都活不了多久了。”\r\n\r\n斩尽杀绝，这是对一个文明最高的重视。\r\n\r\n蒙娜丽莎在变形，墙壁也在变形，像消融的冰。卢浮宫崩塌了，砖石在下坠的途中化为红亮的岩浆，这岩浆穿过他们的身体，竟像清泉般清凉。他们也随着卢浮宫下坠，穿过熔化的欧洲大陆，向地心坠去，穿过地心时，地球在周围爆发开来，变成宇宙间绚烂的焰火；焰火熄灭，空间在瞬间如水晶般透明，星辰用晶莹的光芒织成银色的巨毯，群星振动着，奏出华美的音乐；星海在变密，像涌起的海潮，宇宙向他们聚集坍缩……最后，一切都湮没在爱情的创世之光中。\r\n\r\n在巨变的世界中，不变的只有时间流逝的速度\r\n\r\n### 中部 咒语\r\n\r\n“因为在全人类中，你是唯一一个三体文明要杀的人。”\r\n\r\n他注定是一个向高处飞、向远方去的人。\r\n\r\n不要轻视简单，简单意味着坚固，整个数学大厦，都是建立在这种简单到不能再简单，但在逻辑上坚如磐石的公理的基础上。\r\n\r\n#### 危机纪年第 12 年，三体舰队距太阳系 4.18 光年\r\n\r\n“我是相信的，倒不是有什么证据，而是这样做比较保险：如果真有上帝，我们的信仰就对了；如果没有，我们也没什么损失。”\r\n\r\n“这人确实危险，他信念坚定，眼光远大又冷酷无情，行事冷静决断，平时严谨认真，但在需要时，可以随时越出常轨，采取异乎寻常的行动。”\r\n\r\n#### 危机纪年第 20 年，三体舰队距太阳系 4.15 光年\r\n\r\n“这是谁的大脑？”希恩斯在惊叹中问道。“我的。”山杉惠子含情脉脉地看着丈夫，“出现这幅思维图景时，我正在想你。”\r\n\r\n把你们绝望的人，你们迷茫的人，\r\n把你们渴望看到胜利之光的畏惧徘徊的人都给我，\r\n把那些精神失落、灵魂在流浪的人都送来：\r\n在这金色的信念旁，我要为他们把灯举起。\r\n\r\n您以一介武夫的鲁莽制定了这个根本不可能实现的计划，却以一个卓越战略家的老谋深算，坚韧不拔地一步步推进它，面壁者雷迪亚兹，这真的是个悲剧。”\r\n\r\n唯一不可阻挡的是时间，它像一把利刃，无声地切开了坚硬和柔软的一切，恒定地向前推进着，没有任何东西能够使它的行进出现丝毫颠簸，它却改变着一切。\r\n\r\n### 下部 黑暗森林\r\n\r\n给岁月以文明，而不是给文明以岁月。\r\n\r\n给时光以生命，而不是给生命以时光。\r\n\r\n毁灭你，与你有何相干？\r\n\r\n宇宙也曾经光明过，创世大爆炸后不久，一切物质都以光的形式存在，后来宇宙变成了燃烧后的灰烬，才在黑暗中沉淀出重元素并形成了行星和生命。所以，黑暗是生命和文明之母。\r\n\r\n宇宙就是一座黑暗森林，每个文明都是带枪的猎人，像幽灵般潜行于林间，轻轻拨开挡路的树枝，竭力不让脚步发出一点儿声音，连呼吸都小心翼翼……他必须小心，因为林中到处都有与他一样潜行的猎人。如果他发现了别的生命，不管是不是猎人，不管是天使还是魔鬼，不管是娇嫩的婴儿还是步履蹒跚的老人，也不管是天仙般的少女还是天神般的男孩，能做的只有一件事：开枪消灭之。在这片森林中，他人就是地狱，就是永恒的威胁，任何暴露自己存在的生命都将很快被消灭。这就是宇宙文明的图景，这就是对费米悖论的解释。\r\n\r\n他知道要想逃避现实，最好的方式就是深深介入现实之中。\r\n\r\n#### 危机纪年第 208 年，三体舰队距太阳系 2.07 光年\r\n\r\n通过忠实地映射宇宙来隐藏自我，是融入永恒的唯一途径。\r\n\r\n太阳快落下去了，你们的孩子居然不害怕？\r\n“当然不害怕，她知道明天太阳还会升起来的。”\r\n\r\n### 《时间之外的往事》序言（节选）\r\n\r\n我把太阳移到西天，随着阳光角度的变化，田野中禾苗上的水珠一下子晶晶闪亮起来，像突然睁开的无数眼睛。我把阳光调暗些，提前做出一个黄昏，然后遥望着地平线上自己的背影。我挥挥手，那个夕阳前的剪影也挥挥手。看着那个身影，我感觉自己还是很年轻的。\r\n\r\n#### 危机纪元 4 年，云天明\r\n\r\n医治不死病，佛度有缘人。\r\n\r\n云天明的问题在于他无法入世也无法出世，他没有入世的能力也没有出世的资本，只能痛苦地悬在半空。自己今后的人生之路怎么走，通向哪里，他心中一片茫然。\r\n\r\n#### 危机纪元 5-7 年，阶梯计划\r\n\r\n如果千秋功罪真有人评说，现在已经可以派一个人去解释岁月造成的误会。\r\n\r\n### 第二部\r\n\r\n#### 威慑纪元 12 年，“青铜时代”号\r\n\r\n黑暗森林理论对人类文明的影响是极其深刻的：那个篝火余烬旁的孩子，由外向乐观变得孤僻自闭了。\r\n\r\n#### 威慑纪元 13 年，审判\r\n\r\n我没有太多可说的，只有一个警告：生命从海洋登上陆地是地球生物进化的一个里程碑，但那些上岸的鱼再也不是鱼了；同样，真正进入太空的人，再也不是人了。所以，人们，当你们打算飞向外太空再也不回头时，请千万慎重，需付出的代价比你们想象的要大得多。\r\n\r\n#### 威慑纪元 61 年，执剑人\r\n\r\n黑暗森林威慑是悬在两个世界头上的达摩克利斯之剑，罗辑就是悬剑的发丝，他被称为执剑人。\r\n\r\n#### 威慑纪元 62 年，奥尔特星云外，“万有引力”号\r\n\r\n“他们不是杀人犯！如果没有威慑，‘蓝色空间’号现在就是人类延续的唯一希望。可我们现在正和人类的敌人联手追击他们，你一点儿都不觉得耻辱？”\r\n\r\n#### 威慑纪元 62 年 11 月 28 日 16：00 至 16：17，威慑控制中心\r\n\r\n半个世纪前在设计控制中心时曾征求过罗辑的意见，他当时只是简单地说了一句：像坟墓一样简洁。\r\n\r\n#### 威慑后一小时，失落的世界\r\n\r\n这种恐惧归根结底还是对黑暗森林威慑本身的恐惧，这就是终极威慑的特点：威慑者和被威慑者对威慑有着相同的恐惧。\r\n\r\n#### 威慑后第一年，澳大利亚\r\n\r\n这时，太阳系的太空中已经没有人了，只有空荡荡的太空城和战舰飘浮在地球、火星和木星轨道上，飘浮在荒凉的小行星带中，仿佛是一片寂静的金属坟墓，埋葬着人类的光荣与梦想。\r\n\r\n断了的骨头长好后，愈合的断裂处长得比原来还粗，这在医学上叫超量恢复，是说如果人体有机会弥补以前缺少的某些东西，那么这些东西可能恢复到比不缺少它们的人更多。\r\n\r\n“所有的部落都已消失，\r\n所有的长矛都已折断。\r\n在这里，\r\n我们曾经饮露餐花，\r\n而你们，\r\n却撒下一片砾石。”\r\n\r\n所有抵抗运动的成员都知道他们在进行的是一场毫无希望的战斗，将来三体舰队到达地球之日，也就是他们全军覆灭之时。这些在深山和城市的下水道中衣衫褴褛饥肠辘辘的战士，是在为人类最后的尊严而战，他们的存在，是人类这段不堪回首的历史中唯一的亮色。\r\n\r\n“生存本来就是一种幸运，过去的地球上是如此，现在这个冷酷的宇宙中也到处如此。但不知从什么时候起，人类有了一种幻觉，认为生存成了唾手可得的东西，这就是你们失败的根本原因。进化的旗帜将再次在这个世界升起，你们将为生存而战，我希望在座的每个人都在那最后的五千万人之中，希望你们能吃到粮食，而不是被粮食吃掉。”\r\n\r\n#### 威慑纪元最后十分钟，62 年 11 月 28 日 16：17：34 至 16：27：58，奥尔特星云外，“万有引力”号和“蓝色空间”号\r\n\r\n这时，距叶文洁在公元 20 世纪的那个清晨按下那个红色按钮已经三百一十五年了。\r\n\r\n#### 威慑后第一天至第五天，奥尔特星云外，“万有引力”号和“蓝色空间”号\r\n\r\n“方寸之间，深不见底啊。”\r\n\r\n我是墓地，我是死的，谁都不会攻击。不同维度之间没有黑暗森林，低维威胁不到高维，低维的资源对高维没有用。但同维的都是黑暗森林。\r\n\r\n### 第三部\r\n\r\n#### 广播纪元 7 年，程心\r\n\r\n安逸的美梦彻底破灭，黑暗森林理论得到了最后的证实，三体世界被摧毁了。\r\n\r\n#### 广播纪元 7 年，智子\r\n\r\n“宇宙很大，生活更大，也许以后还有缘相见。”\r\n\r\n#### 广播纪元 7 年，云天明\r\n\r\n之所以选择拉格朗日点，只是为了保持会面时位置的稳定，同时，按三体世界在太空中的惯例，天体间的引力平衡点就是约会的地方。\r\n\r\n#### 广播纪元 7 年，云天明的童话\r\n\r\n“我不会让你消失的，公主。”\r\n“你知道，我也知道，我们到不了墓岛，也不可能把深水王子带回来。”\r\n“要是那样，公主，我就永远为你打伞。”\r\n\r\n对于利用空间曲率航行，后来又出现了一个更温和更局部的设想，一艘处于太空中的飞船，如果能够用某种方式把它后面的一部分空间熨平，减小其曲率，那么飞船就会被前方曲率更大的空间拉过去，这就是曲率驱动。\r\n\r\n云天明告诉地球世界：三体光速飞船采用空间曲率驱动。\r\n\r\n三个世纪前他送给了程心一颗星星，三个世纪后他又带给人类一个希望。\r\n\r\n死亡是唯一一座永远亮着的灯塔，不管你向哪里航行，最终都得转向它指引的方向。一切都会逝去，只有死神永生。”\r\n\r\n死亡是唯一一座永远亮着的灯塔，不管你向哪里航行，最终都得转向它指引的方向。一切都会逝去，只有死神永生。\r\n\r\n这个隐喻最终无法解读，如维纳斯的断臂一般。针眼的画成了一个永远的谜，这个情节构成了三个故事的基础，从它所显现出来的典雅的冷酷、精致的残忍和唯美的死亡来看，可能暗示着一个生死攸关的巨大秘密。\r\n\r\n#### 广播纪元 8 年，命运的抉择\r\n\r\n从法律角度讲，至少在目前，没有国际法或国家法律禁止团体或个人建造恒星际飞船，在巨行星背阳面避难也不被看做是逃亡主义，但这里出现了一个人类历史上最大的不平等：在死亡面前的不平等。\r\n\r\n威纳尔说：“如果真发现了光粒，不发警报可能是更好的选择，反正也没什么用。本来嘛，在不知不觉中突然完蛋是一种幸运，你却又要把几十亿人折磨二十四小时，这简直是反人类罪。”\r\n\r\n其实吧，从科学角度讲，毁灭一词并不准确，没有真正毁掉什么，更没有灭掉什么，物质总量一点不少都还在，角动量也还在，只是物质的组合方式变了变，像一副扑克牌，仅仅重洗而已……可生命是一手同花顺，一洗什么都没了。\r\n\r\n一个显而易见的事实：曲率驱动飞船在进入光速的加速段会留下航迹。\r\n\r\n处于幼年的人类文明曾经打开家门向外看了一眼，外面无边的暗夜吓住了他，他面对黑暗中的广袤和深邃打了个寒战，紧紧地关上了门。\r\n\r\n#### 广播纪元 8 年，地日拉格朗日点\r\n\r\n“当这个事业可能危害人类的生命时，必须唤醒我，我将拥有最终的决定权，并可以收回赋予你的一切权力。”\r\n\r\n### 第四部\r\n\r\n#### 掩体纪元 11 年，掩体世界\r\n\r\n这是贫穷和流浪的城市，却也拥有色彩万千的生活，像一幅失重状态下的《清明上河图》。\r\n\r\n太阳落下去了，\r\n山、树、石、河，\r\n一切伟大的建筑都埋在黑影里；\r\n人类很有趣地点了他们的小灯：\r\n喜悦他们所看见的；\r\n希望找着他们所要的。\r\n\r\n#### 掩体纪元 11 年，星环城\r\n\r\n失去人性，失去很多；失去兽性，失去一切。\r\n\r\n#### 掩体纪元 66 年，太阳系外围\r\n\r\n弱小和无知不是生存的障碍，傲慢才是。\r\n\r\n弱小和无知不是生存的障碍，傲慢才是\r\n\r\n#### 掩体纪元 67 年，冥王星\r\n\r\n文明像一场五千年的狂奔，不断的进步推动着更快的进步，无数的奇迹催生出更大的奇迹，人类似乎拥有了神一般的力量……但最后发现，真正的力量在时间手里，留下脚印比创造世界更难，在这文明的尽头，他们也只能做远古的婴儿时代做过的事。\r\n把字刻在石头上。\r\n\r\n罗辑坐在《蒙娜丽莎》旁边，一只老手抚摸着古老的画框，喃喃自语：“我不知道你在这儿，知道的话我会常来看你的。”\r\n\r\n#### 掩体纪元 67 年，二维太阳系\r\n\r\n这是一个死的世界，一张死的画。\r\n\r\n悲伤还没有袭来，就像被利刃划开的伤口，一时还感觉不到痛。\r\n\r\n她两次处于仅次于上帝的位置上，却两次以爱的名义把世界推向深渊，而这一次已没人能为她挽回。\r\n\r\n### 第六部\r\n\r\n#### 银河纪元 409 年，我们的星星\r\n\r\n这样想实在是太自命不凡了，就像你在地面上做一个倒立，就认为自己举起了地球一样。\r\n\r\n“把时针拨过十二点。比如说空间维度，把一个已经跌入低维的宇宙重新拉回高维，几乎不可能；但从另一个方向努力，把宇宙降到零维，然后继续降维，就可能从零的方向回到最初，使宇宙的宏观维度重新回到十维。”\r\n\r\n爱是没错的，一个人不可能毁灭一个世界，如果这个世界毁灭了，那是所有人，包括活着的和逝去的，共同努力的结果。\r\n\r\n#### 时间开始后约 170 亿年，我们的星星\r\n\r\n时间确实是最狠的东西。\r\n\r\n#### 时间之外，我们的宇宙\r\n\r\n“这就是！”关一帆做了一个囊括一切的手势，感慨道，“云天明曾送你一颗星星，现在，他又送你一个宇宙。程心，这是一个宇宙，虽然很小，可确实是一个宇宙。”\r\n\r\n在银河系猎户旋臂的漫漫长夜中，有两颗文明的流星划过，宇宙记住了它们的光芒。","type":"text/markdown","created":"20230929043222217","creator":"oeyoews","modified":"20230929050134659","modifier":"oeyoews","page-cover":"https://cdn.weread.qq.com/weread/cover/80/yuewen_695233/t6_yuewen_6952331677562148.jpg","tags":"books"},{"title":"三目运算符","text":"```js\r\n${ci.isCI && ci.name}  // false\r\n${ci.isCI ? ci.name : ''} ''\r\n```","type":"text/markdown","created":"20230912013658571","modified":"20230912013749438","tags":"JavaScript"},{"title":"为什么github上的绿点变成黄色","text":"为什么[github](https://so.csdn.net/so/search?q=github\\&spm=1001.2101.3001.7020)上面提交记录的绿点变成了黄色呢？ 我当天提交完也是倍感疑惑，以为是页面出了什么 bug 或者是网卡了，我也为此重刷新了很多次， 就像图中的这样\\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191207222146504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzOTU5Mw==,size_16,color_FFFFFF,t_70)\\\n大家看清楚图中的左下角有一个黄色的 Happy Halloween！ 哈哈，我英文不是很好，也没有注意到这个文字。 但是是不是比起绿色更加好看了呢？\\\n因为 10 月 31 号是西方的万圣节，是西方的传统节日。所以 github 为了庆祝吧，也是将传统的绿色换成了黄色至深红，更加的欢庆！！ 希望大家在明年的万圣节也打开自己的 github 看一看， 是不是也色彩斑斓， 更加的喜庆， 再看看自己的努力是否可以让我们看到明年的色彩斑斓呢 》》\n","type":"text/markdown","created":"20231031065359510","creator":"太微搜藏","modified":"20231031065448889","modifier":"Lenovo","tags":"剪藏","url":"https://blog.csdn.net/weixin_43939593/article/details/102830772"},{"title":"为什么一个好的太微入门教程比较难写","text":":::abstract\ntw 内容有很多, 但是不建议在入门教程中一下子全部介绍给用户, 最多简单提及一下, 放个连接, 感兴趣的用户自然后点进去看, 这样既能保持入门教程的简介性, 又不会让用户感到入门内容好多,tw 好难\n:::\n\n<$qrcode renderType=\"url\" width=512/>\n\n## 为什么入门教程比较难写???\n\n由于 tw 可以配合各种工具的使用, 使用方式层出不穷, 不是仅仅介绍 tw 的用法就可以了, 更多的是如何用上 tw, nodejs 版, 单文件版, 结合 app, 手机端, 移动端等等, 每一种使用方式又可以细分为好几种, 每一种使用方式都会导致教程上有细微的差异 tw\n\n![img](https://i.imgur.com/q7Lzf7B.png)\n![img](https://i.imgur.com/j5AAvP4.png)\n\n第一种方式: 看起来很简单, 但是仍然需要用户去探索 tiddlyhost 如何使用(我现在也不会用), 并且访问速度也不是很快;\n第二种方式: 官方提供了一个空的 html 下载连接, 用过的人都知道, 那就是一个 playground, 不配合其他工具根本无法使用;\n\n最后 tw 将选择权交给了用户, 让用户自己选择适合自己的使用方式, 并没有明确表明各种使用方式的优缺点\n\n并且图片中的内容,逻辑性并不强, 很容易误导用户, 没有明确表示每一步的具体原因, 为什么这么做. 缺乏具体细节,过于简短\n\n:::tip\n写出一个好的入门教程需要考虑到很多方面, 需要花费很多时间精力.还要有相关的丰富经验. 一个好的入门教程,看起来很简洁, 其实每一步都是精心设计的. \n:::","type":"text/markdown","created":"20231017015911946","creator":"Lenovo","modified":"20231030013325285","modifier":"Lenovo","tags":""},{"title":"为什么使用external-js","text":"* server: 提高频繁保存效率\r\n* html: 减少内存占用,共享多个 wiki","type":"text/markdown","created":"20230921060811233","creator":"oeyoews","modified":"20230922041408281","modifier":"oeyoews","tags":"TiddlyWiki"},{"title":"为什么我的贡献没有在我的个人资料中显示？GitHub_文档","text":"## [关于您的贡献图](#about-your-contribution-graph)\n\n你的个人资料贡献图是你对 GitHub.com 拥有的存储库所做的贡献的记录。 贡献按照协调世界时 (UTC) 而不是您当地的时区加时间戳。 只有在满足特定标准时才会计算贡献。 在某些情况下，我们可能需要重建您的图表才能显示贡献。\n\n如果您是使用 SAML 单点登录 (SSO) 的组织的成员，则在没有活动的 SSO 会话时，您将无法在配置文件上看到来自该组织的贡献活动。 从组织外部查看您个人资料的用户将看到您组织的贡献活动的匿名贡献活动。\n\n## [计算的贡献](#contributions-that-are-counted)\n\n### [议题、拉取请求和讨论](#issues-pull-requests-and-discussions)\n\n如果问题、拉取请求和讨论在独立的存储库中而非分支中打开，它们将在你的贡献图中显示。\n\n### [提交](#commits)\n\n如果提交符合以下所有条件，则会在贡献图中显示：\n\n* 用于提交的电子邮件地址与你在 GitHub.com 上的帐户关联。\n\n* 提交在独立的仓库而不是复刻中进行。\n\n* 提交在以下位置进行：\n\n  * 在仓库的默认分支中\n  * 在 `gh-pages` 分支（对于具有项目网站的存储库）中\n\n有关项目站点的详细信息，请参阅“[关于 GitHub Pages](https://docs.github.com/zh/pages/getting-started-with-github-pages/about-github-pages#types-of-github-pages-sites)”。\n\n此外，以下至少一项必须为 true：\n\n* 您是仓库中的协作者，或者是拥有该仓库的组织的成员。\n* 您已复刻该仓库。\n* 您已打开仓库中的拉取请求或议题。\n* 您已为仓库加星标。\n\n## [贡献未计算的常见原因](#common-reasons-that-contributions-are-not-counted)\n\n注意：\n\n* 在变基提交时，提交的原作者和提交的变基者（无论是在命令行还是 GitHub.com 上）都会获得贡献积分。\n* 如果合并了多个个人帐户，问题、拉取请求和讨论将不会归因于新帐户，也不会显示在贡献图上。\n\n### [24 小时内进行的提交](#commit-was-made-less-than-24-hours-ago)\n\n进行满足计为贡献要求的提交后，您可能需要等待最长 24 小时才能看到在贡献图中显示的贡献。\n\n### [您的本地 Git 提交电子邮件地址未连接到您的帐户](#your-local-git-commit-email-isnt-connected-to-your-account)\n\n提交必须是使用与你在 GitHub.com 上的帐户连接的电子邮件地址或使用在电子邮件设置中提供给你的 GitHub 提供的 `noreply` 电子邮件地址进行的，这样才能显示在贡献图上。有关 `noreply` 电子邮件地址的详细信息，请参阅“[设置提交电子邮件地址](https://docs.github.com/zh/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-email-preferences/setting-your-commit-email-address#about-commit-email-addresses)”。\n\n可以通过将 `.patch` 添加到提交 URL 的末尾来检查用于提交的电子邮件地址： 例如，以下提交 URL 包括 `.patch`。\n\n<https://github.com/octocat/octocat.github.io/commit/67c0afc1da354d8571f51b6f0af8f2794117fd10.patch>\n\n```plain\nFrom 67c0afc1da354d8571f51b6f0af8f2794117fd10 Mon Sep 17 00:00:00 2001\nFrom: The Octocat <octocat@nowhere.com>\nDate: Sun, 27 Apr 2014 15:36:39 +0530\nSubject: [PATCH] updated index for better welcome message\n```\n\n`From:` 字段中的电子邮件地址是在[本地 git 配置设置](https://docs.github.com/zh/get-started/quickstart/set-up-git)中设置的地址。 在此示例中，用于提交的电子邮件地址为 `octocat@nowhere.com`。\n\n如果用于提交的电子邮件地址未连接到你在 GitHub.com 上的帐户，必须向你在 GitHub.com 上的帐户[添加电子邮件地址](https://docs.github.com/zh/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-email-preferences/adding-an-email-address-to-your-github-account)。 您的贡献图将在添加新地址后自动重建。\n\n注意：如果使用托管用户帐户，则不能向帐户添加其他电子邮件地址，即使向标识提供者 (IdP) 注册了多个电子邮件地址也是如此。 因此，只有由注册到 IdP 的主电子邮件地址创作的提交才能与托管用户帐户相关联。\n\n通用电子邮件地址（如 `jane@computer.local`）无法添加到 GitHub 帐户，也不能关联到提交。 如果你用一个通用电子邮件地址创作了任何提交，这些提交将不会与你的 GitHub 个人资料相关联，也不会显示在你的贡献图中。\n\n### [未在默认分支或 `gh-pages` 分支中执行提交](#commit-was-not-made-in-the-default-or-gh-pages-branch)\n\n仅发生在默认分支或 `gh-pages` 分支（对于包含项目网站的存储库）中的提交才会计入。 有关详细信息，请参阅“[关于 GitHub Pages](https://docs.github.com/zh/pages/getting-started-with-github-pages/about-github-pages#types-of-github-pages-sites)”。\n\n如果提交位于非默认或非 `gh-pages` 分支中，并且你希望将其计入你的贡献，则需要执行以下操作之一：\n\n* [打开拉取请求](https://docs.github.com/zh/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request)，将更改合并到默认分支或 `gh-pages` 分支中。\n* [更改存储库的默认分支](https://docs.github.com/zh/repositories/configuring-branches-and-merges-in-your-repository/managing-branches-in-your-repository/changing-the-default-branch)。\n\n警告：更改存储库的默认分支将会更改所有存储库协作者的默认分支。 仅当您希望新分支成为进行所有未来拉取请求和提交的基础时才执行此操作。\n\n### [提交在复刻中进行](#commit-was-made-in-a-fork)\n\n在复刻中进行的提交不会计入您的贡献。 要将其计入，您必须执行以下操作之一：\n\n* [打开拉取请求](https://docs.github.com/zh/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request)，将更改合并到父存储库中。\n* 要拆离分叉并将其变成 GitHub.com 上的独立存储库，请联系 [GitHub 支持](https://support.github.com/contact?tags=docs-generic)。 如果分支有自己的分支，请说明分支是应与你的存储库一起移至新网络，还是保留在当前网络中。 有关详细信息，请参阅“[关于分叉](https://docs.github.com/zh/pull-requests/collaborating-with-pull-requests/working-with-forks/about-forks)”。\n\n## [延伸阅读](#further-reading)\n\n* \"[在个人资料上显示你的私有贡献和成就](https://docs.github.com/zh/account-and-profile/setting-up-and-managing-your-github-profile/managing-contribution-settings-on-your-profile/showing-your-private-contributions-and-achievements-on-your-profile)\"\n* “[在个人资料中查看贡献](https://docs.github.com/zh/account-and-profile/setting-up-and-managing-your-github-profile/managing-contribution-settings-on-your-profile/viewing-contributions-on-your-profile)”\n","type":"text/markdown","created":"20231031065343805","creator":"太微搜藏","modified":"20231031065458907","modifier":"Lenovo","tags":"剪藏","url":"https://docs.github.com/zh/account-and-profile/setting-up-and-managing-your-github-profile/managing-contribution-settings-on-your-profile/why-are-my-contributions-not-showing-up-on-my-profile"},{"title":"人世间","text":"","type":"text/markdown","created":"20220206185539951","creator":"Lenovo","modified":"20231017090116869","modifier":"Lenovo","tags":"电视剧"},{"title":"人生大事","text":"","type":"text/markdown","created":"20231015090649117","creator":"Lenovo","modified":"20231015090858762","modifier":"Lenovo","tags":"电视剧"},{"title":"什么是落地页","text":"https://zhuanlan.zhihu.com/p/149734024","type":"text/markdown","created":"20230628134403327","creator":"oeyoews","modified":"20230726045248404","modifier":"oeyoews"},{"title":"以编程思维的方式使用wikitext","text":":::abstract\n下面使用借助 <$iconify icon=\"logos:javascript\" /> 代码让你更好的了解 wiki 中的一些变量使用, 官方文档关于变量的相关内容很全, 但是你会发现, 在每个链接中跳来跳去, 每个说的都很局限, 关联性不是很强,感觉文档很全了, 但是总给人一种奇怪的感觉, 似乎文档还差点啥, 挫败感十足, 必须需要自己慢慢的摸索, 效率很低, 没有一篇系统的介绍变量使用的文章\n:::\n\n```js\nconst title = 'tiddlywiki'\nconst formateTitle = `${title}: 这是一个变量`\n```\n\n```wikitext\n<$set name=\"title\" value=\"tiddlywiki\">\n{{{ [<title>] }}}\n</$set>\n\n// 你可能看到了一些title在整个set标签内都是有效的, 可以理解为js中的变量作用域, js中使用变量的方式除了直接使用就是模板字符串的形式, 但是在wikitext中很复杂, 因为有不同的使用场景, 比如在 filter中 要使用<>包裹起来, 在macro中要使用<____>>包裹起来, 而且还有一些隐性变量 比如在wikitext中可以直接写 !!title, 获取json中的某个值要使用 ##title\n```\n\n<$set name=\"title\" value=\"tiddlywiki\">\n{{{ [<title>] }}}\n</$set>\n\n:::success\nwikitext 关联性极强, 每部分都需要其他部分的相关知识作为铺垫, 所以这也就是为什么一边看不懂的原因, 就好比你在学习第一章节的内容,  <$iconify icon=\"twemoji:teacher\" /> 告诉你说, 这个现在不需要理解, 后面会讲到的; 但是阅读文档的时候没有人会告诉我们\n:::\n\n## 循环\n\nenlist 是一个不错的操作符号, [[tailwind-color-list]]","type":"text/markdown","created":"20231018001757215","creator":"Lenovo","modified":"20231021020911899","modifier":"Lenovo","publish":"article","tags":"TiddlyWiki"},{"title":"伪元素","text":"<label class=\"block\">\r\n  <span class=\"after:content-['*'] after:ml-0.5 after:text-red-500 block text-sm font-medium text-slate-700\">\r\n    Email\r\n  </span>\r\n  <input type=\"email\" name=\"email\" class=\"mt-1 px-3 py-2 bg-white border shadow-sm border-slate-300 placeholder-slate-400 focus:outline-none focus:border-sky-500 focus:ring-sky-500 block w-full rounded-md sm:text-sm focus:ring-1\" placeholder=\"you@example.com\" />\r\n</label>","type":"text/markdown","created":"20230710150421979","creator":"oeyoews","modified":"20230726045248406","modifier":"oeyoews","tags":"Tailwindcss"},{"title":"使用_Fetch_-_Web_API_接口参考___MDN","text":"[Fetch API](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API) 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。\n\n这种功能以前是使用 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 实现的。Fetch 提供了一个更理想的替代方案，可以很容易地被其他技术使用，例如 [`Service Workers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API \"Service Workers\")。Fetch 还提供了专门的逻辑空间来定义其他与 HTTP 相关的概念，例如 [CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS) 和 HTTP 的扩展。\n\n请注意，`fetch` 规范与 `jQuery.ajax()` 主要有以下的不同：\n\n* 当接收到一个代表错误的 HTTP 状态码时，从 `fetch()` 返回的 Promise **不会被标记为 reject**，即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve（如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 [`ok`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok \"ok\") 属性为 false），仅当网络故障时或请求被阻止时，才会标记为 reject。\n* `fetch` **不会发送跨域 cookie**，除非你使用了 *credentials* 的[初始化选项](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch#%E5%8F%82%E6%95%B0)。（自 [2018 年 8 月](https://github.com/whatwg/fetch/pull/585)以后，默认的 credentials 政策变更为 `same-origin`。Firefox 也在 61.0b13 版本中进行了修改）\n\n一个基本的 fetch 请求设置起来很简单。看看下面的代码：\n\n```plain\nfetch(\"http://example.com/movies.json\")\n  .then((response) => response.json())\n  .then((data) => console.log(data));\n```\n\n这里我们通过网络获取一个 JSON 文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想 `fetch()` 到的资源路径，然后返回一个包含响应结果的 promise（一个 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象）。\n\n当然它只是一个 HTTP 响应，而不是真的 JSON。为了获取 JSON 的内容，我们需要使用 [`json()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/json \"json()\") 方法（该方法返回一个将响应 body 解析成 JSON 的 promise）。\n\n**备注：** [Body](#body) 还有其他相似的方法，用于获取其他类型的内容。\n\n最好使用符合[内容安全策略 (CSP)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy)的链接而不是使用直接指向资源地址的方式来进行 fetch 的请求。\n\n### [支持的请求参数](#支持的请求参数)\n\n`fetch()` 接受第二个可选参数，一个可以控制不同配置的 `init` 对象：\n\n参考 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch)，查看所有可选的配置和更多描述。\n\n```plain\n// Example POST method implementation:\nasync function postData(url = \"\", data = {}) {\n  // Default options are marked with *\n  const response = await fetch(url, {\n    method: \"POST\", // *GET, POST, PUT, DELETE, etc.\n    mode: \"cors\", // no-cors, *cors, same-origin\n    cache: \"no-cache\", // *default, no-cache, reload, force-cache, only-if-cached\n    credentials: \"same-origin\", // include, *same-origin, omit\n    headers: {\n      \"Content-Type\": \"application/json\",\n      // 'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    redirect: \"follow\", // manual, *follow, error\n    referrerPolicy: \"no-referrer\", // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url\n    body: JSON.stringify(data), // body data type must match \"Content-Type\" header\n  });\n  return response.json(); // parses JSON response into native JavaScript objects\n}\n\npostData(\"https://example.com/answer\", { answer: 42 }).then((data) => {\n  console.log(data); // JSON data parsed by `data.json()` call\n});\n```\n\n注意：`mode: \"no-cors\"` 仅允许使用一组有限的 HTTP 请求头：\n\n* `Accept`\n* `Accept-Language`\n* `Content-Language`\n* `Content-Type` 允许使用的值为：`application/x-www-form-urlencoded`、`multipart/form-data` 或 `text/plain`\n\n### [发送带凭据的请求](#发送带凭据的请求)\n\n为了让浏览器发送包含凭据的请求（即使是跨域源），要将 `credentials: 'include'` 添加到传递给 `fetch()` 方法的 `init` 对象。\n\n```plain\nfetch(\"https://example.com\", {\n  credentials: \"include\",\n});\n```\n\n**备注：** 当请求使用 `credentials: 'include'` 时，响应的 `Access-Control-Allow-Origin` 不能使用通配符 \"`*`\"。在这种情况下，`Access-Control-Allow-Origin` 必须是当前请求的源，在使用 CORS Unblock 插件的情况下请求仍会失败。\n\n如果你只想在请求 URL 与调用脚本位于同一起源处时发送凭据，请添加 `credentials: 'same-origin'`。\n\n```plain\n// The calling script is on the origin 'https://example.com'\n\nfetch(\"https://example.com\", {\n  credentials: \"same-origin\",\n});\n```\n\n要改为确保浏览器不在请求中包含凭据，请使用 `credentials: 'omit'`。\n\n```plain\nfetch(\"https://example.com\", {\n  credentials: \"omit\",\n});\n```\n\n### [上传 JSON 数据](#上传_json_数据)\n\n使用 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) POST JSON 数据\n\n```plain\nconst data = { username: \"example\" };\n\nfetch(\"https://example.com/profile\", {\n  method: \"POST\", // or 'PUT'\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify(data),\n})\n  .then((response) => response.json())\n  .then((data) => {\n    console.log(\"Success:\", data);\n  })\n  .catch((error) => {\n    console.error(\"Error:\", error);\n  });\n```\n\n### [上传文件](#上传文件)\n\n可以通过 HTML `<input type=\"file\" />` 元素，[`FormData()`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData \"FormData()\") 和 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 上传文件。\n\n```plain\nconst formData = new FormData();\nconst fileField = document.querySelector('input[type=\"file\"]');\n\nformData.append(\"username\", \"abc123\");\nformData.append(\"avatar\", fileField.files[0]);\n\nfetch(\"https://example.com/profile/avatar\", {\n  method: \"PUT\",\n  body: formData,\n})\n  .then((response) => response.json())\n  .then((result) => {\n    console.log(\"Success:\", result);\n  })\n  .catch((error) => {\n    console.error(\"Error:\", error);\n  });\n```\n\n### [上传多个文件](#上传多个文件)\n\n可以通过 HTML `<input type=\"file\" multiple />` 元素，[`FormData()`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData \"FormData()\") 和 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 上传文件。\n\n```plain\nconst formData = new FormData();\nconst photos = document.querySelector('input[type=\"file\"][multiple]');\n\nformData.append(\"title\", \"My Vegas Vacation\");\nfor (let i = 0; i < photos.files.length; i++) {\n  formData.append(`photos_${i}`, photos.files[i]);\n}\n\nfetch(\"https://example.com/posts\", {\n  method: \"POST\",\n  body: formData,\n})\n  .then((response) => response.json())\n  .then((result) => {\n    console.log(\"Success:\", result);\n  })\n  .catch((error) => {\n    console.error(\"Error:\", error);\n  });\n```\n\n### [逐行处理文本文件](#逐行处理文本文件)\n\n从响应中读取的分块不是按行分割的，并且是 `Uint8Array` 数组类型（不是字符串类型）。如果你想通过 `fetch()` 获取一个文本文件并逐行处理它，那需要自行处理这些复杂情况。以下示例展示了一种创建行迭代器来处理的方法（简单起见，假设文本是 UTF-8 编码的，且不处理 `fetch()` 的错误）。\n\n```plain\nasync function* makeTextFileLineIterator(fileURL) {\n  const utf8Decoder = new TextDecoder(\"utf-8\");\n  const response = await fetch(fileURL);\n  const reader = response.body.getReader();\n  let { value: chunk, done: readerDone } = await reader.read();\n  chunk = chunk ? utf8Decoder.decode(chunk) : \"\";\n\n  const re = /\\n|\\r|\\r\\n/gm;\n  let startIndex = 0;\n  let result;\n\n  for (;;) {\n    let result = re.exec(chunk);\n    if (!result) {\n      if (readerDone) {\n        break;\n      }\n      let remainder = chunk.substr(startIndex);\n      ({ value: chunk, done: readerDone } = await reader.read());\n      chunk = remainder + (chunk ? utf8Decoder.decode(chunk) : \"\");\n      startIndex = re.lastIndex = 0;\n      continue;\n    }\n    yield chunk.substring(startIndex, result.index);\n    startIndex = re.lastIndex;\n  }\n  if (startIndex < chunk.length) {\n    // last line didn't end in a newline char\n    yield chunk.substr(startIndex);\n  }\n}\n\nasync function run() {\n  for await (let line of makeTextFileLineIterator(urlOfFile)) {\n    processLine(line);\n  }\n}\n\nrun();\n```\n\n### [检测请求是否成功](#检测请求是否成功)\n\n如果遇到网络故障或服务端的 CORS 配置错误时，[`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) promise 将会 reject，带上一个 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 对象。虽然这个情况经常是遇到了权限问题或类似问题——比如 404 不是一个网络故障。想要精确的判断 `fetch()` 是否成功，需要包含 promise resolved 的情况，此时再判断 [`Response.ok`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok) 是否为 true。类似以下代码：\n\n```plain\nfetch(\"flowers.jpg\")\n  .then((response) => {\n    if (!response.ok) {\n      throw new Error(\"Network response was not OK\");\n    }\n    return response.blob();\n  })\n  .then((myBlob) => {\n    myImage.src = URL.createObjectURL(myBlob);\n  })\n  .catch((error) => {\n    console.error(\"There has been a problem with your fetch operation:\", error);\n  });\n```\n\n### [自定义请求对象](#自定义请求对象)\n\n除了传给 `fetch()` 一个资源的地址，你还可以通过使用 [`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request \"Request()\") 构造函数来创建一个 request 对象，然后再作为参数传给 `fetch()`：\n\n```plain\nconst myHeaders = new Headers();\n\nconst myRequest = new Request(\"flowers.jpg\", {\n  method: \"GET\",\n  headers: myHeaders,\n  mode: \"cors\",\n  cache: \"default\",\n});\n\nfetch(myRequest)\n  .then((response) => response.blob())\n  .then((myBlob) => {\n    myImage.src = URL.createObjectURL(myBlob);\n  });\n```\n\n`Request()` 和 `fetch()` 接受同样的参数。你甚至可以传入一个已存在的 request 对象来创造一个拷贝：\n\n```plain\nconst anotherRequest = new Request(myRequest, myInit);\n```\n\n这个很有用，因为 request 和 response bodies 只能被使用一次（译者注：这里的意思是因为设计成了 stream 的方式，所以它们只能被读取一次）。创建一个拷贝就可以再次使用 request/response 了，当然也可以使用不同的 `init` 参数。创建拷贝必须在读取 body 之前进行，而且读取拷贝的 body 也会将原始请求的 body 标记为已读。\n\n**备注：** [`clone()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/clone \"clone()\") 方法也可以用于创建一个拷贝。它和上述方法一样，如果 request 或 response 的 body 已经被读取过，那么将执行失败。区别在于， `clone()` 出的 body 被读取不会导致原 body 被标记为已读取。\n\n使用 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 的接口，你可以通过 [`Headers()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/Headers \"Headers()\") 构造函数来创建一个你自己的 headers 对象。一个 headers 对象是一个简单的多键值对：\n\n```plain\nconst content = \"Hello World\";\nconst myHeaders = new Headers();\nmyHeaders.append(\"Content-Type\", \"text/plain\");\nmyHeaders.append(\"Content-Length\", content.length.toString());\nmyHeaders.append(\"X-Custom-Header\", \"ProcessThisImmediately\");\n```\n\n也可以传入一个多维数组或者对象字面量：\n\n```plain\nconst myHeaders = new Headers({\n  \"Content-Type\": \"text/plain\",\n  \"Content-Length\": content.length.toString(),\n  \"X-Custom-Header\": \"ProcessThisImmediately\",\n});\n```\n\n它的内容可以被获取：\n\n```plain\nconsole.log(myHeaders.has(\"Content-Type\")); // true\nconsole.log(myHeaders.has(\"Set-Cookie\")); // false\nmyHeaders.set(\"Content-Type\", \"text/html\");\nmyHeaders.append(\"X-Custom-Header\", \"AnotherValue\");\n\nconsole.log(myHeaders.get(\"Content-Length\")); // 11\nconsole.log(myHeaders.get(\"X-Custom-Header\")); // ['ProcessThisImmediately', 'AnotherValue']\n\nmyHeaders.delete(\"X-Custom-Header\");\nconsole.log(myHeaders.get(\"X-Custom-Header\")); // null\n```\n\n虽然一些操作只能在 [`ServiceWorkers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API \"ServiceWorkers\") 中使用，但是它提供了更方便的操作 Headers 的 API。\n\n如果使用了一个不合法的 HTTP Header 属性名，那么 Headers 的方法通常都抛出 TypeError 异常。如果不小心写入了一个不可写的属性（[见下方](#guard)），也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。例如：\n\n```plain\nconst myResponse = Response.error();\ntry {\n  myResponse.headers.set(\"Origin\", \"http://mybank.com\");\n} catch (e) {\n  console.log(\"Cannot pretend to be a bank!\");\n}\n```\n\n最好在在使用之前检查内容类型 `content-type` 是否正确，比如：\n\n```plain\nfetch(myRequest)\n  .then((response) => {\n    const contentType = response.headers.get(\"content-type\");\n    if (!contentType || !contentType.includes(\"application/json\")) {\n      throw new TypeError(\"Oops, we haven't got JSON!\");\n    }\n    return response.json();\n  })\n  .then((data) => {\n    /* process your data further */\n  })\n  .catch((error) => console.error(error));\n```\n\n### [Guard](#guard)\n\n由于 Headers 可以在 request 中被发送或者在 response 中被接收，并且规定了哪些参数是可写的，Headers 对象有一个特殊的 guard 属性。这个属性没有暴露给 Web，但是它影响到哪些内容可以在 Headers 对象中被操作。\n\n可能的值如下：\n\n* `none`：默认的。\n* `request`：从 request 中获得的 headers（[`Request.headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/headers)）只读。\n* `request-no-cors`：从不同域（[`Request.mode`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/mode) `no-cors`）的 request 中获得的 headers 只读。\n* `response`：从 response 中获得的 headers（[`Response.headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/headers)）只读。\n* `immutable`：在 ServiceWorkers 中最常用的，所有的 headers 都只读。\n\n**备注：** 你不可以添加或者修改一个 guard 属性是 `request` 的 Request Header 的 `Content-Length` 属性。同样地，插入 `Set-Cookie` 属性到一个 response header 是不允许的，因此，Service Worker 中，不能给合成的 Response 设置 cookie。\n\n## [Response 对象](#response_对象)\n\n如上所述，[`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 实例是在 `fetch()` 处理完 promise 之后返回的。\n\n你会用到的最常见的 response 属性有：\n\n* [`Response.status`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/status) — 整数（默认值为 200）为 response 的状态码。\n* [`Response.statusText` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText \"Currently only available in English (US)\") — 字符串（默认值为 \"\"），该值与 HTTP 状态码消息对应。注意：HTTP/2 [不支持](https://fetch.spec.whatwg.org/#concept-response-status-message)状态消息\n* [`Response.ok`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok) — 如上所示，该属性是来检查 response 的状态是否在 200 - 299（包括 200 和 299）这个范围内。该属性返回一个布尔值。\n\n它的实例也可用通过 JavaScript 来创建，但只有在 [`ServiceWorkers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API \"ServiceWorkers\") 中使用 [`respondWith()`](https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/respondWith \"respondWith()\") 方法并提供了一个自定义的 response 来接受 request 时才真正有用：\n\n```plain\nconst myBody = new Blob();\n\naddEventListener(\"fetch\", (event) => {\n  // ServiceWorker intercepting a fetch\n  event.respondWith(\n    new Response(myBody, {\n      headers: { \"Content-Type\": \"text/plain\" },\n    }),\n  );\n});\n```\n\n[`Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response \"Response()\") 构造方法接受两个可选参数—— response 的 body 和一个初始化对象（与[`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request \"Request()\") 所接受的 init 参数类似）。\n\n**备注：** 静态方法 [`error()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/error_static \"error()\") 只是返回了错误的 response。与此类似地，[`redirect()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/redirect_static \"redirect()\") 只是返回了一个可以重定向至某 URL 的 response。这些也只与 Service Worker 有关。\n\n## [Body](#body)\n\n不管是请求还是响应都能够包含 body 对象。body 也可以是以下任意类型的实例。\n\n* [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)\n* [`ArrayBufferView`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) (Uint8Array 等)\n* [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)/File\n* string\n* [`URLSearchParams`](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams)\n* [`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData)\n\nBody 类定义了以下方法（这些方法都被 [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request) 和 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)所实现）以获取 body 内容。这些方法都会返回一个被解析后的 Promise 对象和数据。\n\n* [`Request.arrayBuffer()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/arrayBuffer) / [`Response.arrayBuffer()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/arrayBuffer)\n* [`Request.blob()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/blob) / [`Response.blob()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/blob)\n* [`Request.formData()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/formData) / [`Response.formData()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/formData)\n* [`Request.json()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/json) / [`Response.json()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/json)\n* [`Request.text()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/text) / [`Response.text()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/text)\n\n相比于 XHR，这些方法让非文本化数据的使用更加简单。\n\n请求体可以由传入 body 参数来进行设置：\n\n```plain\nconst form = new FormData(document.getElementById(\"login-form\"));\nfetch(\"/login\", {\n  method: \"POST\",\n  body: form,\n});\n```\n\nrequest 和 response（包括 `fetch()` 方法）都会试着自动设置 `Content-Type`。如果没有设置 `Content-Type` 值，发送的请求也会自动设值。\n\n## [特性检测](#特性检测)\n\nFetch API 的支持情况，可以通过检测 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers), [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request), [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 或 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 是否在 [`Window`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window) 或 [`Worker`](https://developer.mozilla.org/zh-CN/docs/Web/API/Worker) 域中来判断。例如：\n\n```plain\nif (window.fetch) {\n  // run my fetch request here\n} else {\n  // do something with XMLHttpRequest?\n}\n```\n\n## [Polyfill](#polyfill)\n\n如果要在不支持的浏览器中使用 Fetch，可以使用 [Fetch Polyfill](https://github.com/github/fetch)。\n\n## [参见](#参见)\n","type":"text/markdown","created":"20231101050213128","creator":"太微搜藏","modified":"20231101050213128","modifier":"太微搜藏","tags":"剪藏","url":"https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch"},{"title":"信息茧房","text":"\"信息茧房\"一词通常用来形容当一个人过度沉迷于网络和数字技术，封闭在一个虚拟的信息世界中，与现实世界和社交互动减少的状态。它指的是人们在数字设备和在线平台的包围中，对现实世界的关注和参与程度降低。\r\n\r\n当人们过度沉迷于社交媒体、视频游戏、电子设备等虚拟世界的信息泛滥中时，他们可能会在自己的舒适区内保持安全，并与外部世界的现实挂钩减少。这种情况可能导致以下几个问题：\r\n\r\n1. 社交隔离：人们在信息茧房中可能减少了与现实世界的社交互动，与家人、朋友和社区的联系减少。他们可能更倾向于通过在线社交媒体与他人交流，而忽视了面对面的交流和社交互动。\r\n\r\n2. 现实世界失衡：信息茧房使人们更容易陷入虚拟世界中，而忽视现实世界的问题和挑战。他们可能会错过重要的生活事件、个人发展机会和社会问题，导致与现实世界脱节。\r\n\r\n3. 心理健康问题：长时间停留在信息茧房中可能导致社交焦虑、孤独感、注意力不集中和自我认同问题等心理健康问题。过度依赖虚拟世界和社交媒体也可能导致对自己的不健康比较、身体形象焦虑等问题。\r\n\r\n为了避免陷入信息茧房的困境，以下是一些建议：\r\n\r\n1. 限制使用时间：设定合理的上网时间，确保在虚拟世界和现实世界之间取得平衡。确保有足够的时间进行户外活动、与亲朋好友面对面交流等现实世界的体验。\r\n\r\n2. 多样化兴趣爱好：培养多样化的兴趣爱好，不仅仅局限于数字设备和在线娱乐。参与体育运动、艺术创作、社区活动等现实世界的活动，丰富自己的生活体验。\r\n\r\n3. 意识到虚拟世界的局限性：虚拟世界是一种娱乐和交流工具，但它并不能完全替代现实世界。意识到虚拟世界的局限\r\n\r\n性，学会平衡和管理自己的在线时间。\r\n\r\n4. 建立健康的社交关系：保持与家人、朋友和社区的联系，通过面对面的交流建立真实、有意义的社交关系。\r\n\r\n5. 关注心理健康：如果感到自己过度依赖虚拟世界或遇到心理健康问题，请及时寻求专业的心理咨询和支持。\r\n\r\n总之，信息茧房是一个警示，提醒我们在数字时代中保持平衡和意识到现实世界的重要性。我们应该积极参与现实生活，与他人建立联系，拥抱多样化的体验，并合理地利用数字技术来增强生活品质。\r\n\r\n[[信息茧房的形成]]","type":"text/markdown","created":"20230623160417914","creator":"oeyoews","modified":"20230726045248408","modifier":"oeyoews","publish":"public"},{"title":"信息茧房的形成","text":"信息茧房的形成是由于多种因素的综合作用。以下是一些可能导致信息茧房形成的主要因素：\r\n\r\n1. 上瘾性设计：许多数字产品和在线平台采用了上瘾性的设计和心理激励，旨在引起用户的注意和持续参与。例如，社交媒体中的无限滚动、自动播放功能、点赞和评论等机制，以及游戏中的奖励和成就系统等，都能够吸引用户并让他们不断追求更多的信息和反馈。\r\n\r\n2. 个性化推荐算法：许多应用使用个性化推荐算法，根据用户的兴趣、行为和偏好，自动推送与其相关的内容。这种算法能够不断向用户展示符合其兴趣的内容，使用户很难抗拒点击和浏览更多的信息。\r\n\r\n3. 社交压力和群体效应：社交媒体的普及使人们渴望与他人保持连接，并获得来自社交圈子的认可和关注。通过在社交媒体上分享自己的生活、观点和成就，人们会不断追求点赞、评论和分享，以满足社交压力和获得群体效应的满足感。\r\n\r\n4. 便利性和娱乐性：数字设备和在线平台提供了便利和娱乐，可以满足人们的各种需求，如获取信息、娱乐、购物、社交等。这种便利性和娱乐性使人们更倾向于沉迷于数字世界，而忽视了现实世界的需求和挑战。\r\n\r\n5. 缺乏时间管理和自制力：当人们没有有效的时间管理和自制力时，他们很容易陷入信息过载和沉迷于数字世界。缺乏意识和控制，导致他们花费过多的时间在社交媒体、视频游戏和其他在线活动上，而忽视了其他重要的生活方面。\r\n\r\n[[视频信息流鸦片]]","type":"text/markdown","created":"20230623160518995","creator":"oeyoews","modified":"20230726045248409","modifier":"oeyoews","publish":"public"},{"title":"修复idea无法启动","text":"`archlinux-java set java-jdk-openjdk`\r\n\r\n```archlinux\r\njava.lang.UnsupportedClassVersionError: com/intellij/idea/Main has been compiled by a more recent version of the Java Runtime (class file version 61.0), this version of the Java Runtime only recognizes class file versions up to 55.0\r\n```\r\n\r\n\r\n系统 jdk 版本太低, 在 2023-2.1-1 之后需要高版本 jdk, 之前是 11","type":"text/markdown","created":"20230826150831116","creator":"oeyoews","modified":"20230826151030524","modifier":"oeyoews","tags":""},{"title":"兜底","text":"在 JavaScript 中，所谓的\"兜底\"是指在代码执行出现异常情况时，可以给出一个备用方案，避免程序崩溃或不可用的情况。","type":"text/markdown","created":"20230421082847072","creator":"oeyoews","modified":"20230421082901383","modifier":"oeyoews","tags":"JavaScript"},{"title":"关于Git的礼节","text":"（这里的内容本来是《[怎样尊重一个程序员](http://www.yinwang.org/blog-cn/2015/03/03/how-to-respect-a-programmer)》的一小节，但由于 Git 的使用引起了很普遍的不尊重程序员的现象，现在特别将这一节提出来单独成文。）\n\nGit 是现在最流行的代码版本控制工具。用外行话说，Git 就是一个代码的“仓库”或者“保管”，这样很多人修改了代码之后，可以知道是谁改了哪一块。其实不管什么工具，不管是编辑器，程序语言，还是版本控制工具，比起程序员的核心思想来，都是次要的东西，都是起辅助作用的。可是 Git 这工具似乎特别惹人恼火。\n\nGit 并不像很多人吹嘘的那么好用，其中有明显的蹩脚设计。跟 Unix 的传统一脉相承，Git 没有一个良好的包装，设计者把自己的内部实现细节无情地泄露给了用户，让用户需要琢磨者设计者内部到底怎么实现的，否则很多时候不知道该怎么办。用户被迫需要记住挺多稀奇古怪的命令，而且命令行的设计也不怎么合理，有时候你需要加-f 之类的参数，各个参数的位置可能不一致，而且加了还不一定能起到你期望的效果。各种奇怪的现象，比如”head detached”，都强迫用户去了解它内部是怎么设计的。随着 Git 版本的更新，新的功能和命令不断地增加，后来你终于看到命令行里出现了 foreach，才发现它的命令行就快变成一个（劣质的）程序语言。如果你了解[ydiff](https://github.com/yinwang0/ydiff)的设计思想，就会发现 Git 之类基于文本的版本控制工具，其实属于古代的东西。然而很多人把 Git 奉为神圣，就因为它是 Linus Torvalds 设计的。\n\nGit 最让人恼火的地方并不是它用起来麻烦，而是它的“资深用户”们居高临下的态度给你造成的心理阴影。好些人因为自己“精通 Git”就以为高人一等，摆出一副专家的态度。随着用户的增加，Git 最初的设计越来越被发现不够用，所以一些约定俗成的规则似乎越来越多，可以写成一本书！跟 Unix 的传统一脉相承，Git 给你很多可以把自己套牢的“机制”，到时候出了问题就怪你自己不知道。所以你就经常听有人煞有介事的说：“并不是 Git 允许你这么做，你就可以这么做的！Unix 的哲学是不阻止傻人做傻事……” 如果你提交代码时不知道 Git 用户一些约定俗成的规则，就会有人嚷嚷：“rebase 了再提交！” “不要 push 到 master！” “不要 merge！” “squash commits！” 如果你不会用 git submodule 之类的东西，有人可能还会鄙视你，说：“你应该知道这些！”\n\n打个比方，这样的嚷嚷给人的感觉是，你得了奥运会金牌之后，把练习用的器材还回到器材保管科，结果管理员对你大吼：“这个放这边！那个放那边！懂不懂规矩啊你？” 看出来问题了吗？程序员提交了有高价值的代码（奥运金牌），结果被一些自认为 Git 用的很熟的人（器材保管员）厉声呵斥。\n\n一个尊重程序员的公司文化，就应该把程序员作为运动健将，把程序员的代码放在尊贵的地位。其它的工具，都应该像器材保管科一样。我们尊重这些器材保管员，然而如果运动员们不懂你制定的器材摆放规矩，也应该表示出尊重和理解，说话应该和气有礼貌，不应该骑到他们头上。所以，对于 Git 的一些命令和用法，我建议大家向新手介绍时，这样开场：“你本来不该知道这些的，可是现在我们没有更好的工具，所以得这样弄一下……”\n","type":"text/markdown","created":"20231030052742101","creator":"太微搜藏","modified":"20231030052742101","modifier":"太微搜藏","tags":"剪藏","url":"https://www.yinwang.org/blog-cn/2015/03/11/git-etiquette"},{"title":"关于太微中文翻译","text":"## 关于太微中文翻译 <$iconify icon=\"ri:translate\" />\n\n:::question 问题\n如果你在看太微翻译文档的时候总是会遇到很多不理解的问题, 原因大致有两个: \n:::\n\n## 语言问题\n\n:::abstract 语言问题\n太微 <$iconify icon=\"simple-icons:tiddlywiki\" style=\"color:black white\"/> 的中文翻译几乎是按照英文直接翻译过来的,大致就是机翻和人工润色, 但是中文翻译的作者是台湾人(应该), 他们的很多表达其实和我们的表达方式也不一样, 虽然不要求机翻的文章能够信达雅, 但是还是达不到正常水平(就是平常所谓的说人话), 很多地方都不分和我们的表达习惯(也许可以借助 ai, 让翻译过来的文章通俗易懂, 说人话\n:::\n\n## 文档问题\n\n:::info 文档问题\n太微的文档其实更多介绍更多的是 wikitex 的使用(内容真的很多, 不要想着一次看完, 看完了也记不住不会用), 文档虽然有一部分教程, 但其实并没有很简化, 文字内容任然非常多,结构上基本是平铺式, 并没有层层递进(希望来一次 <$iconify icon=\"logos:react\" /> 的文档那种大变革,精美的插图, 流畅的行文结构)\n所有的文档掺杂在一起, 没有进行难度区分, 用户不会知道自己大致在看哪个程度的教程,挫败感会很强, tw 其实学习曲线是逐渐上升然后趋于平缓的, 但是文档可能会打破这个规律. 用户可能会花上额外几倍的感觉去入门, 然后找到属于自己的工作流\n:::\n\n:::bug 开发者\n太微的文档其实并没有得到很好的维护, 甚至每种语言的翻译层次不齐, 无奈之下有的时候找不到文档, 就直接翻英文文档了, 甚至有的地方根本没有文档, 只能看源码去找(真羡慕 <$iconify icon=\"logos:vue\" /> 的翻译, vue 用的人多了, 文档啥的也都很齐全了)\n:::\n\n## 结语\n\n:::success 结语\n其实归根结底就是生态没有形成. 贡献者不够. 人多力量大, 希望每一个 太微人(TiddlyWikians) 都可以贡献自己的一份力量, 让他更加友好易用. \n\n太微算是一个小众软件, 希望他像 <$iconify icon=\"logos:vim\" /> <$iconify icon=\"logos:emacs\" /> 成为你的其中一把瑞士军刀.\n:::\n\n:::warning\n以上内容来自 <$avatar inline link=\"https://github.com/oeyoews\" class=\"hover:scale-125 animate-bounce\"/>, 可能会有错误之处, 写于 <$iconify icon=\"meteocons:falling-stars-fill\" class=\"scale-150\" /> 2023/10/16 21:12\n:::","type":"text/markdown","created":"20231016123713564","creator":"Lenovo","modified":"20231018061953713","modifier":"Lenovo","publish":"article","tags":""},{"title":"关于梦","text":"梦被遗忘的原因可以有多个解释：\n\n1. 大脑过滤：大脑在睡眠过程中会进行信息筛选和整理，以帮助我们整理思维和记忆。大部分梦境是由于大脑在清理并整理白天的记忆和情绪，而不是真正需要长期保存的信息。因此，大脑会将无关紧要的梦境信息过滤掉，使其不被存储到长期记忆中。\n\n2. 睡眠阶段：梦境通常发生在快速眼动睡眠（REM）阶段，这是睡眠过程中一个相对短暂且重复出现的阶段。REM 阶段的脑电活动与清醒状态下的脑电活动非常相似，但身体肌肉却处于麻痹状态，以避免我们在梦境中动作。由于 REM 阶段的特殊性质，一些梦境可能更容易在醒来后被忘记。\n\n3. 注意力和意识转移：当我们从睡眠中醒来时，注意力和意识会迅速从梦境中转移到现实生活中。这种转移过程可能导致我们忘记梦境内容，因为我们的大脑更专注于当前的感知和任务。\n\n4. 缺乏意义和情节连贯性：许多梦境是离散、不连贯或缺乏明确的情节和意义。由于它们在逻辑上不一致或没有实际意义，这些梦境往往更容易被遗忘，因为我们的大脑更倾向于记住有意义和相关的信息。\n\n综上所述，梦被遗忘的原因是多方面的，包括大脑过滤、睡眠阶段、注意力转移和梦境特性等。但也有些梦境会长时间留在记忆中，这可能因个体差异、梦境的情感强度和重要性等因素而异。\n\n梦境中的事物不符合常理的原因可以从以下几个方面进行解释：\n\n1. 大脑活动：梦境是由大脑在睡眠中产生的一种虚构体验。在梦境中，大脑的活动与清醒状态下的思维和感知有所不同。梦境往往涉及到非逻辑性的情节和场景，这是因为大脑在梦境中解离了现实的限制，创造出了与日常经验不同的虚拟世界。\n\n2. 记忆和情绪：梦境可能与我们的记忆和情绪有关。大脑会在梦境中重新组合和重组我们白天的记忆片段，形成新的场景和情节。这个过程可能导致不符合常理的情况出现，因为记忆的片段被重新组合并与其他信息结合。\n\n3. 潜意识和隐喻：梦境中的不符合常理的元素可能反映出我们内心深处的潜意识和隐喻。梦境是我们内心世界的一种表达方式，通过不寻常或离奇的情节，梦境可能暗示着我们的情感、欲望、恐惧等。\n\n4. 大脑过滤和整理：正常情况下，大脑会在白天过滤和整理我们的感知和思维，以使其符合逻辑和现实。而在睡眠中，大脑放松了过滤和整理的机制，导致了梦境中不符合常理的事物出现。\n\n需要注意的是，每个人的梦境都是独特的，可能有不同的解释。梦境的含义和理解可以因个体差异、文化背景和生活经历而异。因此，对于梦境中的不符合常理的事物，没有一种固定的解释，而是需要从个体和心理角度进行分析和理解。","type":"text/markdown","created":"20231030080143298","creator":"Lenovo","modified":"20231030080233699","modifier":"Lenovo","tags":"知识"},{"title":"关于系统条目和影子条目的总结","text":":::warning\n以下总结通过查阅 TiddlyWiki 官方文档和个人实践总结得出, 不保证绝对正确. 写于 2023-06-13; v5.30.prelease(lastest) 不再更新\n:::\n\t\n:::tip\n📚 系统条目和影子条目属于不同的划分, 不是一定属于交集\n:::\n\n## shadow\n\n```plain \n[all[shadows]]\n```\n\n被修改过的影子条目\n\n```plain \n[!is[system]is[shadow]]\n```\n\n匹配规则: 未使用`$:/` 开头插件条目, 同时被用户修改过\n\n注意插件的条目被 tw 加载过后都算是 影子条目, 只不过默认不匹配, 需要加 `all` 操作符\n\n```plain\n[all[shadows]is[shadow]]\n```\n\n:::tip\n* 影子条目一定来自插件\n* 只要使用$:/ 开头的就是系统条目, 但是系统条目不一定都是插件条目\n:::\n\n:::warning\n`tag` 操作符只是针对非系统条目有效\n:::\n\n*[影子条目]: 是来自插件内加载的条目。与一般条目不同的是它们不出现在大多数清单\n\n*[系统条目]: 条目名称以特殊字符串 $:/ 开头，会被视为系统条目\n\n## 练习测试\n\n:::todo\n* 创建几个条目: `$:/手动创建的系统条目`, `$:/手动创建的系统条目`, `普通条目01` `普通条目02`\n:::\n\n> Coming ... :hand:\n\n> add filter here to test \n\n\nhttps://talk.tiddlywiki.org/t/problem-system-links-and-freelink-plugin/7270/3","type":"text/markdown","created":"20230613021039755","creator":"oeyoews","modified":"20231017102754279","modifier":"Lenovo","publish":"article","tags":"TiddlyWiki"},{"title":"内部外部方法","text":"为了使`sayName`方法在实例之间共享，我们可以使用原型（prototype）来优化代码。使用原型的方式，可以将方法定义在构造函数的原型对象上，从而使所有实例对象都共享同一个方法。\r\n\r\n下面是使用原型来优化`Student`构造函数的示例代码：\r\n```js\r\nclass Student {\r\n    constructor(name, gender, age) {\r\n        this.name = name;\r\n        this.gender = gender;\r\n        this.age = age;\r\n    }\r\n    sayName() {\r\n        console.log(this.name); \r\n    }\r\n}\r\n```\r\n\r\n```javascript\r\nfunction Student(name, gender, age) {\r\n  this.name = name;\r\n  this.gender = gender;\r\n  this.age = age;\r\n}\r\n\r\nStudent.prototype.sayName = function() {\r\n  console.log(\"我是\" + this.name);\r\n}\r\n\r\nlet 小明 = new Student(\"小明\", '男', 12);\r\nlet 小红 = new Student(\"小红\", '女', 13);\r\n\r\n小明.sayName(); // -> \"我是小明\"\r\n小红.sayName(); // -> \"我是小红\"\r\n```\r\n\r\n在上面的代码中，我们将`sayName`方法定义在`Student`构造函数的原型对象上，而不是在构造函数内部定义。这样，所有使用`Student`构造函数创建的实例对象都可以共享同一个`sayName`方法。\r\n\r\n接着，我们创建了两个`Student`实例对象`小明`和`小红`，并分别调用它们的`sayName`方法，输出了它们的姓名。\r\n\r\n需要注意的是，使用原型定义方法时，方法中的`this`关键字指向的是调用该方法的实例对象，而不是构造函数本身。因此，在`sayName`方法中的`this.name`实际上是指实例对象的`name`属性，而不是构造函数的`name`属性。\r\n\r\n* https://juejin.cn/post/7241114001323819063\r\n* https://www.bilibili.com/video/BV11h411F7nd/?spm_id_from=333.1007.tianma.4-2-12.click&vd_source=d6afd7eedd9f9c940321c63f0a1539e3","type":"text/markdown","created":"20230606014925596","creator":"oeyoews","modified":"20230726045248360","modifier":"oeyoews","tags":"JavaScript"},{"title":"函数柯里化","text":"```js\r\n// bind 也可以用来部分应用一个函数（柯里化）。\r\nvar product = function(a, b){ return a * b; }\r\nvar doubler = product.bind(this, 2);\r\ndoubler(8); // = 16\r\n```\r\n\r\n`bind` 方法也可以用来实现函数的部分应用（partial application），也称为函数柯里化（currying）。\r\n\r\n函数的部分应用是指固定函数的一个或多个参数，生成一个新的函数。这个新函数只需要接收剩余的参数，就可以完成原函数的调用。通过部分应用，我们可以将一个接收多个参数的函数转换为一个接收少量参数的函数，从而可以更加灵活地复用函数。\r\n\r\n在上面的例子中，我们定义了一个乘法函数 `product`，然后使用 `bind` 方法将其部分应用到参数 `2` 上，生成一个新的函数 `doubler`。这个新函数只需要接收一个参数 `b`，然后将其与 `2` 相乘，就可以得到原来函数的结果。通过部分应用，我们将原来需要两个参数的函数转换为只需要一个参数的函数，从而可以更加方便地使用这个函数。\r\n\r\n需要注意的是，`bind` 方法可以同时绑定多个参数，而且可以在绑定参数的同时改变函数的 `this` 值。如果部分应用后的函数还需要继续部分应用，可以再次调用 `bind` 方法。","type":"text/markdown","created":"20230607043231525","creator":"oeyoews","modified":"20230726045248280","modifier":"oeyoews","tags":"JavaScript"},{"title":"利用ts-check对JavaScript进行静态类型检测","text":"我们知道 TypeScript 2.3 以后的版本支持使用`--checkJs`对`.js`文件进行类型检查和错误提示。 但是由于 JavaScript 是弱类型语言，在编写代码的时候，是无法检测变量的类型的。\n\n因此每次运行代码类型报错的时候，我心中都会冒出来一个强烈的愿望：要是 JavaScript 是强类型的多好！\n\n好消息是，JSDoc 的 `@ts-check`，可以现实这个愿望。\n\n## [#](#立即上手) 立即上手\n\n如果能有机会使用 TypeScript 那当然是最好，但是往往开发的老项目在早期都是 JavaScript 完成的，如果都迁移到 TypeScript 版本工作量是庞大的，而且不可避免出现许多 bug 问题，那么有没有一种方式可以无痛的在使用 JavaScript 的同时享受到 TypeScript 的类型检查呢？\n\n答案就是 `// @ts-check`，在 js 文件的头部引入这样一行注释，然后配合`JSDoc`就可以在 JavaScript 代码中使用 TypeScript 的类型检查了。\n\n举个例子，在下图中我们首先声明了一个变量 a，然后把数字 1 赋给了它，接着又把字符串 '1' 赋给了它，看起来好像没有什么问题，而且运行起来也不会报错。\n\n然后我们加上 `// @ts-check` 试试：\n\n神奇的一幕出现了，在变量 a 赋值的下面，出现了红色波浪线，鼠标放上去提示：\n\n![](https://user-images.githubusercontent.com/23518990/70406434-a92fc080-1a7b-11ea-896f-2c286548ea8b.png)\n\n也就是说我们将一个字符串赋值给了一个数字类型的变量是有问题的，这个时候我们未运行程序，但是编辑器已经帮我们分析出了代码可能存在的问题，这时候我们运行代码，是没有报错的。\n\n因为这个类型检测只是让我们按照 TypeScript 的强类型语言检测类型问题，但是我们依然是 JavaScript 代码依然会按照 JavaScript 的代码逻辑运行，如是 TypeScript 代码的话，这里运行就会报错。\n\n## [#](#jsdoc-类型标记) JSDoc 类型标记\n\n既然 ts-check 这么好用，我们来看看 JSDoc 类型的注释支持哪些类型的检测。\n\n根据官方文档，JSDoc 现在支持下面几个类型检测：\n\n* `@type`\n\n- `@param` (or `@arg` or `@argument`)\n\n* `@returns` (or `@return`)\n\n- `@typedef`\n\n* `@callback`\n\n- `@template`\n\n* `@class` (or `@constructor`)\n\n- `@this`\n\n* `@extends` (or `@augments`)\n\n- `@enum`\n\n下面我们选择常用的标记进行说明，更多更详细的标记可以参考[官方文档](https://www.tslang.cn/docs/handbook/type-checking-javascript-files.html)。\n\n### [#](#type) @type\n\n描述：用来声明变量的类型。\n\n### [#](#param和-returns) @param 和@returns\n\n描述：`@param`语法和`@type`相同，但增加了一个参数名。\n\n### [#](#typedef) @typedef\n\n描述：`@typedef` 可以用来声明复杂类型，和`@param`类似的语法。\n\n> 可以在第一行上使用`object`或`Object`。\n\n## [#](#实验要求) 实验要求\n\n经测试，在 `VSCode` 和`IDEA`下可以直接使用`ts-check` 的类型检测，`sublime`等编辑器不可以，应该是要下载对应的插件才可以。\n\n## [#](#写在最后) 写在最后\n\n对于老项目，使用 `// @ts-check` 和 `JSDoc` 来来享受 TypeScript 类型系统的好处是最简单、学习成本最低的方法。\n\n而对于新项目，则更加推荐直接使用 TypeScript 来进行代码编写，并且各大框架里面都是用的 TypeScript 进行的代码编写，在可期的未来，TypeScript 将会越来越受欢迎。\n","type":"text/markdown","created":"20231030084033852","creator":"太微搜藏","modified":"20231030094654171","modifier":"Lenovo","tags":"剪藏","url":"https://daotin.netlify.app/fw8lsf.html#jsdoc-%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0"},{"title":"剪藏","text":":::tip 剪藏\n剪藏内容\n:::","type":"text/markdown","created":"20231016002929793","creator":"Lenovo","modified":"20231016003034963","modifier":"Lenovo"},{"title":"加载动画","text":"加载动画是第一印象，令人惊艳的加载动画能带来不少的趣味性。当然，没有加载动画能够带来更高效的体验。","type":"text/markdown","created":"20230903032647089","creator":"oeyoews","modified":"20230903032714057","modifier":"oeyoews","tags":""},{"title":"卡片翻转显示答案","text":"```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Card Flip</title>\r\n    <link\r\n      rel=\"stylesheet\"\r\n      href=\"https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css\"\r\n    />\r\n    <style>\r\n      .card {\r\n        perspective: 1000px;\r\n        display: inline-block;\r\n      }\r\n\r\n      .card-inner {\r\n        width: 200px;\r\n        height: 300px;\r\n        transition: transform 0.6s;\r\n        transform-style: preserve-3d;\r\n      }\r\n\r\n      .card.flipped .card-inner {\r\n        transform: rotateY(180deg);\r\n      }\r\n\r\n      .card-face {\r\n        position: absolute;\r\n        width: 100%;\r\n        height: 100%;\r\n        backface-visibility: hidden;\r\n      }\r\n\r\n      .card-front {\r\n        background-color: #f2f2f2;\r\n        color: #333;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        font-size: 24px;\r\n      }\r\n\r\n      .card-back {\r\n        background-color: #333;\r\n        color: #f2f2f2;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        font-size: 24px;\r\n        transform: rotateY(180deg);\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div class=\"flex justify-center items-center h-screen\">\r\n      <div class=\"card\" onclick=\"flipCard(event)\">\r\n        <div class=\"card-inner\">\r\n          <div class=\"card-face card-front\">Question</div>\r\n          <div class=\"card-face card-back\">Answer</div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <script>\r\n      function flipCard(event) {\r\n        const card = event.currentTarget;\r\n        card.classList.toggle(\"flipped\");\r\n      }\r\n    </script>\r\n  </body>\r\n</html>\r\n```","type":"text/markdown","created":"20230928125125527","creator":"oeyoews","modified":"20230928125157547","modifier":"oeyoews","tags":"HTML"},{"title":"同步服务端条目","text":"https://bramchen.github.io/tw5-docs/zh-Hans/#Hidden%20Setting%3A%20Sync%20Polling%20Interval\n\nhttps://talk.tiddlywiki.org/t/could-we-reduce-the-frequency-of-autosave/3593\nhttps://talk.tiddlywiki.org/t/could-we-reduce-the-frequency-of-autosave/3593\n\n```plain\n指定 Syncadaptor 在服务器和浏览器之间同步条目的间隔时间。\n\n默认值为 \"60000\" (60 * 1000 毫秒 = 1 分).\n\n变更需要重新启动才能生效。\n```\n\n`$:/core/module/sync.js`\n\n* 原来是一分钟刷新一次, 时间这么久, 之前以为是不会自动刷新呢,(也许可以手动触发)\n\n:::question\n* 有可以从 server 段手动触发更新的机制吗\n:::","type":"text/markdown","created":"20231031123408856","creator":"Lenovo","modified":"20231031124409505","modifier":"Lenovo","tags":"TiddlyWiki"},{"title":"名词","text":"<$echarts $tiddler=\"addon/tagpie.js\" filter=[tag[名词]] toolbox=\"show\" width=4 doughnut='' title=\"含有名词的 tiddler\" legend='yes' $theme='light'/>","type":"text/markdown","created":"20231011115331285","creator":"Lenovo","modified":"20231013125248167","modifier":"Lenovo","tags":""},{"title":"周爱民：告前端同学书","text":"> 一年前，InfoQ 的编辑约请我对前端技术做了些回顾总结，说了三个方面的话题：其一，前端过去的 15 年大致可以怎样划分；其二，前端的现状以及面临的挑战；其三，前端会有怎样的未来。后来刊发成综述，是《技术 15 年》。缘于文体变动，访谈的味道十不存一，所以这里再次整理成文，是为《告前端同学书》。\n\n作者：周爱民 / aimingoo\n\n> 编者按：本文作者周爱民确认出席由前端圈主办的第六届 FEDAY。FEDAY 将于 2023 年 11 月 18 日在杭州举办。本文经作者本人授权发布。\n\n各位前端同学，就我的所知来看，每⼀个具体的技术，在其⽅向上都有着不同的标志事件，也因此有着不同的阶段划分。但是我想，如果从我们这个领域对“前端”的认识来观察这件事，⼤概会对不同的前端阶段能有更清晰的认识。\n\n早期前端的从业⼈员⼤多来⾃后端开发者、应⽤软件开发者，或者⽹⻚设计师，⽽并没有专职的前端开发。例如说阿⾥巴巴在 2010 年之前都把前端归在产品部⻔，可⻅前端⼯程师的来源和定位⼀直都很模糊。这个时代，ECMAScript 还陷在 Ed4 的泥坑中没有⾛出来，IE 浏览器带来的标准分裂还没有得到全⾯的修补，源于对这个领域的漠视，⼤⼚优势也没有体现出来，前端开发者们基本上各⾃为战，框架和中间件层出不穷⽽⼜良莠难分，开发⼯具和环境却荒草凄凄以⾄于乏善可陈。但是也正是在这个时代，ES6、CSS3、HTML5 等等都在筑基、渗透与蓄势。\n\n随着专⽤⼯具链和开发流程的成熟，前后端分离的运动从项⽬内部开始蔓延到整个领域，出现了专⻔的前端开发⼯程师、团队，以及随之⽽来的⻆⾊细分，很多独⽴的技术社区就是在这个时代出现的。前后端分离不仅仅是⼀种技术表现，更是⼀种⾏业协作的模式与规范，并且反过来推动了⼯具和框架的⼤发展。信⼼满满的前端不拘于⼀城⼀地，⼀⽅⾯向前、向专业领域推进，从⽽影响到交互与接触层。因此更丰富的界⾯表现，以及从移动设备到⼈机交互界⾯等领域都成了前端的研究⽅向，是所谓“⼤前端”。⽽另⼀⽅⾯则向后、向系统领域渗透，有了所谓⼯程师“全栈化”运动。这个时候的“全栈”，在⼯程上正好符合敏捷团队的需求，在实践上正好⼜叠加上 DevOPS、云端开发和⼩应⽤的⼏阵助⼒，前端因此⼀⽚繁华景象。\n\n所以 2008 年左右开始的前后端分离是整个前端第⼆阶段的起点，这场运动改变了软件开发的体系与格局，为随后⼗年的前端成熟期拓开了局⾯。那⼀年的 SD2C 我谈了《VCL 已死、RAD 已死》，⽽⼗年后阿⾥的圆⼼在 GMTC 上讲了《前端路上的思考》，可算作对这个时代的预⾔和反思。\n\n相对于之前所说的第⼀、第⼆阶段，我认为如今我们正⾏进在⼀个全新阶段中。这个阶段初起的主要表现是：前端分离为独⽴领域，并向前、后两个⽅向并进之举已然势微。其关键在于，前端这个领域中的内容已经逐渐复杂，⽽其应⽤的体量也将愈加庞⼤，因此再向任何⽅向发展都难尽全⼒、难得全功。\n\n摊⼦铺得⼤了，就需要再分家。所以下⼀个阶段中，将再次发⽣横向的领域分层，⼀些弥合层间差异的技术、⽅法与⼯具也将出现，类似于 Babel 这样的“嵌缝膏”产品将会再次成为⼀时热⻔。但⻓期来说，领域分层带来的是更专精的职业与技能，跨域协作是规约性的、流程化的，以及⼯具适配的。从 ECMAScript 的实践来看，规范的快速更新和迭代已经成为现实，因此围绕规范与接⼝的新的开发技术与⼯程模型，将会在这个阶段中成为主要⼒量，并成为维持系统稳定性的主要⼿段。\n\n这是在⼀个新阶段的前夜。故此，有很多信息并不那么明朗，⽐如说像前后端分离这样的标志性事件并没有出现，亦或者出现了也还没有形成典型影响。我倾向于认为引领新时代的，或者说开启下⼀个阶段的运动将会发⽣在交互领域，也就是说新的交互⽅式决定了前端的未来。之前⾏业⾥在讲的 VR 和 AR（虚拟现实和增强实境）是在这个⽅向上的典型技术，但不唯于此。⼏乎所有在交互⽅式上的变⾰，都会成为⼈们认识与改变这个世界的全新动⼒，像语⾳识别、视觉捕捉、脑机接⼝等等，这些半成熟的或者实验性的技术都在影响着我们对“交互”的理解，从⽽也重新定义了前端。\n\n⾏业⽣态也会重构，如同今天的前端⼤会已经从“XX 技术⼤会”中分离出来⼀样，不久之后“交互”也会从前端分化出来，设计、组件化、框架与平台等等也会成体系地分化出来。前端会变得⽐后端更复杂、更多元，以及更加的⽣机勃勃。这样的⽣态起来了，⼀个新的时代也就来临了。简单地说，1、要注重领域与规范，2、要跟进交互与体验，3、要在⽣态中看到机会。\n\n然而，前端的同学们，我们也不要忘记在这背景中回望自身，正视我们前端自己的问题。\n\n其⼀，底⼦还是薄，前端在技术团队与社区的积累上仍然不够。看起来摊⼦是铺开了，但是每每只在“如何应⽤”上下功夫，真正在⽹络、系统、语⾔、编译、机器学习等等⽅⾯有深⼊研究的并不多。⼀直以来，真正有创建性或预⻅性的思想、⽅法与理论鲜⻅于前端，根底薄是⾸要原因。\n\n其⼆，思维转换慢，有些技术与思想抛弃得不够快，不够彻底。不能总是把核⼼放在“三⼤件（JS+CSS+HTML）”上⾯，核⼼要是不变，前端的⾰命也就不会真正开始。要把“Web 前端”前⾯的“Web”去掉，就现实来说，很多⼈连“观望”都没有开始。\n\n其三，还没有找到跟“交互”结合起来的有效⽅法与机制。前端过去⼗年，在 IoT、机器学习、云平台等等每⼀次潮流都卡上了点⼉，但是如果前端的下⼀次转型起于“交互”，那么我们⽬前还没有能⼒适应这样的变化。当然，契机也可能不在于“交互”，但如果这样，我们的准备就更不充分了。\n\n其四，向更多的应⽤领域渗透的动机与动⼒不明确。⻓期以来，前端在各个领域上都只是陪跑，缺乏真正推动这些领域的动机与动⼒。往将来看，这些因素在前端也将持续缺乏。寻求让前端持续发展，甚⾄领跑某些领域的内驱⼒量，任重⽽道远。\n\n同学们，我想我们必须有一种共同的、清醒的认识与认知：浏览器是未来。去操作系统和云化是两个⼤的⽅向，当它们达成⽬标时，浏览器将成为与⽤户接触的唯⼀渠道。研究浏览器，其本质就是研究交互和表现，是前端的“终极私活”。但不要局限于“Web 浏览器”，它必将成为历史，如同操作系统的“⽂件浏览器”⼀样。\n\n要极其关注 JavaScript 的类型化，弱类型是这⻔语⾔在先天条件上的劣势，是它在⼤型化和系统化应⽤中的明显短板。这个问题⼀旦改善，JavaScript 将有⼒量从其它各种语⾔中汲取营养，并得以⾯向更多的开发领域，这是 JavaScript 的未来。\n\nAI 和 WASM 在前端可以成为⻬头并进的技术，⼀个算法，⼀个实现。对于前端来说，性能问题⼀直是核⼼问题，⽽交互与表现必将“⼤型与复杂化”，例如虚拟现实交互，以及模拟反馈等等，⽽ WASM 是应对这些问题的有效⼿段。\n\n所谓交互与表现，本质上都是“空间问题”。亦即是说，前端表现中的所谓布局、块、位置、流等等传统模式与技术，与将来的交互技术在问题上是同源的。就像“盒模型”确定了 CSS 在前端的核⼼地位⼀样，新的空间定位技术，以及与之匹配的表现与交互⽅法是值得关注和跟进的。\n\n前端要有更强的组织⼒，才能应付更⼤规模的系统。这⾥的组织⼒主要是针对⼯程化⽽⾔，所有⼯程化⼯具，其最终的落脚点都在快速、可靠，并以体系化的⽅式来组织⼯程项⽬。这包括⼈、资源、信息、时间、能⼒与关系等等⼯程因素，每个⽅⾯都有问题，都值得投⼊技术⼒量。\n\n相较于新入行的前端的同学们，我能从没有前端走到如今前端的⼤发展，何其幸也。以我⼀路之所⻅，前端真正让我钦佩的是持久的活⼒。前端开发者⼏乎总是⼀个团队中“新鲜⾎液”的代名词，因此前端在业界的每个阶段都⾛在时代的前列。如今看 C 语⾔的⽼迈，操作系统的封闭，后台的保守，以及业务应⽤、产品市场等等各个领域都在筑城⾃守，再看前端种种，便总觉得开放与探索的信念犹在。\n\n曾经与我⼀道的那些早期的前端开发者们，如今有做了主管的，有搞了标准的，有带了团队的，有转了后端的，有做架构做产品做运维等等⼀肩担之，也有开了公司做了顾问从商⼊政的，但也仍然还有在前端⼀线上做着努⼒，仍看好于这⼀个⽅向并在具体事务上勉⼒前⾏的。我曾经说，“任何事情做个⼗年，总会有所成绩的”，如今看来，这个时间还是说少了，得说是：⼏个⼗年地做下去，前端总能做到第⼀。\n\n惟只提醒⼤家，领域分层的潮流之下，层间技术的核⼼不是功能（functional），⽽是能⼒（capabilities）。向应⽤者交付能⼒，需要有体系性的思维，要看向系统的全貌。我们专精于细节没错，专注于⼀城⼀地也没错，然而眼光⾼远⽽脚踏实地，是前端朋友们当有之势。\n\n亦是这个时代予我们的当为之事！\n\n周爱民/aimingoo\n\n初稿于 2022.06\n\n此稿于 2023.10\n","type":"text/markdown","created":"20231028024501938","creator":"太微搜藏","modified":"20231028024531331","modifier":"Lenovo","tags":"剪藏","url":"https://mp.weixin.qq.com/s/MuZUjmm3X199_O5qgEJHWw"},{"title":"在Windows下搭建轻量级的linux开发环境","text":"### [](https://example.com)简介\n\n[MSYS2](https://so.csdn.net/so/search?q=MSYS2\\&spm=1001.2101.3001.7020) （Minimal SYStem 2） 是一个 MSYS 的独立改写版本，主要用于 shell 命令行开发环境。同时它也是一个在 Cygwin （POSIX 兼容性层） 和 MinGW-w64（从\"MinGW-生成\"）基础上产生的，追求更好的互操作性的 Windows 软件。\n\nMSYS2 是 MSYS 的一个升级版，准确的说是集成了 pacman 和 Mingw-w64 的 [Cygwin](https://so.csdn.net/so/search?q=Cygwin\\&spm=1001.2101.3001.7020) 升级版，提供了 bash shell 等 linux 环境、版本控制软件（git/hg）和 MinGW-w64 工具链。与 MSYS 最大的区别是移植了 Arch Linux 的软件包管理系统 Pacman，使用 Pacman 可以方便的维护 MSYS2 下的软件包组件。\n\n对于咱们普通用户来说，MSYS2 为我们提供了一个轻量级的类 linux/UNIX 环境，支持几乎所有的标准 linux 命令，可以在该环境下开发或者学习 Linux 应用软件开发。\n\nMSYS2 的官方网站： [MSYS2](https://www.msys2.org/ \"MSYS2\")\n\n### [](https://example.com)Msys2 软件包管理工具 pacman\n\n-S 指令\\\n    安装\\\n    pacman -S #安装软件\\\n    pacman -Sy #获取最新打软件情况，如果已经是最新了，直接会提示已经更新到最新了。\\\n    pacman -Syy #强行更新你的应用的软件库（源）\\\n    pacman -Su #更新所有软件\\\n    pacman -Syu #更新软件源并更新你的软件\\\n    pacman -Syyu #强行更新一遍，再更新软件\\\n    查询一个软件\\\n    pacman -Ss \\<pkg\\_name> #查询所有软件名里面带有\\<pkg\\_name>相关的软件。并且查询名支持正则表达\\\n    pacman -S -g            //查询软件组\n\n    pacman -Sc  #清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录。\n\n    pacman -Scc  #清理所有的缓存文件\n\n-R 指令\\\n    pacman -R \\<pkg\\_name> #删除软件\\\n    pacman -Rs \\<pkg\\_name> #删除软件，并删除\\<pkg>所有的依赖包\\\n    pacman -Rns \\<pkg\\_name> #删除软件，并删除\\<pkg>所有的依赖，并删掉\\<pkg>的全局配置文件。 推荐！！\\\n-Q 指令\\\n    pacman -Q #显示出所有软件 sudo pacman -Q | wc -l 查询数量\\\n    pacman -Qe #查询所有自己安装的软件\\\n    pacman -Qeq #查询所有自己安装的软件，只显示包名，不显示版本号等\\\n    pacman -Qs \\<pkg\\_name> #查询本地安装的所有带\\<pkg\\_name>的软件\\\n    pacman -Qdt #查询所有孤儿软件，不再被需要的。\\\n    pacman -Qdtq #查询所有不再被依赖的包名\n\n\\#查询孤儿软件并删除掉他们\\\n    pacman -R $(sudo pacman -Qdtq)    \n\n### [](https://example.com)Msys2 设置 VIM 参数\n\n    VIM 配置文件路径：/usr/share/vim/vim82/defaults.vim\\\n    通过修改配置参数，可实现 VIM 行为配置，例如：\\\n    set tabstop=4\\\n    set nu\n\n### [](https://example.com)C 库函数查询命令 man\n\n    用法：    man 2 read\\\n          中间的数字是 man 的分卷号，man 分成很多部分，分别是：\\\n        1 用户命令， 可由任何人启动的。\\\n        2 系统调用， 即由内核提供的函数。\\\n        3 例程， 即库函数，比如标准 C 库 libc。\\\n        4 设备， 即/dev 目录下的特殊文件。\\\n        5 文件格式描述， 例如/etc/passwd。\\\n        6 游戏， 不用解释啦！\\\n        7 杂项， 例如宏命令包、惯例等。\\\n        8 系统管理员工具， 只能由 root 启动。\\\n        9 其他（Linux 特定的）， 用来存放内核例行程序的文档。\\\n \n","type":"text/markdown","created":"20231028234743201","creator":"太微搜藏","modified":"20231102081904143","modifier":"Lenovo","tags":"剪藏","url":"https://blog.csdn.net/hanshuizhizi/article/details/128001139"},{"title":"多个await的执行顺序？-CSDN博客","text":"{{||headerTemplate}}\n\n最新推荐文章于 2023-07-15 10:28:40 发布\n\n版权声明：本文为博主原创文章，遵循[CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/)版权协议，转载请附上原文出处链接和本声明。\n\n今天讨论问题，涉及到了多个 await 执行顺序的问题，折腾了半个多小时终于弄懂了。\\\n下边是个简单的代码：\n\n```plain\nfunction test1() {\n\tconsole.log(111);\n}\nfunction test2() {\n\tconsole.log(222);\n}\nasync function test3() {\n\tawait test1();\n\tawait test2();\n}\ntest3();\n\n1234567891011\n```\n\n这个执行起来很容易理解，输出结果为 111、222。\\\n那么下边改造一下：\n\n```plain\nfunction test1() {\n\tsetTimeout( ()=> {\n\t\tconsole.log(111);\n\t}, 1000);\n}\nfunction test2() {\n\tconsole.log(222);\n}\nasync function test3() {\n\tawait test1();\n\tawait test2();\n}\ntest3();\n\n12345678910111213\n```\n\n输出的结果为 222、111。那么问题来了，为什么会造成这样的结果？如果我们想要让执行顺序依然为 111、222 怎么做？\\\n在和小伙伴们讨论多时，群里边发来一篇文章，上边写到：\\\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706171913356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg4MDA4OA==,size_16,color_FFFFFF,t_70)\\\n那么谜底揭晓，原来 await 等待的东西分两种情况，promise 和非 promise，遇到 promise 会阻塞下边的代码，遇到非 promise 的会直接根据情况进行执行。\\\n所以最终我们又改造了一下代码：\n\n```plain\nfunction test1() {\n\treturn new Promise(resolve => {\n        setTimeout(() => {\n            console.log(111);\n            resolve();\n        }, 2000)\n    })\n}\nfunction test2(res) {\n\tsetTimeout(() => {\n\t    console.log(222);\n\t}, 1000);\n}\nasync function test3() {\n    await test1();\n    await test2();\n}\ntest3();\n\n123456789101112131415161718\n```\n\n最终输出 111、222，代码的执行顺序如下：\\\n执行 test3()，执行 test1()，遇到 promise，阻塞代码，此时 test2()不执行，运行 test1()，等待 2s，输出 111，运行 resolve()，执行 test2()，等待 1s，输出 222。\n\n参考链接：[理解 JavaScript 的 async/await](https://segmentfault.com/a/1190000007535316)\n\n> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function","type":"text/markdown","created":"20231019133620792","creator":"太微搜藏","modified":"20231019133848926","modifier":"Lenovo","tags":"剪藏","url":"https://blog.csdn.net/weixin_42880088/article/details/118525117"},{"title":"多去朗读","text":"朗读可以帮助我们更好地理解和记忆。朗读可以激活大脑的语言中心和听觉中心，提高我们对所读内容的理解和记忆能力。此外，把所读内容解释给他人听，可以帮助我们更深入地理解和掌握所学知识，并且可以发现自己在阅读时可能忽略的细节或问题。因此，尝试朗读和解释所学内容，可以帮助我们更有效地学习和掌握知识","type":"text/markdown","created":"20230606094300801","creator":"oeyoews","modified":"20230726045248273","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&多去朗读"},{"title":"多去睡觉","text":"睡眠对于学习编程等需要大量新的关联的任务非常重要。睡眠可以促进大脑的记忆、巩固和再现过程，这对于学习编程等需要记忆和理解的任务非常重要。此外，睡眠还可以帮助大脑清理代谢产物，维持大脑健康。因此，要学好编程，我们需要保证充足的睡眠时间，并且尽量保持规律的作息时间。建议成年人每天睡眠时间在 7-9 小时之间，而青少年和儿童需要更多的睡眠时间。","type":"text/markdown","created":"20230606094405811","creator":"oeyoews","modified":"20230726045248274","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&多去睡觉"},{"title":"多去锻炼","text":"做体力活动可以帮助我们保持身体健康和提高学习效率。研究表明，适量的身体运动可以促进身体内的血液循环，增加大脑的氧气供应，提高注意力和专注力，并且有助于缓解焦虑和压力。因此，我们可以在学习期间适当进行一些体力活动，例如散步、跑步、打球等，这些活动可以帮助我们放松身心、提高学习效率。同时，我们应该养成良好的习惯，自觉参与体育活动，保持身体健康，这对于我们的身体和大脑健康都非常重要。","type":"text/markdown","created":"20230606094125620","creator":"oeyoews","modified":"20230726045248273","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&多去锻炼"},{"title":"多喝热水","text":"身体水分充足对于大脑功能的正常运转非常重要，因为大脑的大部分成分都是水。如果身体缺水，就会导致血液黏稠度增加，从而减少血流量，导致大脑供氧不足、代谢缓慢，进而影响认知能力、注意力、记忆力等。因此，保持足够的水分摄入对于保持大脑健康非常重要。建议每天至少饮用 6-8 杯水，如果进行剧烈运动或在高温环境下工作，应适当增加水分摄入量。","type":"text/markdown","created":"20230606094005090","creator":"oeyoews","modified":"20230726045248272","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&多喝热水"},{"title":"如何掌握所有的程序语言","text":"## 如何掌握所有的程序语言\n\n对的，我这里要讲的不是如何掌握一种程序语言，而是所有的……\n\n很多编程初学者至今还在给我写信请教，问我该学习什么程序语言，怎么学习。由于我知道如何掌握“所有”的程序语言，总是感觉这种该学“一种”什么语言的问题比较低级，所以一直没来得及回复他们 :P 可是逐渐的，我发现原来不只是小白们有这个问题，就连美国大公司的很多资深工程师，其实也没搞明白。\n\n今天我有动力了，想来统一回答一下这个搁置已久的“初级问题”。类似的话题貌似曾经写过，然而现在我想把它重新写一遍。因为在跟很多人交流之后，我对自己头脑中的（未转化为语言的）想法，有了更精准的表达。\n\n如果你存在以下的种种困惑，那么这篇文章也许会对你有所帮助：\n\n1. 你是编程初学者，不知道该选择什么程序语言来入门。\n2. 你是资深的程序员或者团队领导，对新出现的种种语言感到困惑，不知道该“投资”哪种语言。\n3. 你的团队为使用哪种程序语言争论不休，发生各种宗教斗争。\n4. 你追逐潮流采用了某种时髦的语言，结果两个月之后发现深陷泥潭，痛苦不堪……\n\n虽然我已经不再过问这些世事，然而无可置疑的现实是，程序语言仍然是很重要的话题，这个情况短时间内不会改变。程序员的岗位往往会要求熟悉某些语言，甚至某些奇葩的公司要求你“深入理解 OOP 或者 FP 设计模式”。对于在职的程序员，程序语言至今仍然是可以争得面红耳赤的宗教话题。它的宗教性之强，以至于我在批评和调侃某些语言（比如 Go 语言）的时候，有些人会本能地以为我是另外一种语言（比如 Java）的粉丝。\n\n显然我不可能是任何一种语言的粉丝，我甚至不是 Yin 语言的粉丝 ;) 对于任何从没见过的语言，我都是直接拿起来就用，而不需要经过学习的过程。看了这篇文章，也许你会明白我为什么可以达到这个效果。理解了这里面的东西，每个程序员都应该可以做到这一点。嗯，但愿吧。\n\n### 重视语言特性，而不是语言\n\n很多人在乎自己或者别人是否“会”某种语言，对“发明”了某种语言的人倍加崇拜，为各种语言的孰优孰劣争得面红耳赤。这些问题对于我来说都是不存在的。虽然我写文章批评过不少语言的缺陷，在实际工作中我却很少跟人争论这些。如果有其它人在我身边争论，我甚至会戴上耳机，都懒得听他们说什么 ;) 为什么呢？我发现归根结底的原因，是因为我重视的是“语言特性”，而不是整个的“语言”。我能用任何语言写出不错的代码，就算再糟糕的语言也差不了多少。\n\n任何一种“语言”，都是各种“语言特性”的组合。打个比方吧，一个程序语言就像一台电脑。它的牌子可能叫“联想”，或者“IBM”，或者“Dell”，或者“苹果”。那么，你可以说苹果一定比 IBM 好吗？你不能。你得看看它里面装的是什么型号的处理器，有多少个核，主频多少，有多少 L1 cache，L2 cache……，有多少内存和硬盘，显示器分辨率有多大，显卡是什么 GPU，网卡速度，等等各种“配置”。有时候你还得看各个组件之间的兼容性。\n\n这些配置对应到程序语言里面，就是所谓“语言特性”。举一些语言特性的例子：\n\n* 变量定义\n* 算术运算\n* for 循环语句，while 循环语句\n* 函数定义，函数调用\n* 递归\n* 静态类型系统\n* 类型推导\n* lambda 函数\n* 面向对象\n* 垃圾回收\n* 指针算术\n* goto 语句\n\n这些语言特性，就像你在选择一台电脑的时候，看它里面是什么配置。选电脑的时候，没有人会说 Dell 一定是最好的，他们只会说这个型号里面装的是 Intel 的 i7 处理器，这个比 i5 的好，DDR3 的内存 比 DDR2 的快这么多，SSD 比磁盘快很多，ATI 的显卡是垃圾…… 如此等等。\n\n程序语言也是一样的道理。对于初学者来说，其实没必要纠结到底要先学哪一种语言，再学哪一种。曾经有人给我发信问这种问题，纠结了好几个星期，结果一个语言都还没开始学。有这纠结的时间，其实都可以把他纠结过的语言全部掌握了。\n\n初学者往往不理解，每一种语言里面必然有一套“通用”的特性。比如变量，函数，整数和浮点数运算，等等。这些是每个通用程序语言里面都必须有的，一个都不能少。你只要通过“某种语言”学会了这些特性，掌握这些特性的根本概念，就能随时把这些知识应用到任何其它语言。你为此投入的时间基本不会浪费。所以初学者纠结要“先学哪种语言”，这种时间花的很不值得，还不如随便挑一个语言，跳进去。\n\n如果你不能用一种语言里面的基本特性写出好的代码，那你换成另外一种语言也无济于事。你会写出一样差的代码。我经常看到有些人 Java 代码写得相当乱，相当糟糕，却骂 Java 不好，雄心勃勃要换用 Go 语言。这些人没有明白，是否能写出好的代码在于人，而不在于语言。如果你的心中没有清晰简单的思维模型，你用任何语言表述出来都是一堆乱麻。如果你 Java 代码写得很糟糕，那么你写 Go 语言代码也会一样糟糕，甚至更差。\n\n很多初学者不了解，一个高明的程序员如果开始用一种新的程序语言，他往往不是去看这个语言的大部头手册或者书籍，而是先有一个需要解决的问题。手头有了问题，他可以用两分钟浏览一下这语言的手册，看看这语言大概长什么样。然后，他直接拿起一段例子代码来开始修改捣鼓，想法把这代码改成自己正想解决的问题。在这个简短的过程中，他很快的掌握了这个语言，并用它表达出心里的想法。\n\n在这个过程中，随着需求的出现，他可能会问这样的问题：\n\n* 这个语言的“变量定义”是什么语法，需要“声明类型”吗，还是可以用“类型推导”？\n* 它的“类型”是什么语法？是否支持“泛型”？泛型的 “variance” 如何表达？\n* 这个语言的“函数”是什么语法，“函数调用”是什么语法，可否使用“缺省参数”？\n* ……\n\n注意到了吗？上面每一个引号里面的内容，都是一种语言特性（或者叫概念）。这些概念可以存在于任何的语言里面，虽然语法可能不一样，它们的本质都是一样的。比如，有些语言的参数类型写在变量前面，有些写在后面，有些中间隔了一个冒号，有些没有。\n\n这些实际问题都是随着写实际的代码，解决手头的问题，自然而然带出来的，而不是一开头就抱着语言手册看得仔仔细细。因为掌握了语言特性的人都知道，自己需要的特性，在任何语言里面一定有对应的表达方式。如果没有直接的方式表达，那么一定有某种“绕过方式”。如果有直接的表达方式，那么它只是语法稍微有所不同而已。所以，他是带着问题找特性，就像查字典一样，而不是被淹没于大部头的手册里面，昏昏欲睡一个月才开始写代码。\n\n掌握了通用的语言特性，剩下的就只剩某些语言“特有”的特性了。研究语言的人都知道，要设计出新的，好的，无害的特性，是非常困难的。所以一般说来，一种好的语言，它所特有的新特性，终究不会超过一两种。如果有个语言号称自己有超过 5 种新特性，那你就得小心了，因为它们带来的和可能不是优势，而是灾难！\n\n同样的道理，最好的语言研究者，往往不是某种语言的设计者，而是某种关键语言特性的设计者（或者支持者）。举个例子，著名的计算机科学家 Dijkstra 就是“递归”的强烈支持者。现在的语言里面都有递归，然而你可能不知道，早期的程序语言是不支持递归的。直到 Dijkstra 强烈要求 Algol 60 委员会加入对递归的支持，这个局面才改变了。Tony Hoare 也是语言特性设计者。他设计了几个重要的语言特性，却没有设计过任何语言。另外大家不要忘了，有个语言专家叫王垠，他是早期 union type 的支持者和实现者，也是 checked exception 特性的支持者，他在自己的[博文](http://www.yinwang.org/blog-cn/2017/05/23/kotlin)里指出了 checked exception 和 union type 之间的关系 :P\n\n很多人盲目的崇拜语言设计者，只要听到有人设计（或者美其民曰“发明”）了一个语言，就热血沸腾，佩服的五体投地。他们却没有理解，其实所有的程序语言，不过是像 Dell，联想一样的“组装机”。语言特性的设计者，才是像 Intel，AMD，ARM，Qualcomm 那样核心技术的创造者。\n\n### 合理的入门语言\n\n所以初学者要想事半功倍，就应该从一种“合理”的，没有明显严重问题的语言出发，掌握最关键的语言特性，然后由此把这些概念应用到其它语言。哪些是合理的入门语言呢？我个人觉得这些语言都可以用来入门：\n\n* Scheme\n* C\n* Java\n* Python\n* JavaScript\n\n那么相比之下，我不推荐用哪些语言入门呢？\n\n* Shell\n* PowerShell\n* AWK\n* Perl\n* PHP\n* Basic\n* Go\n* Rust\n\n总的说来，你不应该使用所谓“[脚本语言](http://www.yinwang.org/blog-cn/2013/03/29/scripting-language)”作为入门语言，特别是那些源于早期 Unix 系统的脚本语言工具。PowerShell 虽然比 Unix 的 Shell 有所进步，然而它仍然没有摆脱脚本语言的根本问题——他们的设计者不知道他们自己在干什么 :P\n\n采用脚本语言学编程，一个很严重的问题就是使得学习者抓不住关键。脚本语言往往把一些系统工具性质的东西（比如正则表达式，Web 概念）加入到语法里面，导致初学者为它们浪费太多时间，却没有理解编程最关键的概念：变量，函数，递归，类型……\n\n不推荐 Go 语言的原因类似，虽然 Go 语言不算脚本语言，然而他的设计者显然不明白自己在干什么。所以使用 Go 语言来学编程，你不能专注于最关键，最好的语言特性。关于 Go 语言的各种毛病，你可以参考这篇[文章](http://www.yinwang.org/blog-cn/2014/04/18/golang)。\n\n同样的，我不觉得 Rust 适合作为入门语言。Rust 花了太大精力来夸耀它的“新特性”，而这些新特性不但不是最关键的部分，而且很多是有问题的。初学者过早的关注这些特性，不仅学不会最关键的编程思想，而且可能误入歧途。关于 Rust 的一些问题，你可以参考这篇[文章](http://www.yinwang.org/blog-cn/2016/09/18/rust)。\n\n### 掌握关键语言特性，忽略次要特性\n\n为了达到我之前提到的融会贯通，一通百通的效果，初学者应该专注于语言里面最关键的特性，而不是被次要的特性分心。\n\n举个夸张点的例子。我发现很多编程培训班和野鸡大学的编程入门课，往往一来就教学生如何使用 printf 打印“Hello World！”，进而要他们记忆 printf 的各种“格式字符”的意义，要他们实现各种复杂格式的打印输出，甚至要求打印到文本文件里，然后再读出来……\n\n可是殊不知，这种输出输入操作其实根本不算是语言的一部分，而且对于掌握编程的核心概念来说，都是次要的。有些人的 Java 课程进行了好几个星期，居然还在布置各种 printf 的作业。学生写出几百行的 printf，却不理解变量和函数是什么，甚至连算术语句和循环语句都不知道怎么用！这就是为什么很多初学者感觉编程很难，我连 `%d`，`%f`，`%.2f` 的含义都记不住，还怎么学编程！\n\n然而这些野鸡大学的“教授”头衔是如此的洗脑，以至于被他们教过的学生（比如我女朋友）到我这里请教，居然骂我净教一些没用的东西，学了连 printf 的作业都没法完成 :P 你别跟我讲 for 循环，函数什么的了…… 可不可以等几个月，等我背熟了 printf 的用法再学那些啊？\n\n所以你就发现一旦被差劲的老师教过，这个程序员基本就毁了。就算遇到好的老师，他们也很难纠正过来。\n\n当然这是一个夸张的例子，因为 printf 根本不算是语言特性，但这个例子从同样的角度说明了次要肤浅的语言特性带来的问题。\n\n这里举一些次要语言特性的例子：\n\n* C 语言的语句块，如果里面只有一条语句，可以不打花括号。\n* Go 语言的函数参数类型如果一样可以合并在一起写，比如 `func foo(s string, x, y, z int, c bool) { ... }`\n* Perl 把正则表达式作为语言的一种特殊语法\n* JavaScript 语句可以在某些时候省略句尾的分号\n* Haskell 和 ML 等语言的 [currying](http://www.yinwang.org/blog-cn/2013/04/02/currying)\n\n### 自己动手实现语言特性\n\n在基本学会了各种语言特性，能用它们来写代码之后，下一步的进阶就是去实现它们。只有实现了各种语言特性，你才能完全地拥有它们，成为它们的主人。否则你就只是它们的使用者，你会被语言的设计者牵着鼻子走。\n\n有个大师说得好，完全理解一种语言最好的方法就是自己动手实现它，也就是自己写一个解释器来实现它的语义。但我觉得这句话应该稍微修改一下：完全理解一种“语言特性”最好的方法就是自己亲自实现它。\n\n注意我在这里把“语言”改为了“语言特性”。你并不需要实现整个语言来达到这个目的，因为我们最终使用的是语言特性。只要你自己实现了一种语言特性，你就能理解这个特性在任何语言里的实现方式和用法。\n\n举个例子，学习 SICP 的时候，大家都会亲自用 Scheme 实现一个面向对象系统。用 Scheme 实现的面向对象系统，跟 Java，C++，Python 之类的语言语法相去甚远，然而它却能帮助你理解任何这些 OOP 语言里面的“面向对象”这一概念，它甚至能帮助你理解各种面向对象实现的差异。\n\n这种效果是你直接学习 OOP 语言得不到的，因为在学习 Java，C++，Python 之类语言的时候，你只是一个用户，而用 Scheme 自己动手实现了 OO 系统之后，你成为了一个创造者。\n\n类似的特性还包括类型推导，类型检查，惰性求值，如此等等。我实现过几乎所有的语言特性，所以任何语言在我的面前，都是可以被任意拆卸组装的玩具，而不再是凌驾于我之上的神圣。\n\n### 总结\n\n写了这么多，重要的话重复三遍：语言特性，语言特性，语言特性，语言特性！不管是初学者还是资深程序员，应该专注于语言特性，而不是纠结于整个的“语言品牌”。只有这样才能达到融会贯通，拿起任何语言几乎立即就会用，并且写出高质量的代码。\n","type":"text/markdown","created":"20231030052442425","creator":"太微搜藏","modified":"20231030052508329","modifier":"Lenovo","tags":"剪藏","url":"https://www.yinwang.org/blog-cn/2017/07/06/master-pl"},{"title":"如何管理笔记","text":"事实上我并没有特意管理，很多时候都是随手一扔，我更倾向于每篇文章的独立性，\n\n关于搜索， 直接搜索关键词即可，并且我其实是有几个常用的文章主题分类标记的，更何况 tw 本身还有强大的 filter，大可不必在管理上大费心思，大费周章\n\n后期会点击随机骰子的方式,查看以前的笔记, 如果遇到没有价值的会删掉, 又是也会顺手更新整理一下文章","type":"text/markdown","created":"20231009112957319","creator":"Lenovo","modified":"20231018055819669","modifier":"Lenovo","tags":""},{"title":"如何阅读别人的代码","text":"## 如何阅读别人的代码\n\n挺多人问过我「如何阅读已有代码」这个问题，希望我能有一个好方法。有些人希望通过阅读「优质项目」（比如 Linux 内核）得到提高，改进自己的代码质量。对于这个问题，我一般都不好回答，因为我很少从阅读别人的代码得到提升。我对自己阅读的代码有很高的标准，因为世界上存在太多风格差劲的代码，阅读它们会损害自己的思维。同样的道理，我也不会阅读风格差劲的文章。\n\n但这并不等于我无法跟其它程序员交流和共事，我有别的办法。比起阅读代码，我更喜欢别人给我讲解他们的代码，用简单的语言或者图形来解释他们的思想。有了思想，我自然知道如何把它变成代码，而且是优雅的代码。很多人的代码我不会去看，但如果他们给我讲，我是可以接受的。\n\n如果有同事请我帮他改进代码，我不会拿起代码埋头就看，因为我知道看代码往往是事倍功半，甚至完全没用。我会让他们先在白板上给我解释那些代码是什么意思。我的同事们都发现，把我讲明白是需要费一番工夫的。因为我的要求非常高，只要有一点不明白，我就会让他们重新讲。还得画图，我会让他们反复改进画出来的图，直到我能一眼看明白为止。如果图形是 3D 的，我会让他们给我压缩成 2D 的，理解了之后再推广到 3D。我无法理解复杂的，高维度的概念，他们必须把它给我变得很简单。\n\n所以跟我讲代码可能需要费很多时间，但这是值得的。我明白了之后，往往能挖出其他人都难以看清楚的要点。给我讲解事情，也能提升他们自己的思维和语言能力，帮助他们简化思想。很多时候我根本没看代码，通过给我讲解，后来他们自己就把代码给简化了。节省了我的脑力和视力，他们也得到了提高。\n\n我最近一次看别人的代码是在 Intel，我们改了 PyTorch 的代码。那不是一次愉悦的经历，因为虽然很多人觉得 PyTorch 好用，它内部的代码却是晦涩而难以理解的。PyTorch 不是 Intel 自己的东西，所以没有人可以给我讲。修改 PyTorch 代码，增加新功能的时候，我发现很难从代码本身看明白应该改哪里。后来我发现，原因在于 PyTorch 的编译构架里自动生成了很多代码，导致你无法理解一些代码是怎么来的。\n\n比如他们有好几个自己设计的文件格式，里面有一些特殊的文本，决定了如何在编译时生成代码。你得理解这些文件在说什么，而那不是任何已知的语言。这些文件被一些 Python 脚本读进去，吐出来一些奇怪的 C++，CUDA，或者 Python 代码。这其实是一种 DSL，我已经在之前的[文章](http://www.yinwang.org/blog-cn/2017/05/25/dsl)中解释过 DSL 带来的问题。要往 PyTorch 里面加功能，你就得理解这些脚本是如何处理这些 DSL，生成代码。而这些脚本写得也比较混乱和草率，所以就是头痛加头痛。\n\n最后我发现，没有办法完全依靠这些代码本身来理解它。那么怎么解决这个问题呢？幸好，网络上有 PyTorch 的内部工程师写了篇 [blog](http://blog.ezyang.com/2019/05/pytorch-internals/)，解释 PyTorch 如何组织代码。Blog 的作者 E. Z. Yang 我见过一面，是在一次 PL 学术会议上。他当时在 MIT 读书，一个挺聪明的小伙子。不过看了这 blog 也只能初步知道它做了什么，应该碰大概哪些文件，而这些每天都可能变化。\n\n这篇 blog 还提到，某几个目录里面是历史遗留代码，如果你不知道那是什么，那么请不要碰！看看那几个目录，里面都是一些利用 C 语言的宏处理生成代码的模板，而它使用 C 语言宏的方式还跟普通的用法不一样。在我看来，所谓「宏」（macro）和 「元编程」（metaprogramming） 本身就是巨大的误区，而 PyTorch 对宏的用法还如此奇怪，自作聪明。\n\n你以为看了这篇 blog 就能理解 PyTorch 代码了吗？不，仍然是每天各种碰壁。大量的经验都来自折腾和碰壁。多个人同时在进行这些事情，然后分享自己的经验。讨论会内容经常是：「我发现要做这个，得在这个文件里加这个，然后在那个文件里加那个…… 然后好像就行了。」 下次开会又有人说：「我发现不是像你说的那样，还得改这里和这里，而那里不是关键……」 许多的知其然不知其所以然，盲人摸象，因为「所以然」已经被 PyTorch 的作者们掩盖在一堆堆混乱的 DSL 下面了。\n\n所以我从 PyTorch 的代码里面学到了什么呢？什么都没有。我只看到各种软件开发的误区在反复上演。如果他们在早期得到我的建议，根本不可能把代码组织成这种样子，不可能有这么多的宏处理，代码生成，DSL。PyTorch 之类的深度学习框架，本质上是某种简单编程语言的解释器，只不过这些语言写出来的函数可以求导而已。\n\n很多人都不知道，有一天我用不到一百行 Scheme 代码就写出了一个「深度学习框架」，它其实是一个小的编程语言。虽然没有性能可言，没有 GPU 加速，功能也不完善，但它抓住了 PyTorch 等大型框架的本质——用这个语言写出来的函数能自动求导。这种洞察力才是最关键的东西，只要抓住了关键，细节都可以在需要的时候琢磨出来。几十行代码反复琢磨，往往能帮助你看透上百万行的项目里隐藏的秘密。\n\n很多人以为看大型项目可以提升自己，而没有看到大型项目不过是几十行核心代码的扩展，很多部分是低水平重复。几十行平庸甚至晦涩的代码，重复一万次，就成了几十万行。看那些低水平重复的部分，是得不到什么提升的。造就我今天的编程能力和洞察力的，不是几百万行的大型项目，而是小到几行，几十行之短的练习。不要小看了这些短小的代码，它们就是编程最精髓的东西。反反复复琢磨这些短小的代码，不断改进和提炼里面的结构，磨砺自己的思维。逐渐的，你的认识水平就超越了这些几百万行，让人头痛的项目。\n\n所以我如何阅读别人的代码呢？Don’t。如果有条件，我就让代码的作者给我讲，而不是去阅读它。如果作者不合作，而我真的要使用那个项目的代码，我才会去折腾它。那么如何折腾别人的代码呢？我有另外一套办法。\n","type":"text/markdown","created":"20231030052029225","creator":"太微搜藏","modified":"20231030052029225","modifier":"太微搜藏","tags":"剪藏","url":"https://www.yinwang.org/blog-cn/2020/02/05/how-to-read-code"},{"title":"字体的选择","text":"好的字体可以展现你的网站的个性，默认字体可以提升加载速度和性能。如何选择取决于你。","type":"text/markdown","created":"20230903032742342","creator":"oeyoews","modified":"20230903032750129","modifier":"oeyoews","tags":""},{"title":"小屁孩日记","text":"","type":"text/markdown","created":"20231023113425501","creator":"Lenovo","modified":"20231023113444014","modifier":"Lenovo","tags":"books"},{"title":"展开运算符-浅拷贝","text":"在这两行代码中，`const originalArray = [...array];` 和 `const originalArray = array;` 之间存在一些区别。\r\n\r\n1. `const originalArray = [...array];`：这行代码使用了扩展运算符 `...`，它创建了一个原数组 `array` 的浅拷贝。这意味着 `originalArray` 现在引用的是一个与 `array` 具有相同内容的新数组，但是两个数组在内存中是独立的，互不影响。如果你修改 `originalArray` 或 `array` 中的任何一个数组，另一个数组不会受到影响。\r\n\r\n2. `const originalArray = array;`：这行代码直接将 `originalArray` 设置为引用了 `array`。这意味着 `originalArray` 和 `array` 实际上引用了同一个数组对象。如果你修改 `originalArray` 或 `array` 中的元素，两个变量引用的是同一数组，所以另一个变量也会受到影响。\r\n\r\n综上所述，`const originalArray = [...array];` 创建了一个独立的数组副本，而 `const originalArray = array;` 则创建了两个变量引用同一个数组。通常情况下，如果你希望在不影响原数组的情况下对数组进行修改，使用 `const originalArray = [...array];` 是更安全的选项。","type":"text/markdown","created":"20230827145001426","creator":"oeyoews","modified":"20230827145028778","modifier":"oeyoews","tags":"JavaScript"},{"title":"常见问题___pnpm","text":"{{||headerTemplate}}\n\n## 常见问题\n\n## 如果包存储在全局存储中，为什么我的 `node_modules` 使用了磁盘空间？[​](#如果包存储在全局存储中为什么我的-node_modules-使用了磁盘空间 \"Direct link to 如果包存储在全局存储中为什么我的-node_modules-使用了磁盘空间\")\n\npnpm 创建从全局存储到项目下 `node_modules` 文件夹的 [硬链接](https://en.wikipedia.org/wiki/Hard_link)。 硬链接指向磁盘上原始文件所在的同一位置。 因此，例如，如果您的项目中 `foo` 并且它占用 1MB 的空间，那么看起来它在项目的 `node_modules` 文件夹中占用了与全局存储相同的 1MB 的空间。 但是，该 1MB 是磁盘上两个不同位置的*相同空间* 。 所以 `foo` 总共占用 1MB，而不是 2MB。\n\n获取有关此主题的更多信息：\n\n* [为什么硬链接似乎与原始链接占用相同的空间？](https://unix.stackexchange.com/questions/88423/why-do-hard-links-seem-to-take-the-same-space-as-the-originals)\n* [Pnpm 聊天室的一个帖子](https://gist.github.com/zkochan/106cfef49f8476b753a9cbbf9c65aff1)\n* [Pnpm repo 中的一个 issue](https://github.com/pnpm/pnpm/issues/794)\n\n## 能用于 Windows 吗？[​](#能用于windows吗 \"Direct link to 能用于Windows吗？\")\n\n短回答：当然 长答案：在 Windows 上使用符号链接至少可以说是有问题的，但是，pnpm 有一个解决方法。 对于 Windows，我们用[junctions](https://docs.microsoft.com/en-us/windows/win32/fileio/hard-links-and-junctions)替代。\n\n## 但是嵌套的 `node_modules` 组织方式与 Windows 兼容吗？[​](#但是嵌套的-node_modules-组织方式与-windows-兼容吗 \"Direct link to 但是嵌套的-node_modules-组织方式与-windows-兼容吗\")\n\nnpm 的早期版本由于嵌套了所有 `node_modules` (参见 [这个 issue](https://github.com/nodejs/node-v0.x-archive/issues/6960)). 但是，pnpm 不会创建深层文件夹，它使用符号链接来创建依赖关系树结构。\n\n## 循环 symlinks 呢?[​](#循环-symlinks-呢 \"Direct link to 循环 symlinks 呢?\")\n\n尽管 pnpm 使用链接将依赖项放入 `node_modules` 文件夹，循环的符号链接已经被避免了，因为父包放置在其依赖项所在 `node_modules` 文件夹中。 所以 `foo`的依赖项不在 `foo/node_modules` 中，`foo` 其实和它 依赖项一起在 `node_modules` 中。\n\n## 为什么使用硬链接？ 为什么不直接创建到全局存储的符号链接？[​](#为什么使用硬链接-为什么不直接创建到全局存储的符号链接 \"Direct link to 为什么使用硬链接？ 为什么不直接创建到全局存储的符号链接？\")\n\n一台机器上一个包在可以有不同的依赖集。\n\n在项目 **A** `foo@1.0.0` 可以具有一个依赖被解析为 `bar@1.0.0`，但在项目 **B** 中 `foo` 的依赖可能会被解析至 `bar@1.1.0`; 因此，pnpm 硬链接 `foo@1.0.0` 到每个使用它的项目，以便为其创建不同的依赖项集。\n\n直接软链至全局存储与 Node 的 `--preserve-symlinks` 标志一起使用是可行的，但是，该方法附带了个自己的问题，因此我们决定使用硬链接。 有关为何作出决定的详情，请参阅 [这个 issue](https://github.com/nodejs/node-eps/issues/46)。\n\n## Does pnpm work across different subvolumes in one Btrfs partition?[​](#does-pnpm-work-across-different-subvolumes-in-one-btrfs-partition \"Direct link to Does pnpm work across different subvolumes in one Btrfs partition?\")\n\nWhile Btrfs does not allow cross-device hardlinks between different subvolumes in a single partition, it does permit reflinks. As a result, pnpm utilizes reflinks to share data between these subvolumes.\n\n包存储应与安装的位置处于同一驱动器和文件系统上，否则，包将被复制，而不是被链接。 这是由于硬链接的工作方式带来的一个限制，因为一个文件系统上的文件无法寻址另一个文件系统中的位置。 更多详细信息请参阅 [issue #712](https://github.com/pnpm/pnpm/issues/712)。\n\npnpm 在以下两种情况下的功能有所不同：\n\n### 存储路径已指定[​](#存储路径已指定 \"Direct link to 存储路径已指定\")\n\n如果存储路径是通过 [存储配置](https://pnpm.io/zh/configuring)指定的，则存储与项目间的复制行为将会发生在不同的磁盘上。\n\n如果您在磁盘 `A` 上执行 `pnpm install`，则 pnpm 存储必须位于磁盘 `A`。 如果 pnpm 存储位于磁盘 `B`，则所有需要的包将被直接复制到项目位置而不是链接。 这严重抑制了 pnpm 的存储和性能优势。\n\n### 存储路径未指定[​](#存储路径未指定 \"Direct link to 存储路径未指定\")\n\n如果未设置存储路径，则会创建多个存储（每个驱动器或文件系统一个）。\n\n如果安装在磁盘 `A` 上运行，则存储将在 `A` 的文件系统根目录下的 `.pnpm-store` 下被创建。 如果后续安装在磁盘 `B` 上运行，则将会在 `B` 上的 `.pnpm-store`处创建一个独立的存储。 项目仍将保持 pnpm 的优势，但每个驱动器可能有冗余包。\n\n## `pnpm` 代表什么？[​](#pnpm-代表什么 \"Direct link to pnpm-代表什么\")\n\n`pnpm` 代表 performant（高性能的）`npm`。 [@rstacruz](https://github.com/rstacruz/)想出了这个名字。\n\n## `pnpm` 无法在 <!-- --><<!-- -->你的项目>中使用 ？[​](#pnpm-无法在-你的项目中使用- \"Direct link to pnpm-无法在-你的项目中使用-\")\n\n在大多数情况下，这意味着被使用的依赖项之一没有在 `package.json` 中被声明的。 It is a common mistake caused by flat `node_modules`. 如果发生这种情况，这是依赖项中的错误，应修复依赖项。 但这可能需要时间，因此 pnpm 支持额外的解决方法来使有问题的包工作。\n\n### 解决方案 1[​](#解决方案1 \"Direct link to 解决方案1\")\n\nIn case there are issues, you can use the [`node-linker=hoisted`](https://pnpm.io/zh/npmrc#node-linker) setting. This creates a flat `node_modules` structure similar to the one created by `npm`.\n\n### 解决方案 2[​](#解决方案2 \"Direct link to 解决方案2\")\n\n在下面的例子中，一个依赖在它自己的 deps 列表中**没有** `iterall` 模块。\n\n解决有问题的包缺少依赖项的最简单的解决方案是将 **增加 `iterall` 作为我们项目的 `package.json` 中的依赖项**。\n\n您可以这样做，方法是通过 `pnpm add iterall`安装它，并自动将它添加到您项目的 `package.json` 中。\n\n```plain\n  \"dependencies\": {\n    ...\n    \"iterall\": \"^1.2.2\",\n    ...\n  }\n```\n\n### 解决方案 3[​](#解决方案3 \"Direct link to 解决方案3\")\n\n解决方案之一是使用 [hooks](https://pnpm.io/zh/pnpmfile#hooks) 将缺少的依赖项添加到包的 `package.json` 中。\n\nAn example was [Webpack Dashboard](https://github.com/pnpm/pnpm/issues/1043) which wasn't working with `pnpm`. It has since been resolved such that it works with `pnpm` now.\n\nIt used to throw an error:\n\n```plain\nError: Cannot find module 'babel-traverse'\n  at /node_modules/inspectpack@2.2.3/node_modules/inspectpack/lib/actions/parse\n```\n\n问题是 `babel-traverse` 被用于 `inspectpack`， 然后被用于 `webpack-dashboard`，但是 `babel-traverse` 没有在 `inspectpack` 的 `package.json` 中。 它仍然与 `npm` 和 `yarn` 兼容，因为它们构建的平铺的 `node_modules`结构。\n\n解决方案是创建一个 `.pnpmfile.cjs` ，内容如下：\n\n```plain\nmodule.exports = {\n  hooks: {\n    readPackage: (pkg) => {\n      if (pkg.name === \"inspectpack\") {\n        pkg.dependencies['babel-traverse'] = '^6.26.0';\n      }\n      return pkg;\n    }\n  }\n};\n```\n\n创建 `.pnpmfile.cjs` 后，仅删除 `pnpm-lock.yaml` - 不需要 删除 `node_modules`，因为 pnpm 挂钩仅影响模块解析。 然后，重建依赖项 & 它应该可以工作。\n","type":"text/markdown","created":"20231017051232273","creator":"太微搜藏","modified":"20231018054025546","modifier":"Lenovo","tags":"剪藏","url":"https://pnpm.io/zh/faq"},{"title":"异人之下","text":"","type":"text/markdown","created":"20231015090552996","creator":"Lenovo","modified":"20231015090929908","modifier":"Lenovo","tags":"电视剧"},{"title":"强制刷新image","text":"```plain\r\ndocker-compose up --build\r\n```","type":"text/markdown","created":"20230905075748011","creator":"oeyoews","modified":"20230905075805757","modifier":"oeyoews","tags":"docker"},{"title":"当然我在扯淡","text":"　　\n\n* 2022 年 12 月 12 日\n\n  \\\n  [continuation 和并发计算专项班](https://www.yinwang.org/blog-cn/2022/12/12/continuation-course)\n\n* 2022 年 12 月 01 日\n\n  \\\n  [计算机科学阅读班提供疫情特价](https://www.yinwang.org/blog-cn/2022/12/01/tuition-for-covid)\n\n* 2022 年 10 月 09 日\n\n  \\\n  [相对论推导练习](https://www.yinwang.org/blog-cn/2022/10/09/relativity)\n\n* 2022 年 09 月 12 日\n\n  \\\n  [疫情封控是违反宪法的](https://www.yinwang.org/blog-cn/2022/09/12/lockdown-unconstitutional)\n\n* 2022 年 06 月 25 日\n\n  \\\n  [疫情是怎么回事](https://www.yinwang.org/blog-cn/2022/06/25/covid-19)\n\n* 2022 年 02 月 22 日\n\n  \\\n  [自然视力恢复法](https://www.yinwang.org/blog-cn/2022/02/22/myopia)\n\n* 2022 年 02 月 22 日\n\n  \\\n  [计算机科学进阶班招生](https://www.yinwang.org/blog-cn/2022/02/22/advanced-cs-course)\n\n* 2022 年 02 月 07 日\n\n  \\\n  [计算机科学阅读班招生说明](https://www.yinwang.org/blog-cn/2022/02/07/reading-course)\n\n* 2021 年 09 月 16 日\n\n  \\\n  [第一位“计算机科学少年班”学生毕业](https://www.yinwang.org/blog-cn/2021/09/16/youth-cs-student)\n\n* 2021 年 07 月 29 日\n\n  \\\n  [“超人类机器视觉”是不存在的](https://www.yinwang.org/blog-cn/2021/07/29/super-human-level-vision)\n\n* 2021 年 05 月 11 日\n\n  \\\n  [『Ground-Up Computer Science』样章](https://www.yinwang.org/blog-cn/2021/05/11/gucs-sample)\n\n* 2021 年 05 月 10 日\n\n  \\\n  [计算机科学基础班（第 4 期）报名](https://www.yinwang.org/blog-cn/2021/05/10/cs4)\n\n* 2021 年 04 月 16 日\n\n  \\\n  [大提琴为什么这么难学](https://www.yinwang.org/blog-cn/2021/04/16/cello-technique)\n\n* 2021 年 02 月 16 日\n\n  \\\n  [计算机科学阅读班（实验）](https://www.yinwang.org/blog-cn/2021/02/16/cs-reading-course)\n\n* 2021 年 02 月 15 日\n\n  \\\n  [计算机科学基础班（第三期）报名](https://www.yinwang.org/blog-cn/2021/02/15/cs3)\n\n* 2020 年 09 月 24 日\n\n  \\\n  [计算机科学集体班（第二期）报名](https://www.yinwang.org/blog-cn/2020/09/24/cs-class2)\n\n* 2020 年 05 月 23 日\n\n  \\\n  [几个需要避免的美国英语习惯](https://www.yinwang.org/blog-cn/2020/05/23/american-english-problems)\n\n* 2020 年 04 月 30 日\n\n  \\\n  [一对一教学计划](https://www.yinwang.org/blog-cn/2020/04/30/individualized-learning)\n\n* 2020 年 03 月 26 日\n\n  \\\n  [计算机科学入门班报名](https://www.yinwang.org/blog-cn/2020/03/26/entry-level-class)\n\n* 2020 年 03 月 23 日\n\n  \\\n  [对智商的怀疑](https://www.yinwang.org/blog-cn/2020/03/23/wisdom-of-intelligence)\n\n* 2020 年 03 月 06 日\n\n  \\\n  [英语学习的一些经验](https://www.yinwang.org/blog-cn/2020/03/06/english-learning-tips)\n\n* 2020 年 03 月 03 日\n\n  \\\n  [计算机科学课程](https://www.yinwang.org/blog-cn/2020/03/03/cs-course)\n\n* 2020 年 02 月 13 日\n\n  \\\n  [一道 Java 面试题](https://www.yinwang.org/blog-cn/2020/02/13/java-type-system)\n\n* 2020 年 02 月 05 日\n\n  \\\n  [如何阅读别人的代码](https://www.yinwang.org/blog-cn/2020/02/05/how-to-read-code)\n\n* 2019 年 12 月 24 日\n\n  \\\n  [我不是编译器专家](https://www.yinwang.org/blog-cn/2019/12/24/compilers)\n\n* 2019 年 09 月 30 日\n\n  \\\n  [自动驾驶车的责任和风险分析](https://www.yinwang.org/blog-cn/2019/09/30/autopilot-responsibility)\n\n* 2019 年 09 月 16 日\n\n  \\\n  [机器与人类视觉能力的差距（3）](https://www.yinwang.org/blog-cn/2019/09/16/machine-vs-human-3)\n\n* 2019 年 09 月 15 日\n\n  \\\n  [机器与人类视觉能力的差距（2）](https://www.yinwang.org/blog-cn/2019/09/15/machine-vs-human-2)\n\n* 2019 年 09 月 14 日\n\n  \\\n  [机器与人类视觉能力的差距（1）](https://www.yinwang.org/blog-cn/2019/09/14/machine-vs-human)\n\n* 2019 年 09 月 11 日\n\n  \\\n  [Talk is not cheap](https://www.yinwang.org/blog-cn/2019/09/11/talk-is-not-cheap)\n\n* 2019 年 08 月 19 日\n\n  \\\n  [关于微内核的对话](https://www.yinwang.org/blog-cn/2019/08/19/microkernel)\n\n* 2019 年 07 月 21 日\n\n  \\\n  [再谈“P vs NP”问题](https://www.yinwang.org/blog-cn/2019/07/21/pnp2)\n\n* 2019 年 07 月 12 日\n\n  \\\n  [学习的智慧](https://www.yinwang.org/blog-cn/2019/07/12/learning-philosophy)\n\n* 2018 年 11 月 23 日\n\n  \\\n  [解谜英语语法](https://www.yinwang.org/blog-cn/2018/11/23/grammar)\n\n* 2018 年 04 月 13 日\n\n  \\\n  [解谜计算机科学](https://www.yinwang.org/blog-cn/2018/04/13/computer-science)\n\n* 2018 年 02 月 22 日\n\n  \\\n  [智能合约和形式验证](https://www.yinwang.org/blog-cn/2018/02/22/smart-contract)\n\n* 2018 年 02 月 16 日\n\n  \\\n  [成都的雾霾](https://www.yinwang.org/blog-cn/2018/02/16/chengdu-pollution)\n\n* 2017 年 11 月 11 日\n\n  \\\n  [天才是不存在的](https://www.yinwang.org/blog-cn/2017/11/11/genius)\n\n* 2017 年 11 月 05 日\n\n  \\\n  [网络用语](https://www.yinwang.org/blog-cn/2017/11/05/words)\n\n* 2017 年 11 月 04 日\n\n  \\\n  [AlphaGo Zero 和强人工智能](https://www.yinwang.org/blog-cn/2017/11/04/alphago-zero)\n\n* 2017 年 11 月 01 日\n\n  \\\n  [理性的力量](https://www.yinwang.org/blog-cn/2017/11/01/power-of-reasoning)\n\n* 2017 年 10 月 16 日\n\n  \\\n  [人体工学](https://www.yinwang.org/blog-cn/2017/10/16/ergonomics)\n\n* 2017 年 08 月 14 日\n\n  \\\n  [旅行的智慧](https://www.yinwang.org/blog-cn/2017/08/14/travel-wisdom)\n\n* 2017 年 07 月 08 日\n\n  \\\n  [生活的智慧](https://www.yinwang.org/blog-cn/2017/07/08/living-philosophy)\n\n* 2017 年 07 月 06 日\n\n  \\\n  [如何掌握所有的程序语言](https://www.yinwang.org/blog-cn/2017/07/06/master-pl)\n\n* 2017 年 07 月 06 日\n\n  \\\n  [带猫回国经历](https://www.yinwang.org/blog-cn/2017/07/06/cat-travel-china)\n\n* 2017 年 05 月 25 日\n\n  \\\n  [DSL 的误区](https://www.yinwang.org/blog-cn/2017/05/25/dsl)\n\n* 2017 年 05 月 23 日\n\n  \\\n  [Kotlin 和 Checked Exception](https://www.yinwang.org/blog-cn/2017/05/23/kotlin)\n\n* 2017 年 05 月 17 日\n\n  \\\n  [什么是现实理想主义者](https://www.yinwang.org/blog-cn/2017/05/17/practical-idealism)\n\n* 2017 年 04 月 23 日\n\n  \\\n  [人工智能的局限性](https://www.yinwang.org/blog-cn/2017/04/23/ai)\n\n* 2017 年 04 月 14 日\n\n  \\\n  [经验和洞察力](https://www.yinwang.org/blog-cn/2017/04/14/experience-and-insight)\n\n* 2016 年 10 月 13 日\n\n  \\\n  [C# 的 IDisposable 接口](https://www.yinwang.org/blog-cn/2016/10/13/c-sharp-disposable)\n\n* 2016 年 10 月 12 日\n\n  \\\n  [C 编译器优化的 Bug](https://www.yinwang.org/blog-cn/2016/10/12/compiler-bug)\n\n* 2016 年 09 月 18 日\n\n  \\\n  [对 Rust 语言的分析](https://www.yinwang.org/blog-cn/2016/09/18/rust)\n\n* 2016 年 09 月 14 日\n\n  \\\n  [测试的道理](https://www.yinwang.org/blog-cn/2016/09/14/tests)\n\n* 2016 年 07 月 10 日\n\n  \\\n  [Tesla autopilot 引起致命车祸](https://www.yinwang.org/blog-cn/2016/07/10/tesla-autopilot-fatal-crash)\n\n* 2016 年 06 月 28 日\n\n  \\\n  [养生节目的危害](https://www.yinwang.org/blog-cn/2016/06/28/yangsheng)\n\n* 2016 年 06 月 08 日\n\n  \\\n  [Java 有值类型吗？](https://www.yinwang.org/blog-cn/2016/06/08/java-value-type)\n\n* 2016 年 06 月 06 日\n\n  \\\n  [Swift 语言的设计错误](https://www.yinwang.org/blog-cn/2016/06/06/swift)\n\n* 2016 年 05 月 22 日\n\n  \\\n  [正面思维的误区](https://www.yinwang.org/blog-cn/2016/05/22/positive-thinking)\n\n* 2016 年 04 月 13 日\n\n  \\\n  [博文的自愿付费方式](https://www.yinwang.org/blog-cn/2016/04/13/pay-blog)\n\n* 2016 年 03 月 19 日\n\n  \\\n  [为什么自动车完全不可以犯错误](https://www.yinwang.org/blog-cn/2016/03/19/self-driving-car-liability)\n\n* 2016 年 03 月 09 日\n\n  \\\n  [AlphaGo 与人工智能](https://www.yinwang.org/blog-cn/2016/03/09/alpha-go)\n\n* 2016 年 02 月 12 日\n\n  \\\n  [我看自动驾驶技术](https://www.yinwang.org/blog-cn/2016/02/12/self-driving-car)\n\n* 2016 年 01 月 18 日\n\n  \\\n  [给 Java 说句公道话](https://www.yinwang.org/blog-cn/2016/01/18/java)\n\n* 2016 年 01 月 10 日\n\n  \\\n  [Tesla Autopilot](https://www.yinwang.org/blog-cn/2016/01/10/tesla-autopilot)\n\n* 2015 年 12 月 21 日\n\n  \\\n  [Tesla Model X 的车门设计问题](https://www.yinwang.org/blog-cn/2015/12/21/tesla-model-x)\n\n* 2015 年 11 月 21 日\n\n  \\\n  [编程的智慧](https://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy)\n\n* 2015 年 10 月 18 日\n\n  \\\n  [图灵的光环](https://www.yinwang.org/blog-cn/2015/10/18/turing)\n\n* 2015 年 09 月 19 日\n\n  \\\n  [对 Parser 的误解](https://www.yinwang.org/blog-cn/2015/09/19/parser)\n\n* 2015 年 07 月 04 日\n\n  \\\n  [数学和编程](https://www.yinwang.org/blog-cn/2015/07/04/math)\n\n* 2015 年 07 月 02 日\n\n  \\\n  [谈程序的正确性](https://www.yinwang.org/blog-cn/2015/07/02/program-correctness)\n\n* 2015 年 06 月 14 日\n\n  \\\n  [DRY 原则的误区](https://www.yinwang.org/blog-cn/2015/06/14/dry-principle)\n\n* 2015 年 06 月 07 日\n\n  \\\n  [所谓软件工程](https://www.yinwang.org/blog-cn/2015/06/07/software-engineering)\n\n* 2015 年 04 月 03 日\n\n  \\\n  [编程的宗派](https://www.yinwang.org/blog-cn/2015/04/03/paradigms)\n\n* 2015 年 03 月 21 日\n\n  \\\n  [英语口音](https://www.yinwang.org/blog-cn/2015/03/21/accent)\n\n* 2015 年 03 月 20 日\n\n  \\\n  [智商的圈套](https://www.yinwang.org/blog-cn/2015/03/20/trap-of-intelligence)\n\n* 2015 年 03 月 17 日\n\n  \\\n  [设计的重要性](https://www.yinwang.org/blog-cn/2015/03/17/design)\n\n* 2015 年 03 月 11 日\n\n  \\\n  [关于 Git 的礼节](https://www.yinwang.org/blog-cn/2015/03/11/git-etiquette)\n\n* 2015 年 03 月 03 日\n\n  \\\n  [怎样尊重一个程序员](https://www.yinwang.org/blog-cn/2015/03/03/how-to-respect-a-programmer)\n\n* 2015 年 02 月 24 日\n\n  \\\n  [所谓“人为错误”](https://www.yinwang.org/blog-cn/2015/02/24/human-errors)\n\n* 2015 年 02 月 20 日\n\n  \\\n  [其他人的 BUG](https://www.yinwang.org/blog-cn/2015/02/20/other-peoples-bug)\n\n* 2015 年 02 月 01 日\n\n  \\\n  [创造者的思维方式](https://www.yinwang.org/blog-cn/2015/02/01/creative-thinking)\n\n* 2015 年 01 月 19 日\n\n  \\\n  [小费和中国人的尊严](https://www.yinwang.org/blog-cn/2015/01/19/tips)\n\n* 2014 年 11 月 12 日\n\n  \\\n  [恶评《星际穿越》](https://www.yinwang.org/blog-cn/2014/11/12/interstellar)\n\n* 2014 年 04 月 24 日\n\n  \\\n  [关系式模型的实质](https://www.yinwang.org/blog-cn/2014/04/24/relational)\n\n* 2014 年 04 月 18 日\n\n  \\\n  [对 Go 语言的综合评价](https://www.yinwang.org/blog-cn/2014/04/18/golang)\n\n* 2014 年 02 月 18 日\n\n  \\\n  [一个对 Dijkstra 的采访视频](https://www.yinwang.org/blog-cn/2014/02/18/dijkstra-interview)\n\n* 2014 年 02 月 09 日\n\n  \\\n  [程序员的心理疾病](https://www.yinwang.org/blog-cn/2014/02/09/programmer-mental)\n\n* 2014 年 02 月 04 日\n\n  \\\n  [程序语言与它们的工具](https://www.yinwang.org/blog-cn/2014/02/04/pl-tool)\n\n* 2014 年 01 月 28 日\n\n  \\\n  [RubySonar：一个 Ruby 静态分析器](https://www.yinwang.org/blog-cn/2014/01/28/rubysonar)\n\n* 2014 年 01 月 04 日\n\n  \\\n  [我和权威的故事](https://www.yinwang.org/blog-cn/2014/01/04/authority)\n\n* 2013 年 11 月 25 日\n\n  \\\n  [PySonar2 与 Sourcegraph 集成完毕](https://www.yinwang.org/blog-cn/2013/11/25/pysonar2-sg)\n\n* 2013 年 07 月 13 日\n\n  \\\n  [丘奇和图灵](https://www.yinwang.org/blog-cn/2013/07/13/church-turing)\n\n* 2013 年 07 月 06 日\n\n  \\\n  [Pydiff Python 结构化程序比较工具](https://www.yinwang.org/blog-cn/2013/07/06/PyDiff-Python%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%AF%94%E8%BE%83%E5%B7%A5%E5%85%B7)\n\n* 2013 年 04 月 26 日\n\n  \\\n  [原因与证明](https://www.yinwang.org/blog-cn/2013/04/26/reason-and-proof)\n\n* 2013 年 04 月 21 日\n\n  \\\n  [Ydiff 结构化的程序比较](https://www.yinwang.org/blog-cn/2013/04/21/ydiff-%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%AF%94%E8%BE%83)\n\n* 2013 年 04 月 20 日\n\n  \\\n  [编辑器与 IDE](https://www.yinwang.org/blog-cn/2013/04/20/editor-ide)\n\n* 2013 年 04 月 18 日\n\n  \\\n  [程序语言的常见设计错误(2) - 试图容纳世界](https://www.yinwang.org/blog-cn/2013/04/18/language-design-mistake2)\n\n* 2013 年 04 月 17 日\n\n  \\\n  [关于语言的思考](https://www.yinwang.org/blog-cn/2013/04/17/languages)\n\n* 2013 年 04 月 16 日\n\n  \\\n  [Yoda 表示法错在哪里](https://www.yinwang.org/blog-cn/2013/04/16/yoda-notation)\n\n* 2013 年 04 月 15 日\n\n  \\\n  [几个超炫的专业词汇](https://www.yinwang.org/blog-cn/2013/04/15/terminology)\n\n* 2013 年 04 月 14 日\n\n  \\\n  [标准化试卷标记语言](https://www.yinwang.org/blog-cn/2013/04/14/standard-exam-language)\n\n* 2013 年 04 月 14 日\n\n  \\\n  [一种新的操作系统设计](https://www.yinwang.org/blog-cn/2013/04/14/os-design)\n\n* 2013 年 04 月 14 日\n\n  \\\n  [Markdown 的一些问题](https://www.yinwang.org/blog-cn/2013/04/14/markdown)\n\n* 2013 年 04 月 13 日\n\n  \\\n  [谈程序的“通用性”](https://www.yinwang.org/blog-cn/2013/04/13/generality)\n\n* 2013 年 04 月 12 日\n\n  \\\n  [什么是启发](https://www.yinwang.org/blog-cn/2013/04/12/inspiration)\n\n* 2013 年 04 月 11 日\n\n  \\\n  [Scheme 编程环境的设置](https://www.yinwang.org/blog-cn/2013/04/11/scheme-setup)\n\n* 2013 年 04 月 10 日\n\n  \\\n  [我为什么离开 Cornell](https://www.yinwang.org/blog-cn/2013/04/10/cornell)\n\n* 2013 年 04 月 07 日\n\n  \\\n  [测试驱动开发](https://www.yinwang.org/blog-cn/2013/04/07/test-driven-dev)\n\n* 2013 年 04 月 02 日\n\n  \\\n  [Currying 的局限性](https://www.yinwang.org/blog-cn/2013/04/02/currying)\n\n* 2013 年 04 月 01 日\n\n  \\\n  [惰性求值](https://www.yinwang.org/blog-cn/2013/04/01/lazy-evaluation)\n\n* 2013 年 04 月 01 日\n\n  \\\n  [Hindley-Milner 类型系统的根本性错误](https://www.yinwang.org/blog-cn/2013/04/01/hindley-milner)\n\n* 2013 年 03 月 31 日\n\n  \\\n  [函数式语言的宗教](https://www.yinwang.org/blog-cn/2013/03/31/purely-functional)\n\n* 2013 年 03 月 29 日\n\n  \\\n  [什么是“脚本语言”](https://www.yinwang.org/blog-cn/2013/03/29/scripting-language)\n\n* 2013 年 03 月 28 日\n\n  \\\n  [Chez Scheme 的传说](https://www.yinwang.org/blog-cn/2013/03/28/chez-scheme)\n\n* 2013 年 03 月 26 日\n\n  \\\n  [Lisp 已死，Lisp 万岁！](https://www.yinwang.org/blog-cn/2013/03/26/lisp-dead-alive)\n\n* 2013 年 03 月 24 日\n\n  \\\n  [论对东西的崇拜](https://www.yinwang.org/blog-cn/2013/03/24/tools)\n\n* 2013 年 03 月 19 日\n\n  \\\n  [“解决问题”与“消灭问题”](https://www.yinwang.org/blog-cn/2013/03/19/eliminate-problems)\n\n* 2013 年 03 月 15 日\n\n  \\\n  [程序语言的常见设计错误(1) - 片面追求短小](https://www.yinwang.org/blog-cn/2013/03/15/language-design-mistake1)\n\n* 2013 年 03 月 08 日\n\n  \\\n  [谈语法](https://www.yinwang.org/blog-cn/2013/03/08/on-syntax)\n\n* 2013 年 03 月 07 日\n\n  \\\n  [Oberon 操作系统：被忽略的珍宝](https://www.yinwang.org/blog-cn/2013/03/07/oberon)\n\n* 2013 年 03 月 07 日\n\n  \\\n  [谈 Linux，Windows 和 Mac](https://www.yinwang.org/blog-cn/2013/03/07/linux-windows-mac)\n\n* 2013 年 03 月 07 日\n\n  \\\n  [解密“设计模式”](https://www.yinwang.org/blog-cn/2013/03/07/design-patterns)\n\n* 2013 年 03 月 04 日\n\n  \\\n  [Braid - 一个发人深思的游戏](https://www.yinwang.org/blog-cn/2013/03/04/braid)\n\n* 2012 年 09 月 18 日\n\n  \\\n  [TeXmacs：一个真正“所见即所得”的排版系统](https://www.yinwang.org/blog-cn/2012/09/18/texmacs)\n\n* 2012 年 08 月 01 日\n\n  \\\n  [怎样写一个解释器](https://www.yinwang.org/blog-cn/2012/08/01/interpreter)\n\n* 2012 年 07 月 25 日\n\n  \\\n  [什么是语义学](https://www.yinwang.org/blog-cn/2012/07/25/semantics)\n\n* 2012 年 07 月 04 日\n\n  \\\n  [GTF - Great Teacher Friedman](https://www.yinwang.org/blog-cn/2012/07/04/dan-friedman)\n\n* 2012 年 05 月 18 日\n\n  \\\n  [什么是“对用户友好”](https://www.yinwang.org/blog-cn/2012/05/18/user-friendliness)\n","type":"text/markdown","created":"20231030043319817","creator":"太微搜藏","modified":"20231030043319818","modifier":"太微搜藏","tags":"剪藏","url":"https://www.yinwang.org/"},{"title":"影子图书馆","text":"影子图书馆是一个创新的概念，它通常指的是一个虚拟的图书馆或数字图书馆。影子图书馆通过数字化技术和互联网连接，提供了一个在线平台，让用户可以访问和阅读各种电子书籍、文献和其他资料。\r\n\r\n影子图书馆的目的是为用户提供便利的阅读和学习体验，无论他们身处何地。它为用户提供了广泛的图书和资源，包括小说、学术著作、期刊文章、报纸、杂志等。这些资源通常以电子书或电子文档的形式存在，并可以在互联网上随时访问。\r\n\r\n影子图书馆的特点之一是数字化和在线化。用户可以通过网络浏览器或特定的应用程序访问影子图书馆，无需实体书籍或实体图书馆的存在。这使得用户可以方便地在任何时间和地点获取所需的阅读材料。\r\n\r\n此外，影子图书馆通常提供了一些额外的功能和服务，以增强用户的阅读体验。例如，它可能提供书签和注释功能，使用户能够在电子书中做笔记和标记。它还可以提供搜索功能，让用户可以快速找到所需的内容。\r\n\r\n总的来说，影子图书馆为读者提供了一个便捷和全面的阅读平台，让他们可以随时随地获取各种电子书籍和其他资源。它是数字时代对传统图书馆模式的一种创新演变，满足了人们日益增长的数字阅读需求。\r\n\r\nhttps://zh.annas-archive.org","type":"text/markdown","created":"20230629040858247","creator":"oeyoews","modified":"20230726045248410","modifier":"oeyoews"},{"title":"心智模型","text":"心智模型是指人类的思维和认知过程的模型，它描述了人类思维的基本原理和结构。心智模型的目的是解释和预测人类的思考、决策和行为。\r\n\r\n心智模型可以分为不同的层次和组成部分，包括感知、注意力、记忆、思维和决策等。在感知层次上，心智模型描述了人类如何通过感觉器官接收外界信息，并对其进行处理和理解。在注意力层次上，心智模型解释了人类如何选择和集中注意力，以便处理重要或有趣的信息。在记忆层次上，心智模型描述了人类如何存储和检索信息，以及如何利用过去的经验来指导当前的思考和决策。在思维层次上，心智模型解释了人类如何进行概念形成、推理和问题解决。在决策层次上，心智模型描述了人类如何权衡不同的选择，并做出最佳决策。\r\n\r\n心智模型还可以包括情感和动机这样的因素，这些因素对人类的思维和行为产生重要影响。情感可以影响人类的注意力、记忆和决策，而动机可以促使人类追求目标并采取行动。\r\n\r\n心智模型的发展和研究有助于我们更好地理解人类思维和认知的基本原理，同时也有助于应用于教育、心理治疗和人工智能等领域。\r\n","type":"text/markdown","created":"20230409080717123","creator":"oeyoews","modified":"20230409080728326","modifier":"oeyoews","tags":""},{"title":"想要写的TiddlyWiki5插件","text":":::warning\n不再更新\n:::\n\n:::info\n🔌 (即将)想要写的 TiddlyWiki5 插件; 仅作为个人练习记录, 无意优化 TiddlyWiki5 的使用体验, 如果有那就算是无意的吧 😄\n:::\n\n\n## TODO\n\n:::todo\n- [ ] support `tiddlywiki --init oeyoews`\n- [ ] add dplayer(很少用到, 目前不做)\n- [ ] 构建输出的时候如果有大文件图片, 就输出警告\n- [ ] slugify plugin: 优化链接\n- [x] 默认不出现红框, 而是提示界面, 点击显示具体错误\n- [ ] for two thousands tiddler, daylight plugins will be slow to automatcially switch mode\n- [ ] 自动预览导入内容或者图片, 选择是否需要修改名字\n- [ ] 使用单独布局, https://github.com/casualwriter/vanilla- [x] chatgpt 模仿官网 ui\n- [ ] https://tiddlywiki.com/editions/translators/\n- [ ] tm-modal to write tiddler link notion\n- [ ] 盘古插件 neotw-pangu: 格式化文本， 符合基本中文习惯， 空格空行逗号处理\n- [ ] 文章标题支持 fold\n- [ ] autolist plugin\n- [ ] 浮动目录(markdown)\n- [ ] 所见即所得(个人并不是其爱好者, 更喜欢所写即所见)\n- [ ] 双链插件 链出/入 icon\n- [ ] 看板插件\n- [ ] 整屏滑动页面\n- [ ] 结合 motion 插件和 commandpalette 插件\n- [ ] grayscale page plugin\n- [ ] 可拖动 tiddler, 调整顺序\n- [ ] 全文输出 Rss 插件\n- [ ] 全文搜索插件 \n- [x] 日间模式插件\n- [ ] Tiddlywiki LSP\n- [ ] 插件更新提示插件\n- [ ] 类 vscode 插件商店\n- [ ] 工作区切换插件; 多故事河管理\n- [ ] breadcrumbs\n- [ ] layouts 搜索菜单\n- [ ] topbar to leftbar just like itab homepage\n:::\n\n## Ing\n\n:::info\n- [ ] update toggle sidebar position icon and effects\n:::\n\n## DONE\n\n:::example\n- [x] 时钟翻页效果 https://www.qireader.com.cn/tags/!readlater/entries/2pWeqXJNm71VrbXM\n:::\n\n## 写插件遇到的一些问题\n\n- [ ] pageControl 会把有颜色的图标变成黑白的\n- [ ] 启动时使用别的 layout, 切换到主 layout 后 topbar 消失\n- [ ] 某些 widget 的条目出现在故事河如果刷新, widget 会渲染两次\n- [ ] filter 在页面滚动时会进行刷新\n```plain \n<!-- tags: $:/tags/Macro -->\n\n<!-- This macro will cause twice refresh -->\n\n\\define publishFilter()\n-[!is[system]publish[no]]\n\\end\n```","type":"text/markdown","created":"20230619150240359","creator":"oeyoews","modified":"20231018062517889","modifier":"Lenovo","publish":"article","tags":"TiddlyWiki Plugins"},{"title":"报错日志","text":"```bash\r\njournalctl -b 1\r\n```\r\n\r\n```bash\r\nacpiphp: ACPI Hot Plug PCI Controller Driver version: 0.5\r\n10月 02 21:48:01 oeyoews kernel: PCI: MMCONFIG for domain 0000 [bus 00-ff] at [mem 0xc0000000-0xcfffffff] (base 0xc0000000)\r\n10月 02 21:48:01 oeyoews kernel: PCI: not using MMCONFIG\r\n10月 02 21:48:01 oeyoews kernel: PCI: Using configuration type 1 for base access\r\n10月 02 21:48:01 oeyoews kernel: ENERGY_PERF_BIAS: Set to 'normal', was 'performance'\r\n10月 02 21:48:01 oeyoews kernel: kprobes: kprobe jump-optimization is enabled. All kprobes are optimized if possible.\r\n10月 02 21:48:01 oeyoews kernel: HugeTLB: registered 1.00 GiB page size, pre-allocated 0 pages\r\n10月 02 21:48:01 oeyoews kernel: HugeTLB: 16380 KiB vmemmap can be freed for a 1.00 GiB page\r\n10月 02 21:48:01 oeyoews kernel: HugeTLB: registered 2.00 MiB page size, pre-allocated 0 pages\r\n10月 02 21:48:01 oeyoews kernel: HugeTLB: 28 KiB vmemmap can be freed for a 2.00 MiB page\r\n10月 02 21:48:01 oeyoews kernel: ACPI: Added _OSI(Module Device)\r\n10月 02 21:48:01 oeyoews kernel: ACPI: Added _OSI(Processor Device)\r\n10月 02 21:48:01 oeyoews kernel: ACPI: Added _OSI(3.0 _SCP Extensions)\r\n10月 02 21:48:01 oeyoews kernel: ACPI: Added _OSI(Processor Aggregator Device)\r\n10月 02 21:48:01 oeyoews kernel: ACPI BIOS Error (bug): Could not resolve symbol [\\_SB.PC00.I2C0.TPD0], AE_NOT_FOUND (20230331/dswload2-162)\r\n10月 02 21:48:01 oeyoews kernel: fbcon: Taking over console\r\n10月 02 21:48:01 oeyoews kernel: ACPI Error: AE_NOT_FOUND, During name lookup/catalog (20230331/psobject-220)\r\n10月 02 21:48:01 oeyoews kernel: ACPI: Skipping parse of AML opcode: Scope (0x0010)\r\n10月 02 21:48:01 oeyoews kernel: ACPI BIOS Error (bug): Could not resolve symbol [\\_SB.PC00.I2C1.TPL1], AE_NOT_FOUND (20230331/dswload2-162)\r\n10月 02 21:48:01 oeyoews kernel: ACPI Error: AE_NOT_FOUND, During name lookup/catalog (20230331/psobject-220)\r\n10月 02 21:48:01 oeyoews kernel: ACPI: Skipping parse of AML opcode: Scope (0x0010)\r\n10月 02 21:48:01 oeyoews kernel: ACPI BIOS Error (bug): Could not resolve symbol [\\_SB.PC00.I2C2.TPL1], AE_NOT_FOUND (20230331/dswload2-162)\r\n10月 02 21:48:01 oeyoews kernel: ACPI Error: AE_NOT_FOUND, During name lookup/catalog (20230331/psobject-220)\r\n10月 02 21:48:01 oeyoews kernel: ACPI: Skipping parse of AML opcode: Scope (0x0010)\r\n```","type":"text/markdown","created":"20231002140449062","creator":"oeyoews","modified":"20231002141904713","modifier":"oeyoews","tags":"gnome"},{"title":"择天记","text":"## 第 1 章 序 下山\r\n\r\n在这里，平静的云层像白色的丝绵向着四面八方蔓延，似乎没有尽头，上方的虚空镜面后是无尽的黑色深渊，里面有无数颗星辰。\r\n\r\n清晨醒来，他们在背书，烈日炎火，他们在背书，暮钟破哑里，他们在背书。春暖花开，夏雷震震，秋风萧瑟，冬雪凄寒，他们在垄上，在溪畔，在树下，在梅边，捧着道经不停地读着，背着，不知时间之渐逝。\r\n\r\n“不能治的病……那是命吧？” \r\n  “是的，那就是你的命。”\r\n\r\n## 第 2 章 我改主意了\r\n\r\n那少年穿着件洗到发白的旧道衣，容颜稚嫩，眉眼端正，眼眸明亮，有种说不出来的味道，仿佛能够看到很多事物里隐着的真相，就像镜子一般。\r\n\r\n## 第 4 章 这是个俗气的名字，但，是我的名字\r\n\r\n不是他很擅长让人不愉快，而是他在认真地做着自己认为应该做的事情。无论退婚还是改变主意，他都认为那是正确的，无比地肯定，以至于让人产生一种难以否定的感觉，于是，那些让他不愉快的人，最终都会郁闷到无法愉快起来。\r\n\r\n每个人在世间都是独一无二的。\r\n\r\n所以大道三千，他求的是顺心意——所谓顺心意，就是心安理得。\r\n\r\n她没有想到那少年在看到大周京都后，能够表现的如此平静，完全不像是没有见识的乡下孩子。那是因为她不知道那少年自幼看过无数卷书，在书里已经看过无数风景，行过无数里路。\r\n\r\n## 第 6 章 青衣少年三十六\r\n\r\n人类修行与妖族、魔族有很多不同，最开始的时候，讲究学以开心智，悟以养神识，借智慧明天地之理，借神识借天地之力，以能量淬炼身体，由皮肤毛发而始，直至筋膜肌肉，直至深入骨髓，炼至强壮，力能举石，身康体健不畏普通疾病，故名洗髓。\r\n\r\n初春京都云盛，太阳被遮在后方，天道院里清幽一片，忽然间，溪河两畔的草地变得极明亮，嫩绿新发的草枝，仿佛成了翡翠细枝，残留的露珠变成了明珠，清澈的溪水里，细细的游鱼瞪着眼睛看着天空，被突然到来的光明僵硬了身躯。\r\n\r\n## 第 7 章 开卷有喜\r\n\r\n拥有不言败的精神，而且活的足够严谨——我从来不认为天才有多么了不起，真正最可怕的人，是对自己最狠的那些人。”\r\n\r\n## 第 9 章 摘星\r\n\r\n认真而努力的孩子，值得特别的嘉赏。\r\n\r\n## 第 10 章 我有做错什么吗？\r\n\r\n但他是世上最珍惜时间的人，他不愿意把时间浪费在无谓的愤怒与悔怅里，只愿意把时间用在有价值的地方，这种表现有时候给人的感觉，便是百折不挠。\r\n\r\n聪明人会活的不快活，所以做人要难得糊涂。\r\n\r\n## 第 11 章 何日上青云\r\n\r\n“既然我没有做错什么，那么我为什么要改变什么？\r\n\r\n“好风频借力，送我上青云。\r\n\r\n## 第 14 章 让人无话可说的朋友（下）\r\n\r\n天才与白痴之间只有一线之隔，那道线就是可能性。\r\n\r\n## 第 15 章 徐有容\r\n\r\n书中有大道，一卷便胜过情爱无数。\r\n\r\n## 第 17 章 一间学院\r\n\r\n初春犹寒，湖风轻拂，茂密的野草，微微低下腰身，一片安静。\r\n\r\n## 第 18 章 国教学院的新生（上）\r\n\r\n所以一旦他看准目标，便会毫不犹豫地直线向前，不会彷徨、不需要呐喊，沉默执着，只争朝夕。\r\n\r\n## 第 21 章 第一页\r\n\r\n即便是无底的深渊，也不可能永远爬不出来。\r\n\r\n“书读百遍，其义自见。”\r\n\r\n## 第 22 章 读书的方法\r\n\r\n这种方法里最重要的环节，是最后那步的笔记。无论是用笔记在纸上，还在记在自己的脑海里，都是对整个阅读过程的再次梳理与确认，也只有完成了这一步，才能说阅读者把书里的内容完全转化成了自己的知识。\r\n\r\n闻道有先后，先发而后至，后发而先至。”\r\n\r\n## 第 23 章 就这么简单\r\n\r\n因为要吃晚饭，所以可以无视眼前触手可得的改变命运的机会。如果说这是自律，这自律未免也太严苛残酷了些，更像是某种自虐，但也可以说是某种自信，因为他相信那机会不会溜走。\r\n\r\n## 第 24 章 星之海洋\r\n\r\n能够凝神，便能够定星，能够定星，便能够引星光洗髓，能够洗髓便能够坐照自观，能够坐照自观，就能够心意通幽，明天地造化，能够通幽，便能够聚星于体，百病不侵，能够聚星便能够从圣而行，御风万里，最后方能神隐于天地之间，不在命轮之内，或者那时就不需要逆天改命了？\r\n\r\n所谓修行，便是将天地的力量借为人的力量。\r\n\r\n无法解释的联系，就是命运。\r\n\r\n## 第 25 章 万千星辰，只取一颗\r\n\r\n那是因为他比任何人都清楚，活在这个世界上真正的诱惑是什么。\r\n\r\n如果这是南墙，他已经到了墙根，总得把头触上去，才能甘心。\r\n\r\n## 第 26 章 甘露台与百草园\r\n\r\n因为她叫落落，她很大方。\r\n\r\n## 第 27 章 厚积\r\n\r\n就像雪片穿过风和树林落到了地面上。 \r\n  没有一片树叶承接住了一片雪，这是很难发生的事情。 \r\n  但真的发生了。 \r\n  现在看来这片树林依然郁郁葱葱，没有一点白色。 \r\n  事实上呢？ \r\n  树林下方的地面上，积雪已然渐厚。 \r\n  这便是厚积。 \r\n  总有一天，将会薄发。 \r\n  或者，暴发。\r\n\r\n## 第 28 章 已多年\r\n\r\n淡然有时候会让人失去一些锐气，但也会让人变得更加冷静\r\n\r\n## 第 37 章 谢谢\r\n\r\n春和景明，湖静如镜，偶有风穿堂而过，绕书架，落鬓间。\r\n\r\n## 第 38 章 第一堂课\r\n\r\n好奇是所有智慧生命最难止住的痒，是最大的诱惑\r\n\r\n敢于去想，在梦想实现之前，永远不给自己提前设限，不给自己寻找任何退缩的借口、失败的理由，只有这样，我们才有可能把看似遥远的梦想，变成真正的现实。\r\n\r\n## 第 39 章 指点\r\n\r\n风雨渐落，斜阳残，夜色渐至，旧园静。\r\n\r\n暮色并不如血，如馄饨摊的炉火，温暖至极。\r\n\r\n## 第 40 章 从百草园到国教学院\r\n\r\n“沉默地读书修行，不显山不露水，只在溪里做只无人闻津的游鱼，只待某朝风雨大动，那只鱼儿跃过龙门，变成真正的巨龙，俯瞰着整个大陆，名声显于天地之间……”\r\n\r\n## 第 41 章 第一夜\r\n\r\n与其把时间浪费在愤怒里，还不如用来做些真正有意义的事情，比如读书修行，修行读书。\r\n\r\n## 第 43 章 庄换羽\r\n\r\n我的眼中只有你，你有的眼中却只有别人，这本来就是人世间最令人愤怒的事情。\r\n\r\n## 第 45 章 宗祀所的小怪物\r\n\r\n世界如此美好，自己何必如此暴躁？\r\n\r\n## 第 46 章 我叫落落\r\n\r\n小孩子不懂事，向来都是最好的借口，不是吗？\r\n\r\n## 第 47 章 虎虎生风\r\n\r\n落落懂了他的意思，然后忽然明白自己做错了——先前自己不该看先生，那一眼是习惯，是尊重，但也等于是把选择的权力以及随后需要承担的责任，都丢给了先生，这是非常不对的事情。\r\n\r\n## 第 53 章 有些乱\r\n\r\n陈长生没有回头，说道：“菜有些咸，我想去静静。”　　今天的菜有些咸。　　他的声音有些淡。　　这句话有些乱。　　因为他的心乱了。\r\n\r\n## 第 57 章 人品问题\r\n\r\n人品，便是道义无亏，无损。　　得道者，必然多助。\r\n\r\n## 第 58 章 公平问题\r\n\r\n可惜小人物不曾见过沧海，如何懂得什么是壮阔？不曾摘下星辰，如何懂得什么是浩瀚？你终究是不懂冰雪为何物的夏虫罢了。”\r\n\r\n天下人说天下事，何须胆大？”\r\n\r\n## 第 59 章 桐宫之囚\r\n\r\n大道三千，他修的是顺心意。顺心意而行，顺心意而活，天地让他不得顺心意，他便要想办法让自己的心意顺起来，只有顺心意，才能拥有真正的平静，而平静，正是冷静的最高境界。\r\n\r\n因为只有顺心意，才能逆天命。\r\n\r\n## 第 60 章 独闯龙潭\r\n\r\n他始终都在绝望的深渊里寻找着希望，他每天每夜都在向死而生。\r\n\r\n## 第 64 章 吱吱\r\n\r\n如果人类可以相信，我们才应该是世界的统治者。\r\n\r\n## 第 66 章 问世间\r\n\r\n提亲为始，倾身为礼，缔约为书，这便是订婚。\r\n\r\n## 第 69 章 白鹤为凭（下）\r\n\r\n“因为我已经有婚约了，我的未婚夫叫陈长生。”\r\n\r\n## 第 70 章 白帝为姓（上）\r\n\r\n你和这些人说利益，他们说情怀，你和他们说情怀，他们和你说道德，你和他们说道德，他们和你说道理，总之，当这些人说不过你的时候，当他们没有道理的时候，他们便会不停转进，直到事情按照他们的想法或者说想象进行。\r\n\r\n## 第 72 章 有一个少年\r\n\r\n大义？终究不过是利益，或者说权势，仔细想来，真的有些可笑。\r\n\r\n他是个十六岁的少年，真正的少年，看着春风不喜，看着秋风不悲，看着冬雪不叹，看着夏蝉不烦，他看着喜欢的才喜，看着厌憎的便烦，看着不公平的便叹，看到夕阳下的壮烈背影才会悲。\r\n\r\n## 第 73 章 第四个人\r\n\r\n不过，做人首先确实应该做自己。”\r\n\r\n## 第 77 章 崩云乱\r\n\r\n硬撑固然是勇气，学会后退更是一种智慧。\r\n\r\n## 第 94 章 院门与人心\r\n\r\n—我没有错，那我凭什么不硬，气势凭什么不强？\r\n\r\n## 第 95 章 门房，对话，床上的人\r\n\r\n有句话他依然藏在心底，不能治的病不是病，是命。\r\n\r\n“我家祖训有类似的话——在铜钱眼里看人，看的最准。”\r\n\r\n## 第 96 章 怪一场秋雨\r\n\r\n“秋雨敲窗，果然好眠。”\r\n\r\n## 第 97 章 战一座京都（上）\r\n\r\n“任何事实，都要发生之后，才能确定为事实。”\r\n\r\n## 第 99 章 战一座京都（下）\r\n\r\n原来生命有很多种过法，或者说玩法。 \r\n  也许没有意义，但真的很有意思。 \r\n  而且，这样真的很容易快乐起来。\r\n\r\n## 第 102 章 修行，高于生死\r\n\r\n是的，天之道向来极为公平又极为不公平，损有余而补不足，七字道尽所有。\r\n\r\n## 第 103 章 满山野花盛开的年代\r\n\r\n天道高远，难以评价，吾辈当上下求索，勤奋精进。”\r\n\r\n最重要的是，这三个小家伙仿佛都不知道什么叫害怕，什么叫气馁，他们对世界有自己的看法，而且坚定，心思像琉璃一样剔透，阳光落在他们的身上，会折射出更为艳丽夺目的光彩。\r\n\r\n夜空里有无数繁星，京都城里有万家灯火，彼此交辉，看的久了，你竟很难分辨哪一面是天，哪一面是地。\r\n\r\n## 第 104 章 百草园怀旧\r\n\r\n他认为生存的年岁长度是非常重要的事情，而且就像杯中的黑茶一样，越陈越香，越名贵，越能从里面品出更多，他遗憾于自己很难经历岁月的过程，所以格外尊敬年长者，注重辈份伦理。\r\n\r\n## 第 111 章 一花一世界\r\n\r\n老实人说诚实话，最有力量，最能打击人。\r\n\r\n## 第 114 章 教宗\r\n\r\n因为星空之上有命运，星空之下只有生命值得敬畏，生命本身便是最大的压力\r\n\r\n## 第 122 章 指间的星光（下）\r\n\r\n想要活下去，似乎真的需要拼命。\r\n\r\n## 第 126 章 我真的还想再活五百年\r\n\r\n任何能够平静迎接死亡、挑战死亡的生命，都值得敬佩。\r\n\r\n## 第 134 章 文试开始\r\n\r\n不刻意平静才是真正的平静，才代表着自信。\r\n\r\n## 第 144 章 骑鹤下江南\r\n\r\n于岸边听涛，看似影单脱俗，实际上还是心向喧哗。\r\n\r\n## 第 148 章 前进的拳头\r\n\r\n后退，永远没有前进快。\r\n\r\n## 第 153 章 万万没想到\r\n\r\n世间很多事情都是这样，尤其是对于少年阶段的男人们来说，当很多人想关心你的时候，你会很抗拒这种关心，不想理会对方，而当那些关心你的人准备离开的时候，你便会开始提前感到孤单，有些不安。\r\n\r\n所有负面情绪，都应该被瞬间击败或者说抛弃。\r\n\r\n## 第 154 章 崖畔\r\n\r\n为天地立心，为生命立命，为往圣继绝学，为万世开太平，所以请你去死。\r\n\r\n## 第 160 章 而胜\r\n\r\n用未拥有去换最值得追求，哪怕是只存在于未来的可能，也是值得的。\r\n\r\n## 第 186 章 榜首慢走\r\n\r\n照耀世间，带来生命需要的光与热，又不刺眼炽热，晚霞与朝霞真的没有什么差别，后者出现的时间要晚些，但一样灿烂。\r\n\r\n## 第 188 章 一夜之间，万人之前\r\n\r\n在绝望的深渊里沉默地前行，没有同伴，没有手杖，看不到阳光，却不曾停下脚步，终于走出迷雾，看到了希望，这让他感觉更好。\r\n\r\n生死之外皆是寻常事，或者小事。\r\n\r\n## 第 198 章 曾经的三个人（上）\r\n\r\n命运是人与人的运动轨迹的总论。\r\n\r\n## 第 201 章 没有命运这回事\r\n\r\n“人间本没有路，路只是在我们的脚下，看你怎么走，怎么选择自己的位置。”　　“位置是相对的，我视君为君，我便是臣，我眼中无君，我便不是臣。”　　“所以，没有命运，只有选择。”\r\n\r\n## 第 205 章 天书陵\r\n\r\n但生命难道不应该是自由而喜悦的吗？怎么能尽数放在这片青山中？\r\n\r\n## 第 208 章 篱笆墙畔两小儿\r\n\r\n陈长生问道：“那对你来说，什么才是最重要的事情呢？” \r\n  折袖说道：“清醒的活着，或者清醒的死去。”\r\n\r\n## 第 212 章 去陵南\r\n\r\n折袖神情漠然说道：“战斗，风雨，天地自身，还有贫穷苦寒，最重要的是，天书陵外有生死。”\r\n\r\n## 第 214 章 战风雪\r\n\r\n生命，就是要痛苦才真实。\r\n\r\n## 第 216 章 于晨时观碑\r\n\r\n棋琴书画，欣赏风景，也都是浪费生命。　　但这种浪费生命的方法多么美好。　　有生命可以用来浪费多么美好。\r\n\r\n## 第 217 章 照晴碑\r\n\r\n一江烟水照晴岚，两岸人家接画檐，淡荷丛一段秋光，卷香风十里珠帘。\r\n\r\n## 第 224 章 夜里挑灯看碑（下）\r\n\r\n万溪风光不同，终究同入大海。”\r\n\r\n## 第 226 章 往事知多少（下）\r\n\r\n不能把有限的生命浪费在无限的破事上。”\r\n\r\n## 第 232 章 一日看尽前陵碑\r\n\r\n一江烟水照晴岚，两岸人家接画檐，淡荷丛一段秋光，卷香风十里珠帘。”\r\n\r\n## 第 233 章 断碑\r\n\r\n“十四年不修行，只读书，一年通幽。二十日不解碑，只静坐……一日看尽前陵碑。”\r\n\r\n## 第 234 章 应作如是观（上）\r\n\r\n陈长生的性情虽然平稳，但非常在意顺心意。他想要问个究竟的渴望，或许表现出来的很淡然，实际上同样强烈，如野火一般。\r\n\r\n## 第 235 章 应作如是观（下）\r\n\r\n在修道者的识海里，你如何看待世界，世界便会变成你想要看到的模样。\r\n\r\n## 第 240 章 出陵\r\n\r\n他前所未有地坚信，自己能够改变自己的命运，而不需要通过改命他人的命运从而改变自己的命运。\r\n\r\n## 第 275 章 不想走进黑夜的人们\r\n\r\n再美的人儿，如果只是看她的美，那么总有一天会看腻。\r\n\r\n在这种时候，他更要认真地活着，活给死亡看。\r\n\r\n## 第 302 章 人生若只如初见（三）\r\n\r\n不愧是国教学院的诚实可靠小郎君，这番解释还不如不解释。\r\n\r\n## 第 305 章 人生若只如初见（六）\r\n\r\n女生的情绪问题，永远只能交给时间来解决，很多时候，她们只是觉得伤心难过，想要哭，那么你就让她们哭便是，陪着便是，需要递手绢的时候递一递，需要奉献肩头的时候不要客气，并不需要你在旁不停地安慰说话。在她们还没有真正平静下来、不想搞事的时候，你做的任何事都是多事。\r\n\r\n## 第 310 章 人生若只如初见（十一）\r\n\r\n人性是不能考验的，每考验一次，便有可能向出题者相反的方向走一步，同样，信任也不是拿来用的，每用一次都是对信任的一次磋磨。\r\n\r\n## 第 311 章 人生若只如初见（十二）\r\n\r\n“雪山宗，徐生。”　　“秀灵族，陈初见。”\r\n\r\n## 第 314 章 清风问道\r\n\r\n现在做不到，不代表以后也做不到，而且就算一直都做不到，又有什么？努力应该是发自内心的渴求，而不应该来自与别人比较而产生的心理落差，只要真的努力过了，那就足够。\r\n\r\n闭上眼睛就是天黑，不看世界，世界就不存在。\r\n\r\n## 第 318 章 等待命运的到来\r\n\r\n时间果然才是世间最强大的法器。\r\n\r\n## 第 323 章 临渊对谈，一个动心人\r\n\r\n师兄说过，如果努力到最后发现还是无法改变命运，那么只好体味或者享受命运带给你一切。”\r\n\r\n## 第 324 章 不能要的女人，无耻的男人\r\n\r\n只有干干净净地做事，才能得到漂漂亮亮的结果。\r\n\r\n## 第 330 章 清冷的第一剑\r\n\r\n我相信有命运这回事，但我不相信命运可以决定所有事。\r\n\r\n## 第 375 章 全职教育（三）\r\n\r\n记住，敌人的敌人不见得是朋友，因为中间有个东西叫利益。\r\n\r\n所谓历史，不过就是当下的证据，所谓现在，也不过就是历史的重复。\r\n\r\n## 第 388 章 简单少年\r\n\r\n直觉，很多时候就是大量计算及练习后产生的类似本能的反应。\r\n\r\n## 第 397 章 一场盛宴的开端\r\n\r\n世间有很多事情只能做不能说，更不能让人看见，不然不好交待。\r\n\r\n## 第 398 章 有时候，救人得先学会杀人\r\n\r\n存在于人世间，想要自由地活着，想要保护自己心爱的人不受伤害，你必须足够强大，并且让整个世界都承认你的强大，畏惧于你的强大。如何证明，如何让世界承认这一点？你要敢于杀人，敢于让整个世界流血。\r\n\r\n## 第 408 章 三棵松（上）\r\n\r\n没有人会随着年岁增长品德就天然提升，绝大多数时候都是一个年轻的傻逼变成了老傻逼\r\n\r\n## 第 409 章 三棵松（下）\r\n\r\n“滔滔大河分两岸，哪怕只看不语，也总要选一边。”\r\n\r\n我若是砥柱，就该站在大河中央，我若是浮萍，就该顺水而下，我是苏离，我凭什么要站在岸边？\r\n\r\n## 第 422 章 还是那座秋山（上）\r\n\r\n名声这种事情，是不需要任何证据，只需要恶意地猜测便可以毁去的，\r\n\r\n## 第 426 章 父与子（上）\r\n\r\n你们已经老了，可以活得现实一些，但我们还年轻，如果我们活下来，必将还有漫长的岁月等着我们，我不想在以后的岁月里想起今日便后悔、痛苦，所以我不会按照你们的方法行事。\r\n\r\n## 第 434 章 有朋自南方来\r\n\r\n明知不可为却要为之，明知不敌却要战之。\r\n\r\n## 第 438 章 落日不见是清晨\r\n\r\n那些老人……老了，腐朽了，死气沉沉，不求上进，只知道玩阴谋手段，不光明，不磊落，不敞亮，所以没有锋芒，没有锋芒的力量，对人类来说没有任何意义\r\n\r\n## 第 449 章 共商何事\r\n\r\n生死之外，皆是闲事。 \r\n  死生亦大矣。 \r\n  人生无大事，唯生死系之。\r\n\r\n## 第 450 章 锦鲤，沉塘，铁刀的光芒\r\n\r\n你要明白，我们想成为什么样的人，那么我们的世界就会变成什么样。”\r\n\r\n## 第 455 章 钟声响起归家的讯号\r\n\r\n“成熟真是一件很困难的事情，因为很难把握其间的度，果子熟透了，就很容易腐烂。”\r\n\r\n## 第 460 章 车往何处去？\r\n\r\n人世间很多事情，都是这样，无论生活还是工作，哪有那么容易便告一段落的道理，绝大多数时候，都是无趣的枯躁重复。\r\n\r\n## 第 465 章 少年与光阴\r\n\r\n一个不成熟的人的标志，是他愿意为了某个理由轰轰烈烈地去死，一个成熟的人的标志，是他愿意为了某个理由谦恭地活下去。\r\n\r\n## 第 466 章 天道西流去\r\n\r\n这里的安静，代表着很多意思，比如在不需要说话的时候，不说话，拙于言而敏于行，却静于心，比如遇大事有静气。\r\n\r\n## 第 469 章 越女\r\n\r\n有些事情自己默默记在心里就好，不需要表现出来，只需要做，冲动与热情从来都不是同义词，冷静绝不代表怯懦。\r\n\r\n除了追求自己想要的以及必须得到的，所谓成长的过程，不就是担起一个又一个的责任？\r\n\r\n## 第 471 章 那些你所不知道的事情\r\n\r\n任何男子做父亲的时候，总会变成他年轻的时候最讨厌的岳父大人。”\r\n\r\n## 第 472 章 你帮我把伞还给他\r\n\r\n如所有故事或真实的人生一样，人们总会遇到这样或那样的问题，有的问题会让你饮了毒药投了坟，有的问题却让你啼笑皆非美了姻缘，归根结底，故事或人生的结局与其间的那些问题并没有太大的关系，重要的是你怎么去解决那些问题。\r\n\r\n## 第 483 章 黯然销魂者\r\n\r\n离开的人，在人们的心里总是会重要些。　　永远离开了的人，在人们心里的位置便将永远无法被人取代。\r\n\r\n## 第 489 章 招生风波（四）\r\n\r\n一力降十会，污言破慧心\r\n\r\n## 第 498 章 苦修教士，少年宗师\r\n\r\n“君子可以欺之以方，这当然不见得是对的，我虽然不是君子，但也不是小人，但您这位曾经的君子，既然被小人所用行非君子之事，那我自然也只能以小人之道应之。”\r\n\r\n## 第 509 章 再入周园\r\n\r\n“痛苦。”折袖看着他的眼睛，说道：“可以激发生命力，越大的痛苦越能激发出越多的生命力，只要你能够清醒地承受那种痛苦。”\r\n\r\n## 第 516 章 时光泡烂了过往\r\n\r\n痛苦是激发生命力最直接和最有力的手段\r\n\r\n## 第 541 章 倾伞如故否？\r\n\r\n一路同生共死，朝夕相伴，坐而论道，起而迎敌，倾盖如故，白首到老。　　倾伞，便如故。\r\n\r\n## 第 547 章 雪夜入宫\r\n\r\n弄错了一些事情，不重要，忘记了一些事情，更不重要，只要有些事情记得就好。\r\n\r\n真实且有重量的想念叫做相思，一旦相思，自难成眠。\r\n\r\n## 第 600 章 他决定破境的时候故人来了\r\n\r\n友情与爱情是美好的，在某些时候可以拯救你的生命与灵魂，但最靠得住的，始终还是你自己拥有的力量。\r\n\r\n## 第 607 章 直剑\r\n\r\n机缘往往来自于挫折，突破往往原于生死间的考验。\r\n\r\n## 第 622 章 星空之下，无所敬畏\r\n\r\n无论人性还是人心，都是不能考验的，因为当你开始想方法去考验它的时候，说明你已经开始怀疑。”　　教宗最后说道：“而怀疑，是一切不幸的根源。”\r\n\r\n纵使身在高处，依然心存敬畏，这样的人很了不起。　　从始至终，从天到地，从光明至黑暗，无所敬畏，这样的人很可怕。\r\n\r\n## 第 626 章 何以度余生？\r\n\r\n悲剧，或者是把美好地撕碎了给人看，悲伤，则是看着美好却无法靠近，最后被迫转身远离，就此不见。\r\n\r\n如果知道自己的生命只剩下数十天，你会怎样度过这段时间？列出最想做而没有做成的事情来个心愿清单然后卖房卖田去逐一实现？还是躲在房间的阴暗角落里每天以泪洗面？又或者是无视所有道德规则去放纵自己内心深处的欲望与恶念？\r\n\r\n## 第 637 章 杀周（第一季之中）\r\n\r\n唯宁静方能致远。　　可以至远。\r\n\r\n## 第 647 章 母子（下）\r\n\r\n“每个人都要对自己的选择做出解释，就算不在意世人如何看，也总要说服自己。”\r\n\r\n## 第 660 章 森然大阵\r\n\r\n勇气这种东西，或者需要十余年甚至更长时间的羞辱与夜夜难眠才能积蓄起来，但要失去，往往却只是一瞬间的事。\r\n\r\n## 第 692 章 一件事情\r\n\r\n愚，并不意味你就有权力不讲道理，更不意味着需要被敬重。\r\n\r\n## 第 694 章 一颗石头\r\n\r\n既然你用这个世界压我，那我就用我的世界打你。\r\n\r\n## 第 697 章 封城\r\n\r\n生命是一个极其漫长的过程，在这个过程中，我们会遇到很多的困难，会生出很多的失望，也就是所谓劫数，怎样面对这些劫数，是带着劫后余生的庆幸苟活着，还是经过认真的思考后重新找回自己，这是最重要的分别。\r\n\r\n## 第 703 章 生者\r\n\r\n大事之后，表现最疯狂的、经常做出一些最不可思议举动的人，就是那些背叛者，似乎只有通过这种近乎歇斯底里的表现，他们才能证明自己现在的忠诚与以前的忠诚并不相同，才能说服自己不用担心会被新的当权者抛弃，从而获得免于恐惧的自由。\r\n\r\n## 第 705 章 真人\r\n\r\n什么是顺心意？　　他如果看青山妩媚，那便罢了。　　他如果看青山不爽，那便要移掉。　　如果前路平直，那便罢了。　　如果路有不平，自然要出刀。　　风景如果清美，那便欣赏。　　如果满眼污烟瘴气，又如何能够沉默？\r\n\r\n## 第 724 章 初雪落\r\n\r\n惩罚丑恶，便是歌颂美好。”\r\n\r\n## 第 725 章 闻道有先后\r\n\r\n世间最了解你的人，往往不是你的朋友，而是你的敌人。\r\n\r\n## 第 737 章 不管怎么走都是向前\r\n\r\n一个喜欢读书、喜欢思考、喜欢做笔记、喜欢做解题的人，总会比他的对手准备得更加充分，往往会取得很多不可思议的胜利。\r\n\r\n## 第 761 章 最深的阴影\r\n\r\n唯立于星空之下，俯仰无愧，回首无憾，方能无所畏，无所惧，道心通明，道法无碍。\r\n\r\n人的心意总是在真真假假之间浮沉，纵把那花色香都看化，也无法看透这些。\r\n\r\n## 第 837 章 星空与姑娘（上）\r\n\r\n对不喝酒的人来说，喝酒的唯一理由就是与他一起喝酒的人是谁。\r\n\r\n## 第 838 章 星空与姑娘（下）\r\n\r\n但世间有很多事情与你自身的努力没有任何关系，比如男女之间的情事，比如生死之间的大事。无论你如何奋斗成长，都不能确定战胜对方，因为这两种关系，需要的是回应。\r\n\r\n## 第 841 章 春风绿两岸\r\n\r\n位置是相对的，处于不同的位置，自然要选择不同的做事方法。\r\n\r\n## 第 862 章 春风入老城\r\n\r\n不问而取是为偷，不问而至是为袭。\r\n\r\n## 第 877 章 老宅古井，咸菜清粥\r\n\r\n名不正则言不顺，言不顺则事难成。”\r\n\r\n## 第 881 章 秋山啊……\r\n\r\n“我用了二十年的时间来守护我的名望，现在想起来，可能就是为了这个世界相信我一次。”\r\n\r\n## 第 893 章 城外有轿至\r\n\r\n因为唯一的选择就是最好的选择。\r\n\r\n## 第 911 章 我会在深渊里等你\r\n\r\n我不会去星海，我将去往深渊，我将永远不会忘记你，我会一直在那里等待你的到来。”\r\n\r\n## 第 918 章 开卷有钱\r\n\r\n沉默啊沉默，不在沉默里暴发，那么在沉默里尴尬。\r\n\r\n## 第 923 章 一场会写入史书的谈话\r\n\r\n师叔当年对我说过，善良的人们更要警惕……警惕需要拥有相应的能力，不然就会变成笑话。”\r\n\r\n殊途可能同归，但踏上旅程的原因并不相同\r\n\r\n## 第 954 章 相看两厌\r\n\r\n修道本是逆天事，便是柔弱女子，也当持道前行，站在河畔看风景一世，固然清妙自在，但连鞋底都舍不得湿，又如何能够踏波而去，最终登临彼岸？”\r\n\r\n可以尊重，可以理解，但不会接受，不会被你说服，更不会被你改变，不行就是不行，行也不行。\r\n\r\n## 第 956 章 知易守难心而已\r\n\r\n知其雄，守其雌，始为天下溪\r\n\r\n如果我的事情都不能打破你的冷静，那才是你应该抱歉的事情吧？\r\n\r\n## 第 976 章 有人破云，伴天光而落\r\n\r\n活着啊，最重要的事情不是看我们有用没用，而是看我们能不能活的顺心顺意，能不能活的开心。\r\n\r\n## 第 998 章 一样的暮光\r\n\r\n“国教学院，轩辕破。”\r\n\r\n## 第 1038 章 天树情话\r\n\r\n孤单只需要一个人，寂寞则需要两个人，因为那是分离之后的相思。\r\n\r\n## 第 1047 章 生存还是毁灭，井底还是井口？\r\n\r\n好人不见得有好报，甚至活着的时候也谈不上自在，那么为何一定要做好人，我们应该怎样活着，我们为何活着？\r\n\r\n## 第 1052 章 与世界的对话，与自己的谈判\r\n\r\n“在某些重要的时刻，总要要学会取舍。”　　牧夫人说道：“我以为那就是成熟或者腐朽的最大特征。”\r\n\r\n## 第 1084 章 白帝城中云出门（下）\r\n\r\n山无陵，江水为竭。　　冬雷震震下雨雪。　　天地合。　　乃敢与君绝。　　这便是绝别。　　黯然销魂者，唯别而矣。　　更何况是绝别。\r\n\r\n## 第 1085 章 帝心皆风雪\r\n\r\n这不是求不得，而是歉意以及被崇拜、被爱者的喜悦融合在一起的无比强烈的保护欲。\r\n\r\n## 第 1086 章 我见\r\n\r\n如果时间能够让我们遗忘所有的过往，那我们的存在还有什么意义？”\r\n\r\n## 第 1091 章 她说\r\n\r\n过去就让它过去，这是一句很简单的话，很简单的道理，但不是所有人都能做到。\r\n\r\n徐有容轻声说道：“我就喜欢他无论遇着任何事情，哪怕是生死之间的大恐怖，都绝不郁郁，而且并不是放弃之后的放浪形骸，依然专注与执着，坚定且平静。”\r\n\r\n## 第 1099 章 教宗的归来\r\n\r\n做选择是世间最困难、有时候也是最痛苦的事情。\r\n\r\n## 第 1130 章 她可以，我也可以\r\n\r\n天若有情天亦老，唯无情者，方能成大事。\r\n\r\n## 第 1136 章 寂静的春天\r\n\r\n大道若可直中取，何必曲中求。”\r\n\r\n## 第 1141 章 你怎么不去死？\r\n\r\n“如果天下苍生真的这么重要，那你们为何不能为他们去死呢？”\r\n\r\n## 第 1145 章 你不想试试吗？\r\n\r\n只是偶尔还是会有些遗憾。 \r\n  再无少年时。\r\n\r\n## 第 1158 章 大日如来谁可安？\r\n\r\n什么叫一饮一啄，皆有定数？ \r\n  什么叫草蛇灰线，伏延千里？ \r\n  落子便有深意，哪有什么闲棋！\r\n\r\n## 第 1167 章 关于陈生生的一切\r\n\r\n他人是地狱。　　死亡是明镜。　　可以正衣冠。　　可以明心意。\r\n\r\n## 第 1173 章 如果你是除苏\r\n\r\n悲惨的人生经历可以是精神上的财富，但不能是债务，随便转到别人头上。\r\n\r\n## 第 1203 章 福缘深厚的小道士\r\n\r\n在真正的终点之前，所有做过的事与遇见的人都是旅程。\r\n\r\n## 第 1209 章 血的沼泽\r\n\r\n“每个人都是自私的，尤其当他无私的时候。”\r\n\r\n## 第 1219 章 艳阳天\r\n\r\n走的再慢，只要肯走，便总能走到彼岸。\r\n\r\n## 第 1232 章 圣光大陆之行\r\n\r\n活着，应该是主动行为的集合。”\r\n\r\n“好奇心是我们生而为人最美好的禀性，值得为之冒险，甚至付出所有。”\r\n\r\n## 第 1235 章 后记\r\n\r\n命里有时终须有，命里无时要强求","type":"text/markdown","created":"20230614012333299","creator":"oeyoews","modified":"20230929060020095","modifier":"oeyoews","page-cover":"https://img1.doubanio.com/view/subject/s/public/s29521409.jpg","publish":"public","tags":"books"},{"title":"排序sort","text":"JavaScript 中内置的 `Array.prototype.sort()` 方法的具体排序算法是不确定的，因为它可以根据不同的 JavaScript 引擎和浏览器实现而异。不同的引擎可能会选择不同的排序算法来实现这个方法。\r\n\r\n一些 JavaScript 引擎可能会使用快速排序（Quick Sort）或合并排序（Merge Sort）等高效的排序算法来实现 `sort()` 方法。这些算法通常在平均情况下表现良好，但在某些特定情况下可能会退化为较差的性能。\r\n\r\n有些引擎还可能根据数组的长度和内容使用不同的排序算法，以优化性能。例如，当数组的长度较小时，可能会选择使用插入排序（Insertion Sort）等简单但在小规模数据上效果不错的算法。\r\n\r\n由于 JavaScript 引擎的实现会不断演化，具体的排序算法可能会有所变化。因此，在编写依赖于排序算法的代码时，最好不要对排序算法的实现细节作出假设，而是依赖于内置的 `Array.prototype.sort()` 方法来进行排序。\r\n\r\n学习排序算法仍然是有意义的，尽管现代编程语言和框架提供了内置的排序功能。以下是一些学习排序算法仍然有价值的理由：\r\n\r\n1. **算法理解与优化：** 学习排序算法可以帮助你更深入地理解算法设计和优化的原理。理解不同排序算法的时间复杂度、空间复杂度、最佳和最差情况等，有助于你在编写性能优化的代码时做出明智的选择。\r\n\r\n2. **面试和编程挑战：** 在技术面试和编程挑战中，排序算法是常见的问题。了解多种排序算法可以帮助你在面试中表现更出色，并且在解决各种编程问题时能够选择合适的排序策略。\r\n\r\n3. **特定场景需求：** 尽管内置排序方法足够满足大多数情况，但在某些特定场景下，你可能需要实现或优化排序算法。例如，你可能需要针对特定数据分布或数据量较小的情况进行性能优化，而不同的排序算法在不同的情况下可能会表现更好。\r\n\r\n4. **编程能力的提升：** 学习排序算法可以培养你的算法思维，让你在解决各种问题时能够更加灵活和创新。这种思维方式有助于你在编写高效和可维护的代码时更好地选择合适的算法和数据结构。\r\n\r\n5. **深入计算机科学：** 排序算法是计算机科学的基础知识之一。通过学习排序算法，你可以更好地理解计算机科学的核心概念，为进一步深入学习其他算法和数据结构打下坚实基础。\r\n\r\n综上所述，学习排序算法仍然具有很大的价值。尽管你可能不需要在日常开发中手动实现排序算法，但理解它们可以帮助你成为更出色的程序员，并在特定情况下做出更明智的选择。","type":"text/markdown","created":"20230827144601753","creator":"oeyoews","modified":"20230827144720519","modifier":"oeyoews","tags":"JavaScript"},{"title":"插件依赖递归","text":":::info 插件递归\n如果你写了新的 echart addon, 除了提交到 tw-echarts 仓库, 还可以单独写一个插件, 借助 cpl,你只需要声明 parrent-plugin, 这样你就可以在安装 echarts 的同时安装所有的子插件(addon),不过只有第一次安装的时候有效, 如果以后想要找到新的 addon, 可以看 echart 的包括的子插件, 手动安装即可.\n:::\n\n父插件和子插件逻辑上是相互的, 只要安装了其中的一个,另外一方插件就会自动安装, 并且理论上双方支持相互进行递归. \n\n* 以上借助 echarts 举例, 其他插件同理\n\n:::warning 危险\n不过突然想到, 这种机制很危险, 比如有人恶意写一个插件,并且把父插件写为下载量较高的插件, 有可能造成数据丢失, 更重要的还是数据泄露; cpl 以后还是有加上一层安全机制的必要的. 不知道 ob 如何处理这种情况的\n:::","type":"text/markdown","created":"20231013130107753","creator":"Lenovo","modified":"20231013131509488","modifier":"Lenovo","tags":""},{"title":"数字人","text":"数字人是指通过计算机技术和人工智能算法创建出来的具有智能和交互能力的虚拟人物。它们通常以人类的形象出现，可以通过语音、图像或视频等方式与人类进行沟通和交流。\r\n\r\n数字人的创建过程涉及多个技术领域，包括计算机图形学、机器学习、自然语言处理等。首先，通过建模和渲染技术，将数字人的外观、表情和动作设计出来，使其看起来更像真实的人类。然后，使用机器学习算法对数字人进行训练，使其能够理解和生成自然语言，以及具备一定的智能和决策能力。这样，数字人就可以通过语音识别和语义理解技术来理解人类的指令和问题，并通过语音合成或图像生成技术生成对应的回应。\r\n\r\n数字人在许多领域有着广泛的应用，包括虚拟助手、在线客服、教育培训、娱乐和游戏等。它们可以与人类进行实时对话和互动，为用户提供信息、答疑解惑、娱乐等服务。数字人还可以通过分析用户的行为和偏好，提供个性化的推荐和建议，使交互体验更加智能和个性化。\r\n\r\n然而，数字人的发展仍然面临一些挑战和限制。目前的数字人技术还无法完全模拟出人类的情感和认知能力，使得它们在某些复杂的情境下可能无法做出准确的回应。此外，数字人的隐私和安全性也是一个重要的问题，需要保护用户的个人信息和交互数据。\r\n\r\n总的来说，数字人代表了人工智能和计算机技术在模拟人类智能和创造虚拟交互体验方面的重要进展，未来有望在各个领域得到更广泛的应用和发展。","type":"text/markdown","created":"20230626024628652","creator":"oeyoews","modified":"20230726045248406","modifier":"oeyoews"},{"title":"文档画中画","text":"https://glitch.com/edit/#!/document-picture-in-picture-api?path=style.css%3A34%3A0\r\n\r\nhttps://www.qireader.com.cn/tags/!readlater/entries/6r1QBnwLQ4pVLxpk\r\n\r\n```plain \r\nNotAllowedError: Failed to execute 'requestWindow' on 'DocumentPictureInPicture': Opening a PiP window requires https or file protocol\r\n```","type":"text/markdown","created":"20230702095611212","creator":"oeyoews","modified":"20230929145356192","modifier":"oeyoews"},{"title":"朗读者2","text":"## 序言一\r\n\r\n我愿意相信，在这一刻，我与他们共享着同一个幸福的身份，那就是文学的阅读者、人类心灵的倾听者。\r\n\r\n听说许多城市的“朗读亭”外都排起了长队，也有读者为了录制三分钟的视频，在亭外耐心等待了足足九个小时。\r\n\r\n当下的生活固然匆忙，很多时候，我们也的确面临着浮躁的问题；但即使出于种种原因，我们同自己内心相处的时间相对有限，人们依然会本能地渴望着纯粹、辽阔、有质量的精神生活。\r\n\r\n何为经典？答案可能有很多，但我想最直接的一条，就是它们拥有温暖而强劲的力量，能够长久不衰地体贴灵魂、拨动心弦，触碰到我们情感深处最柔软最深刻的部位。这种力量，并不会因时间流逝和年代更迭而减弱。\r\n\r\n一个人内心的声音在广大的人群中持久回响，这是世上最美好的事，这更是一份严肃庄重的责任。\r\n\r\n## 序言二\r\n\r\n《朗读者》选择的文本大多是经典之作。作者既有莎士比亚、塞万提斯、约翰·多恩、雨果、梭罗、裴多菲、罗曼·罗兰、泰戈尔、吉卜林、海明威等外国名家，也有李白、杜甫、刘禹锡、苏轼、老舍、冰心、巴金等中国文学大家。\r\n\r\n我认为人生最大的乐趣是发现美、创造美，这个乐趣是用之不尽、取之不竭的，而美的乐趣来自阅读，阅读这些名篇佳作。\r\n\r\n## 第一次\r\n\r\n这都是非常宝贵而难忘的第一次，因为它们意味着我们的成长。就像作家汪曾祺所说的：“人的第一次，往往需要勇气。”但是第一次也往往会有意想不到的收获，因为它是探索、是挑战、是机遇。所以说，如果你的人生能够拥有更多的第一次，也就意味着你的人生更丰富、更多彩！\r\n\r\n### 朗读者 王学圻\r\n\r\n王学圻从三十一岁开始演戏，与陈凯歌、张艺谋合作过《黄土地》《大阅兵》，由于是军人出身，不便出演“反派”，演过许多军衔不等却腔调雷同、步调一致的军人角色，一直不温不火。直到 2008 年出演《梅兰芳》里的“十三燕”，他才开始声名显赫，从此片约纷至，角色不拘一格。这一年，王学圻已经六十二岁。\r\n\r\n人们喜欢用“大器晚成”来形容王学圻，但对于王学圻本人来说，电影就像是他一辈子也无法走出的梦境。\r\n\r\n剪辑我也没学过，不懂，觉得就剪呗。剪来剪去，一遍一遍地都不行，不满意。后来一看，还真不是一天半天的事。资金的问题跟着又来了。于是，就精简剧组，精简到最精简，只有三个人：一个我，一个杨丽萍，还有一个剪辑员\r\n\r\n其实我平常看很多人获奖掉眼泪，我还说呢：“这装什么呢，得个奖还掉眼泪。”真轮到自己，还真是要掉眼泪的感觉，就是一种委屈，特别委屈。\r\n\r\n有些你认定能做的东西，要坚持。但是这个坚持不是盲目地坚持，要很清醒、理智地想到是哪儿的问题，我怎么能把这个问题解决了。坚持下去，就会达到自己预期的目的，对我来说，这可能是印象最深的。\r\n\r\n不过，细想起来，每个人的生活同样也是一个世界。即使最平凡的人，也得要为他那个世界的存在而战斗。从这个意义上说，在这些平凡的世界里，也没有一天是平静的。\r\n\r\n是的，劳筋损骨熬苦一天以后，孙少平也常常难以入眠，而且在静静的夜晚，一躺进黑暗中，他的思绪反而更活跃了。有时候他也想一些具体的事。但大多数情况下思想是漫无边际的，像没有河床的洪水在泛滥；又像五光十色的光环交叉重叠在一起——这些散乱的思绪一直要带进他的梦中。\r\n\r\n活路稍微一轻松，他突然渴望能看点什么书——算一算，他又很长时间没见书的面了。\r\n\r\n孙少平搬到没门窗的楼房后，才想起这里晚上没灯。他就在外出采购东西的时候，捎带着给自己买了一些蜡烛。\r\n\r\n周围一片寂静，人们都已经沉沉地入睡了。带着凉意的晚风从洞开的窗户中吹进来，摇曳着豆粒般的烛光。\r\n\r\n一个人，不管他多么平凡，只要他是为自己的生活意义而奋斗，那么他与国家民族的命运、与时代的巨大变革就都是息息相关的。\r\n\r\n### 朗读者 柯洁\r\n\r\n他也是在世界第一位置上停留时间最长的中国棋手。在他的世界里没有“第二名”这种说法，如果不是第一，就是失败。\r\n\r\n人类被自己创造的智能打败，不知道该值得骄傲还是该觉得沮丧\r\n\r\n很多事情有残缺才是有美的。失误才会引起战斗。\r\n\r\n有人说人生有六个字，前面三个字是“不害怕”，后面还有三个字，“不后悔”，努力去做吧！\r\n\r\n遇到强大的对手有时候也是一种幸运，强大的对手会重塑强大的自我。\r\n\r\n### 朗读者 许镜清\r\n\r\n在当时，这是超越时代的音乐手法，在电视配乐中开了民乐、电音与管弦乐相结合的先河。\r\n\r\n总有一些光亮，让人觉得可以向前迈出脚步。”\r\n\r\n因为人的一生总有痛苦的时候，总有找不到路的时候，总有看不到前路的时候，这时候有一丝光亮，你就觉得那是方向，就可以往那儿走。\r\n\r\n### 朗读者 刘震云\r\n\r\n而另一方面，崔永元曾向他提出疑问——涉足影视如何保持写作状态，他回应道，“一年 365 天，一个晚上在电影圈，一个晚上在电视圈，剩下的 363 天在书桌前，跟书里的人物在一起。”\r\n\r\n书跟电影是两个完全不同的动物。电影非常讲究节奏，像一头豹子，要跑得非常非常快；而小说是一头大象，可以边走边想。书最擅长的是心理描写，而这个心理描写对电影是完全没有用的。\r\n\r\n我觉得可能是有道理的。第二个道理说得稍微好一些，她说，真正的好电影是看不见导演的电影，是看不见摄影机、看不见演员的电影，看到的就是里边的人物和人物的情感。\r\n\r\n我特别喜欢跟两分钟之内能搞定事儿的人打交道。\r\n\r\n家里人嘛，有时候就得说说废话，不然怎么叫家里人呢？\r\n\r\n也不谈工作，是谈她做这个事情背后的道理，这一点只要沟通清楚就可以了。\r\n\r\n不管是考试的时候还是回家做作业的时候，不会的题就不要做了，因为做也做不对。但是你能不能把自己会的给它做对？你只要把会的做对，你得分一定就不低了。我们每一个人，从来都是在细节上犯错误。细节上犯的错误就是会的事没有做对。\r\n\r\n我觉得和谐、稳定最大的、决定性的因素是不啰嗦。\r\n\r\n同样一件事情，对自己有利没利他不管，看到对别人有利，他就觉得吃了亏。\r\n\r\n“我跟你说不清楚，躁人之辞多，吉人之辞寡。”\r\n\r\n一个人说正经话，说得不对可以劝他；一个人在胡言乱语，何劝之有？”\r\n\r\n### 朗读者 王珮瑜\r\n\r\n她的人生听上去顺利、完美，但了解她的人会知道，她是在机遇和拼搏当中，不断地完善、突破和超越着自己。\r\n\r\n当年种下的一个种子开始发芽了。\r\n\r\n你是给他们打开了一扇门，让他们起码能够看到有这样的世界的存在，然后有机会走进去，了解它的奥妙所在。\r\n\r\n不管遇到什么样的困难，永远不要丢了自己的目标，这个很重要。\r\n\r\n念奴娇·赤壁怀古\r\n〔宋〕苏轼\r\n大江东去，浪淘尽，千古风流人物。故垒西边，人道是，三国周郎赤壁。乱石穿空，惊涛拍岸，卷起千堆雪。江山如画，一时多少豪杰。遥想公瑾当年，小乔初嫁了，雄姿英发。羽扇纶巾，谈笑间，樯橹灰飞烟灭。故国神游，多情应笑我，早生华发。人间如梦，一尊还酹江月。\r\n\r\n### 朗读者 杨利伟\r\n\r\n无数人的很多次，造就了这个“第一次”。\r\n\r\n一刺眼，我眼睛就在眨；一眨眼，大厅里边不知谁喊了一声，“你看他还活着，他的眼睛在动！”\r\n\r\n很多老科学家，白发苍苍，都在流眼泪。包括我回来之后，到了航天中心，我们一些退休的老同志，拉着我的手，流着眼泪说：“我非常遗憾，干了几十年的航天，但是没有亲手把你送到太空去。”实际上是祖国和人民用智慧的双手，把我们航天员送到太空的。这么说一点都不为过。\r\n\r\n其实当一个人的第一次可以和国家、和民族，甚至和整个人类进步关联在一起的时候，那是怎样的一份自豪和荣耀啊！\r\n\r\n测控数据显示，飞船正确入轨，此时它的速度接近第一宇宙速度，是每秒 7.83 公里；轨道近地点为 200 公里，远地点是 400 公里。\r\n\r\n在太空的黑幕上，地球就像站在宇宙舞台中央那位最美的大明星，浑身散发出夺人心魄的、彩色的、明亮的光芒。她披着浅蓝色的纱裙和白色的飘带，如同天上的仙女缓缓飞行。\r\n\r\n为了人类的和平与进步，中国人来到太空了。\r\n\r\n从这样的维度审视我们的家园，思维方式会有所不同。随着身体的失重，许多东西似乎也会随之变轻、变淡，比如名和利。但另一些东西则会在心里变得更加清晰和珍贵，比如祖国和亲人。\r\n\r\n## 眼泪\r\n\r\n人的心灵应如浩淼瀚海，只有不断接纳象征希望、勇气、力量的百川，才可能风华长存。眼泪是无色的，但是它分明又有着最丰富的生命的色彩！\r\n\r\n### 朗读者 陆川\r\n\r\n因着内心的向往，我们会在命运的道路上最终遇到属于自己的电影。”\r\n\r\n我一定要把我在可可西里感受到的生命的脆弱，人的渺小，自然的那种博大和没有边际的感觉，带回北京跟观众分享；分享生命是什么，我们应该用什么样的姿态去尊重生命。\r\n\r\n他们内心是非常充盈、非常丰富的，但大多数情况他们只是沉默，就像石头一样。\r\n\r\n因为大家对于哭泣者没有同情，大家觉得你在哭，你就是很 LOW，但确实有人在真的哭泣。因为太多的人在虚假地哭泣，所以真正的哭泣被中和了，被变得毫无价值了。\r\n\r\n天下所有慈母的跪拜，包括动物在内，都是神圣的。\r\n\r\n### 朗读者 斯琴高娃\r\n\r\n斯琴高娃说，她喜欢把自己看成一块材料，任导演和角色去裁剪、揉捏、粉碎、重塑，无论代价如何，她甘之如饴。\r\n\r\n“有时候我觉得，并不是我塑造了她们，而是她们的人生际遇丰富了我的生命。我走过她们的人生，收获属于自己的感悟。与其说是我塑造了角色，不如说是角色‘度’了我，造就了现在的斯琴高娃。”\r\n\r\n我觉得掉眼泪它也好不了。\r\n\r\n人虽然去了，一个在地上，一个在地下，阴阳相隔，但是互相的那种牵挂是永生永世的。其实那是给他的一种力量，一种精神。\r\n\r\n《世界上最疼我的那个人去了》\r\n\r\n可能妈妈是这个世界上唯一一个我们可以毫无顾忌地、把最真实的自己还原在她面前的那个人，但是我们没有考虑到她的感受。\r\n\r\n### 朗读者 赖敏 丁一舟\r\n\r\n只要身边陪伴的那个人能让你笃定依靠，柴米油盐、一蔬一饭是幸福；风餐露宿、天长路远亦是幸福。\r\n\r\n如果一直在家里的话，面对的永远是四面墙，一个天花板。现在在外面的话，也许你每一天醒来的风景都是不一样的。\r\n\r\n你跟一个人过日子，你跟她过的是精神世界，又不是跟她的病过。你觉得这个人跟你精神上面能够契合到一起就可以了，其他的都不是很重要。\r\n\r\n“艺术靠征服而存在。”征服自然、征服自己，更重要的是，用爱征服时间。\r\n\r\n### 朗读者 张家敏\r\n\r\n当时我的感觉就是泪与水同流，淋浴的水把我的眼泪冲淡了，但我内心的泪还在流。\r\n\r\n我要让爱我的人、我爱的人，永远留住我的笑容。\r\n\r\n我每天早晨起床的时候，第一感觉就是自己醒来还活着呢，活蹦乱跳的，那赶紧起来吧，该干什么干什么去。\r\n\r\n活着的时候，你不要因碌碌无为而羞愧，不要因为不尊重生命虚度年华而悔恨。\r\n\r\n水里的游鱼是沉默的，陆地上的兽类是喧闹的，空中的飞鸟是歌唱着的。但是人类却兼有了海里的沉默，地上的喧闹，与空中的音乐。\r\n\r\n使生如夏花之绚烂，死如秋叶之静美。\r\n\r\n云把水倒在河的水杯里，它们自己却藏在远山之中。\r\n\r\n“我相信你的爱”，让这句话做我的最后的话。\r\n\r\n### 朗读者 张鲁新\r\n\r\n张鲁新曾经多次说，自己一生只做了一件事。\r\n\r\n我向你走来，捧着一颗真心；我向你走来，捧着一路的风尘。\r\n\r\n勇敢的人不是不落泪的人，而是愿意含着眼泪继续奔跑的人。\r\n\r\n人最宝贵的是生命。生命每个人只有一次。人的一生应当这样度过：当回忆往事的时候，他不会因为虚度年华而悔恨，也不会因为碌碌无为而羞愧；在临死的时候，他能够说：“我的整个生命和全部精力，都已经献给了世界上最壮丽的事业——为人类的解放而斗争。”\r\n\r\n青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志、恢宏的想象、炽热的感情；青春是生命的深泉在涌流。\r\n\r\n## 告别\r\n\r\n海子说：“我们最终都要远行，最终都要与稚嫩的自己告别。”\r\n告别是通向成长的苦行之路。\r\n\r\n### 朗读者 姚晨\r\n\r\n每天我们都是侧着睡的，基本她就占了三分之二，然后我一直像个蝙蝠似的扒在墙上睡了一个月。\r\n\r\n说实话，我记不清了。后来，你会发现生命中好多人，不知道在什么时候就默默地……\r\n\r\n我是希望我自己能记住她，包括土豆，将来长大了，看见这篇文字，也能够知道有这样的一个人曾经疼过他。\r\n\r\n我有时候觉得人活一辈子，跟这些人产生各种各样的关联，每一次相遇可能就像是一次告别。我觉得他们也没有图什么，他们就希望你好好的。\r\n\r\n### 朗读者 程何\r\n\r\n余光中先生曾经说过，“一个幸福的译者，他得与一个宏美的灵魂朝夕相对，按其脉搏，听其心跳，亲炙其阔论高谈，真正是一大特权。”\r\n\r\n我从不奢望活在梦中那么长，从不沉溺在每个绮丽幻想，早已习惯痛苦，不再害怕忧伤，不过是换个衣箱换间房，那又怎么样。\r\n\r\n因为这条路太不确定了，没有人走成功过\r\n\r\n夜里哭醒。想不到、看不到未来在哪里，因为这条路没有人走过，觉得前方是黑的。我在一步一个脚印地去拨开那些荆棘、杂草，然后往前走。\r\n\r\n对，去年确诊的。中重度抑郁。其实很多人都劝我放松点儿，很多人都劝我观众看不出那些细微的差别，但是我觉得观众席里说不定有一个人、两个人，他知道，他能感受到。\r\n\r\n我记得杨绛先生在翻译《堂吉诃德》的时候写过序言，她说堂吉诃德有不可动摇的信仰，他坚定地相信，除他自身之外，还有一种东西是永恒不变、普遍存在的。那是需要靠我们坚定地追求才能获取的。\r\n\r\n是我的脑袋变软了，还是我的脑浆流出来了，或者是我从脚冒到头上来的汗？如果是我的汗，那肯定不是吓出来的汗水。\r\n\r\n勇敢如果到了让人害怕的地步，那就算不上勇敢，而应该说是发疯了。\r\n\r\n听其言，侃侃而谈，头头是道；观其行，则荒谬透顶，冒失莽撞。\r\n\r\n我知道何谓勇敢，它是介于两种缺陷之间的一种美德，不过，宁可勇敢过头，近于鲁莽，也不要害怕到成为胆小鬼的地步；这就好像挥霍比吝啬更接近慷慨一样，鲁莽也比怯懦更接近真正的勇敢。\r\n\r\n### 朗读者 曹文轩\r\n\r\n“他的童年，虽然物质上贫穷，但情感和审美的丰富让他写出了第一部成功之作《草房子》。他那流畅、充满诗意的笔调，描写的是诚实的，有时是原始的，甚至忧郁的生命瞬间。”\r\n\r\n我父亲有一块珍藏了许多年的木材，我至今也不太明白，这块木材他留着是干什么用的。我当时只是觉得，他好像有一种预感，他的儿子有一天要上路，得有一只箱子，所以他就请木匠把他珍藏的木材给我做了一个非常非常漂亮的箱子\r\n\r\n其实让我更深切地理解了生死，理解了告别，理解了爱。\r\n\r\n这不是分别，是诀别，是分别里头一种最让人无法接受的告别。\r\n\r\n我常想，大自然就是在告别的过程中完成它的季节轮替的，人类也一样。其实，天空下不是山，也不是水，是什么？是满满的各种各样的告别。就像过一会儿，我又要向董卿说告别一样。我是一个作家，我知道，文学写了上百年、上千年，其实作的就是一篇文章——《生死离别》。\r\n\r\n“我一直将庄重的风气看成是文学应当具有的主流风气，一个国家、一个民族的文学应当对此有所把持。倘若不是，而是一味地玩闹，一味地逗乐，甚至公然拿庄重开涮，我认为这样的庄重格局是值得怀疑的。我们在流动不止的世俗生活中已经很少有庄重的体验，一切看上去都是可笑的，都是可以加以戏弄的。一个人可以成为痞子，而一个国家、一个民族也可以成为痞子国家和痞子民族吗？中国文学应该引领国民走向雅致，走向风度，走向修养和智慧。”\r\n\r\n桑桑终于睡熟。他醒来时，觉得被窝里就只有他一个人。他微微抬起头来，看见父亲正坐在窗口抽烟。天还未亮。黑暗中，烟蒂一亮一亮地照着父亲的面孔，那是一张愁苦忧郁的面孔。\r\n\r\n他隐隐地觉得，他给全家，甚至给所有认识他的人，都带来了紧张、恐慌与悲伤。他知道，事情是十分严重的。然而，在此刻他却就是无法伤心起来。\r\n\r\n### 朗读者 李立群\r\n\r\n其实人就是这样，她不知道那是永远的告别，所以她才会后悔，想起来的时候会特别地怀念。\r\n\r\n我们中国人讲的孝顺是什么意思？我个人的浅见，我觉得“孝”不是教育出来的，教育出来的都是假的，不是真正的乌鸦反哺；真正的乌鸦反哺，应该是你在你爸爸、妈妈对你的爱当中有所领悟。孝顺应该是一种对爱的领悟，然后你反馈回去。它是一个很自然的行动，它不需要教育。或者说教育不见得有多大的作用。\r\n\r\n告别无处不在。它让我们整个人生变得更丰富，也会让您的角色在舞台上变得更丰满。\r\n\r\n人生的矛盾可笑即在于此，年轻力壮，力求事事出轨，决不甘为火车；及至中年，心理的，生理的，种种理的什么什么，都使他不但非作火车不可，且作货车焉。把当初与现在一比较，判若两人，足够自己笑半天的！或有例外，实不多见。\r\n\r\n这个家庭顶好是在北平，其次是成都或青岛，至坏也得在苏州。无论怎样吧，反正必须在中国，因为中国是顶文明顶平安的国家；理想的家庭必在理想的国内也。\r\n\r\n### 朗读者 维和部队战士\r\n\r\n面对凶险，别人都在问“为什么是我？”他们却在问“为什么不是我？”\r\n\r\n“总有一些事需要一些人去做吧！去做这些事可能意味着与死神较量、与危险硬拼、与邪恶斗争，意味着种种不确定性的发生。但代表祖国出征，是无悔的青春选择。”一名战士这样说。\r\n\r\n母亲就说，你是妈妈的儿子，别人也是妈妈的儿子。你要安全地回来，也要把别人的儿子安全地带回来。\r\n\r\n还有一个事我觉得特别遗憾，爆炸的前一天，申亮亮找到我，他说：“中队长你给我理个发吧。”我说明天有勘查的任务，明天我给你理。这成了我一生的遗憾。（哭）\r\n\r\n对于世界，你是一名战士；但是对于我，你是整个世界。\r\n\r\n等着我吧——我会回来的。\r\n只是你要苦苦地等待，\r\n等到那愁煞人的阴雨\r\n勾起你的忧伤满怀，\r\n等到那大雪纷飞，\r\n等到那酷暑难挨，\r\n等到别人不再把亲人盼望，\r\n往昔的一切，一股脑儿抛开。\r\n等到那遥远的他乡\r\n不再有家书传来，\r\n等到一起等待的人\r\n心灰意懒——都已倦怠。\r\n\r\n《等着我吧》这首诗唱响了当时苏联的整个战争岁月，几乎没有一个战士不会背诵这首诗。当时每一个参战的男人和留守的女人相互激励的最好表达就是这首诗。就这首诗风靡的广度与深度，在世界诗歌史上大概堪称无双。这首诗将激昂的情怀与纤细的柔情不可思议地糅合在一起，思想内涵与艺术魅力素朴而又奇妙地结合为一体。\r\n\r\n### 朗读者 王蒙\r\n\r\n告别，一种是时间的告别，一种是空间的告别。\r\n\r\n只要是活着时候的告别，都意味着新的开始，新的地区，新的时间，新的岗位，新的平台，甚至是新的发展。\r\n\r\n我用俄语唱遥远，用英语唱情怀，用维吾尔语唱眼睛，用不言不语唱景仰墓园。\r\n\r\n“大块载我以形，劳我以生，佚我以老，息我以死”，什么意思呢？“大块”是指天地，您要想在天地间活着，您就得劳动，就得辛苦，最后，用衰老让您休息，用死让您安息。\r\n\r\n人生是值得珍贵的，告别的经验虽然有它的酸苦，但是也在丰富着我们的生活，也让我们活一天，好好地过一天”。\r\n\r\n所谓的红叶节已经从霜降开始。通往香山的高速公路你拥我挤，人们的普遍反应是人比叶多，看到的是密不透风的黑发头颅而不是绯红的圆叶。\r\n\r\n“暑盛知秋近，天空照眼明”\r\n\r\n冷酷是一种伟大的美。冷酷提炼了美的纯粹，美的墓碑是美的极致。冷酷有大美而不言。寂寞是最高阶的红火。走了就是走了，再不会回头与挥手，再不出声音，温柔的与庄严的。留恋已经进入全不留恋，担忧已经变成决绝了断。辞世就是不再停留，也就是仍然留下了一切美好。存在就是永垂而去。记住了一分钟就等于会有下一分钟。永恒的别离也就是永远的纪念与生动。出现就是永远\r\n\r\n它们的发达的正规树叶凋落了，新芽点染着少许的褐与红，仍然不合时宜地生发着萌动着，在越来越深重的秋季里做着早春的梦，哪怕它们很快就会停止在西风与雨夹雪里。\r\n\r\n你的呼唤使我低下头来。就这样等待着须发变白。”\r\n\r\n你如玉如兰，如雪如脂，如肖邦如舒曼，如白云如梨花瓣。\r\n\r\n我的一生就是靠对你的诉说而生活。\r\n\r\n生活就是这样，买米、淘米、洗菜、切菜，然后是各种无事生非与大言欺世。然后是永远的盎然与多情的人生，是对于愚蠢与装腔作势的忘记，是人的艰难一把把。然后是你最喜欢的我行我素与心头自有。\r\n\r\n时间，什么是时间，时间是什么？烟一样地飘散了。波纹一样地衰减、纤弱、安静、平息下来，不再有声响了。经过了哭号，经过了饮泣，经过了迎风伫立，经过了深深垂下的眼帘，忘却一样地失去了喜与悲、长与短、生与殁、有与无的区分了。时间仍然可能动人，时间仍然可能欢跃，时间仍然可能痛哭失声，痛定不再思痛。痛变为平静，平静不会轻易再变成痛，平静是痛与不痛的痊愈的伤口。\r\n\r\n你和我一起，走到哪里，你的床我的床边，你的枕我的枕旁，你的声音我的耳际，你的温良我的一切方向。\r\n\r\n已经许多年，我没有在深夜起床赏月，那时还在山村，深夜的清晖给了我们另一个世界，就像丁香花与紫罗兰给了我们另一种花事。\r\n\r\n我的初恋是你。我的少年是你。我的颠沛流离是你。我的金婚是你。我的未有实现的钻石婚是你。\r\n\r\n忠厚传家久，诗书继世长\r\n\r\n又是一年芳草绿，依然十里杏花红。\r\n\r\n有许多次我被离别。我不喜欢离别，离别的唯一价值是怀念聚首与期待下次重逢的欢喜。离别的美好是看到月亮以为你也在看月亮，同一个月亮。\r\n\r\n## 勇气\r\n\r\n勇气有时候是一瞬间的闪念，有时候是一辈子的执念。勇气是在你看清了生活的真相之后，依然热爱生活。\r\n\r\n### 朗读者 江一燕\r\n\r\n我们可能走得很慢，但是一步一个脚印地往前走，奋力爬”。\r\n\r\n“我做的事情、走的路，都是一点一滴、慢慢的、小小的，但它是可以深入人心的。”\r\n\r\n我告诉自己，不要流泪。我不能让他们伤感，我要让他们感觉到希望，感觉到勇气。\r\n\r\n其实有的时候老师可能只是一点点的关怀，一点点的爱，就会影响到我们整个生命，改变我们的人生信仰。\r\n\r\n实际上轮到我考上初中时已不再是考中秀才般的荣耀和喜庆，反而变成了一团浓厚的愁云忧雾笼罩在家室屋院的上空。\r\n\r\n这种眼神足以使任何被痛苦折磨着的心平静下来，足以使任何被痛苦折磨得心力交瘁的灵魂得到抚慰，足以使人沉静地忍受痛苦和劫难而不至于沉沦。\r\n\r\n我抬头看她，猛然看见那双眼睫毛很长的眼眶里溢出泪水来，像雨雾中正在涨溢的湖水，泪珠在眼里打着旋儿，晶莹透亮。我瞬即垂下头避开目光。要是再在她的眼睛里多驻留一秒，我肯定就会号啕大哭。我低着头咬着嘴唇，脚下盲目地拨弄着一颗碎瓦片来抑制情绪，感觉到有一股热辣辣的酸流从鼻腔倒灌进喉咙里去。我后来的整个生命历程中发生过多少这种酸水倒流的事，而倒流的渠道却是从十四岁刚来到的这个生命年轮上第一次疏通的。第一次疏通的倒流的酸水的渠道肯定狭窄，承受不下那么多的酸水，因而还是有一小股从眼睛里冒出来，模糊了双眼，顺手就用袖头揩掉了。我终于仰起头鼓起劲儿说：“老师……我走咧……”\r\n\r\n当各种欲望膨胀成一股强大的浊流冲击所有大门、窗户和每一个心扉的当今，我便企望自己如女老师那种泪珠的泪泉不致堵塞更不敢枯竭，那是滋养生命灵魂的泉源，也是滋润民族精神的泉源哦……\r\n\r\n### 朗读者 汪明荃 罗家英\r\n\r\n所以不能跟女人吵架，吵不赢的；也不能跟她讲理的，她们都是歪理。（全场笑）\r\n\r\n我觉得人生是不断地学习，一段婚姻也是去学习。\r\n\r\n老夫老妻冯骥才“为我们唱一支暮年的歌儿吧！”\r\n\r\n他俩仿佛两杯水倒在一起，怎么也分不开。吵架就像在这水面上划道儿，无论划得多深，转眼连条痕迹也不会留下。\r\n\r\n这句话头几次曾把对方的火气压下去，后来由于总不兑现便失效了；但她还是这么喊，不知是一时为了表示自己盛怒已极，还是迷信这句话最具有威胁性。六十岁以后她就不知不觉地不再喊这句话了。今天又喊出来，可见她已到了怒不可遏的地步。\r\n\r\n是不是一生中经历的事太多了，积累起来就过于沉重，把这桩事压在底下拿不出来了？但为什么今天它却一下子又跑到眼前，分外新鲜而又有力地来撞她的心……\r\n\r\n年轻人和老年人总是有距离的。年轻人应该和年轻人在一起玩，老人得有老人为伴。\r\n\r\n### 朗读者 秋爸爸 秋妈妈\r\n\r\n我们觉得害怕，怕他可能这一辈子，都不知道我们很爱他。\r\n\r\n我觉得是来自于爱，还有一种为人父母的使命感。我唯一的希望就是宝宝、贝贝能够在这个世界上有尊严地活着。这一辈子我都想做他们的守护神。我的愿望就是比他们多活一天。因为这样，我才能够多照顾他们一天。\r\n\r\n光哭，或者抱怨，或者躲，这些都没有用，我们只能迎上去，面对现实\r\n\r\n我一般进去这么劝：苦不苦，看看秋爸，他们家两份堵；累不累，看看秋爸，他们家两份罪。这样一说，基本上能够让家长平息一下自己。\r\n\r\n其实把今天过好了，就是一种勇气。今天，明天，未来的一天又一天，坚持下来就是一种勇气。\r\n\r\n你不是我的希望，不是的\r\n你是你自己的希望\r\n我那些没能实现的梦想还是我的\r\n与你无关，就让它们与你无关吧\r\n你何妨做一个全新的梦\r\n那梦里，不必有我\r\n我是一件正在老去的事物\r\n却仍不准备献给你我的一生\r\n这是我的固执\r\n然而我爱你，我的孩子\r\n我爱你，仅此而已\r\n\r\n### 朗读者 李宁\r\n\r\n即便在最艰难的时刻，也永远不要低估一颗冠军的心。\r\n\r\n作为运动员，个人的挑战会大一点，成功也是你，失败也是你。企业毕竟还是一个更广泛的事情，有资本的层面，有管理团队的层面，有技术层面，有产品层面，有市场渠道，竞争环境等等。企业的勇气在于，拥有决策权的人，他是否能平衡好，最终决定往哪走。有时候可能需要放弃一些既得的，去追求一些看似很有价值，但是未必会实现的\r\n\r\n有信心，就会有勇气，因为有梦想，就会有冲动。\r\n\r\n“做一个战士”！战士要有一个坚定的目标，不会被假象所迷惑。\r\n\r\n我如果是一盏灯，这灯的用处便是照彻那多量的黑暗。我如果是海潮，便要鼓起波涛去洗涤海边一切陈腐的积物。\r\n\r\n### 朗读者 翟墨\r\n\r\n航海家哥伦布曾经说过∶“除非你有勇气到达那些看不到岸的地方，否则你就永远无法跨越大洋。”\r\n\r\n“一个人，一条船，他航行于世界。或许他不想去证明什么宏大的词汇，只是想证明一个人可以走多远。”白岩松这样评价翟墨。\r\n\r\n国际上有一个规定，穿越地球所有的经线，就是环球航海。\r\n\r\n狂风肆虐的时候，我还在那儿缝那个帆，也给自己缝脚。\r\n\r\n不断地去挑战自己，不断地去战胜自己。\r\n\r\n对，叫追云洗澡。有时候我追过去的时候，正好云层聚积得更多，而且走得很慢，然后就可以尽快地打上肥皂以后，尽快地洗了。这是我们航海之后最大的乐趣之一。\r\n\r\n勇气是我启航的一种力量。\r\n\r\n在苍茫的大海上，狂风卷集着乌云。在乌云和大海之间，海燕像黑色的闪电，在高傲地飞翔。\r\n\r\n### 朗读者 樊锦诗\r\n\r\n历史是文字的资料，考古就是实物的资料。越是到古代，在没有文字的时候，越是要靠着考古的实物资料来证明的。考古是研究历史不可或缺的实物资料。\r\n\r\n他说：相恋在未名湖，相爱在珞珈山，相守在莫高窟。\r\n\r\n我虽局处于斗室之中，却神驰于万里之外；虽局限于眼前的时刻之内，却恍若回到千年之前。\r\n\r\n翩若惊鸿，宛如游龙；荣曜秋菊，华茂春松”\r\n\r\n人类长存的真理，便是永远不放弃交流，并在这不中断的交流中，相互理解，相互给予，相互美好地促动。","type":"text/markdown","created":"20230614013246205","creator":"oeyoews","modified":"20230929060441633","modifier":"oeyoews","page-cover":"https://img2.doubanio.com/view/subject/m/public/s29511083.jpg","tags":"books"},{"title":"权限问题","text":"```warning\r\nldconfig: /usr/lib/$NAME is empty, not checked.\r\n```\r\n\r\n```bash\r\npacman -Qkk | grep warning\r\n```\r\n\r\n> ps: directly delete theme","type":"text/markdown","created":"20231001112335149","creator":"oeyoews","modified":"20231001113259071","modifier":"oeyoews","tags":"pacman"},{"title":"模型崩溃","text":"Stable Diffusion 与 GPT-3(.5) 和 GPT-4 等 AI 模型正在改变网络生态。如果人类消费的大部分内容是 AI 生成的，那么 AI 又如何继续改进其模型呢？如果 AI 用 AI 生成的数据进行训练又会发生什么？牛津、剑桥、伦敦帝国学院等机构的研究人员在预印本平台 arXiv 上发表论文，对此展开了分析。研究人员发现，这会导致 AI 模型存在不可逆转的缺陷，他们将其称之为 __模型崩溃__（Model Collapse）。这意味着未来模型训练使用的高质量数据将会愈来愈昂贵，将可能导致网络的碎片化和封闭化，内容创作者将会竭尽全力防止其内容被免费抓取。社交媒体公司也逐渐认识到其数据的价值，对 API 访问收取昂贵费用。如果未来的模型使用容易获取的数据（很可能是其它模型生成）训练，那么这将会加速模型的崩溃，增加对模型进行中毒攻击的可能性。","type":"text/markdown","created":"20230626054239838","creator":"oeyoews","modified":"20230726045248360","modifier":"oeyoews"},{"title":"每天一个蓝屏小技巧","text":":::bug\n* 由于下列错误，Lenovo Windows Security Center 服务启动失败:  Windows 无法验证此文件的数字签名。某软件或硬件最近有所更改，可能安装了签名错误或损毁的文件，或者安装的文件可能是来路不明的恶意软件。 https://blog.csdn.net/chenhao0568/article/details/109451115 (没用)\nhttps://h30471.www3.hp.com/t5/you-xi-ben/bios-li-an-quan-qi-dong-mo-shi-mo-ren-guan-bi-qie-shi-hui-se-de-wu-fa-da-kai/td-p/1212239\n* 由于在创建转储期间出错，创建转储文件失败。(__蓝屏关键原因__)\n* 上一次系统的 12:27:11 在 ‎2023/‎10/‎13 上的关闭是意外的。\n:::\n\nhttps://answers.microsoft.com/zh-hans/windows/forum/all/windows-10/d73f7801-9ad5-4edb-94a0-5951c7fad8df","type":"text/markdown","created":"20231013044633373","creator":"Lenovo","modified":"20231015000920434","modifier":"Lenovo","tags":""},{"title":"水合作用","text":"React 是一个 JavaScript 库，用于构建用户界面。在 React 中，水合作用是指在服务器端渲染时，React 在将 HTML 发送到客户端之前，将组件的初始数据和事件处理程序注入到 HTML 中。这样，当客户端加载 HTML 时，React 就可以快速重建组件的状态，从而提高应用程序的性能和响应速度。这种注入初始数据和事件处理程序的过程就被称为水合作用。","type":"text/markdown","created":"20230606111405803","creator":"oeyoews","modified":"20230726045248406","modifier":"oeyoews"},{"title":"水合错误","text":"https://juejin.cn/post/7205114671840428090\r\n\r\nhttps://nextjs.org/docs/messages","type":"text/markdown","tags":"React"},{"title":"活着","text":"> 永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功，苦难不值得追求，磨练意志是因为苦难无法躲开\r\n\r\n## 中文版自序\r\n\r\n人是为活着本身而活着的，而不是为了活着之外的任何事物所活着。\r\n\r\n## 韩文版自序\r\n\r\n“活着”在我们中国的语言里充满了力量，它的力量不是来自于喊叫，也不是来自于进攻，而是忍受，去忍受生命赋予我们的责任，去忍受现实给予我们的幸福和苦难、无聊和平庸。\r\n\r\n## 日文版自序\r\n\r\n对《活着》而言，生活是一个人对自己经历的感受，而幸存往往是旁观者对别人经历的看法。\r\n\r\n：去年今日此\r\n\r\n## 英文版自序\r\n\r\n人的体验和欲望还有想象和理解，会取消所有不同的界限，会让一个人从他人的经历里感受到自己的命运，就像是在不同的镜子里看到的都是自己的形象。\r\n\r\n## 麦田新版自序\r\n\r\n我能写下些什么呢？往事如烟，可我记忆犹新。\r\n\r\n往事如烟，可我记忆犹新。\r\n\r\n回顾过去，我感觉自己长时期生活在现实和虚构的交界处，作家的生活可能就是如此，在现实和虚构之间来来去去，有时候现实会被虚构，有时候虚构突然成为了现实。\r\n\r\n生活是属于每个人自己的感受，不属于任何别人的看法。\r\n\r\n## 活着\r\n\r\n当我望着到处都充满绿色的土地时，我就会进一步明白庄稼为何长得如此旺盛。\r\n\r\n“我怕它知道只有自己在耕田，就多叫出几个名字去骗它，它听到还有别的牛也在耕田，就不会不高兴，耕田也就起劲啦。”\r\n\r\n有钱人嫁给有钱人，就是把钱堆起来，钱在钱上面哗哗地流，这样的声音我有四十年没有听到了。\r\n\r\n这人哪，一旦嫖上以后，也就免不了要去赌。这个嫖和赌，就像是胳膊和肩膀连在一起，怎么都分不开。\r\n\r\n“爹，你他娘的算了吧。老子看在你把我弄出来的分上让让你，你他娘的就算了吧。”\r\n\r\n最风光的那次是小日本投降后，国军准备进城收复失地。\r\n\r\n“夜里压我，白天骑我，黑心肠的，你是逼我往死里跑。”\r\n\r\n家珍是个好女人，我这辈子能娶上这么一个贤惠的女人，是我前世做狗吠叫了一辈子换来的。家珍对我从来都是逆来顺受，我在外面胡闹，她只是在心里打鼓，从不说我什么，和我娘一样。\r\n\r\n家珍是个好女人，我这辈子能娶上这么一个贤惠的女人，是我前世做狗吠叫了一辈子换来的。\r\n\r\n一直到解放以后，我才知道赌博的赢家都是做了手脚的，难怪我老输不赢，他们是挖了个坑让我往里面跳。\r\n\r\n“赌博全靠一双眼睛一双手，眼睛要练成爪子一样，手要练成泥鳅那样滑。”\r\n\r\n龙二说话时南腔北调，光听他的口音，就知道这人不简单，是闯荡过很多地方、见过大世面的人。\r\n\r\n龙二的黑桃 A 和沈先生的都是从袖管里换出来的，一副牌不能有两张黑桃 A，龙二抢了先，沈先生心里明白也只能认输。\r\n\r\n龙二是赌注小常输，赌注大就没见他输过了。我在青楼常和龙二他们赌，有输有赢，所以我总觉得自己没怎么输，其实我赢的都是小钱，输掉的倒是大钱，我还蒙在鼓里，以为自己马上就要光耀祖宗了。\r\n\r\n人都是一样的，手伸进别人口袋里掏钱时那个眉开眼笑，轮到自己给钱了一个个都跟哭丧一样。\r\n\r\n“摸过女人屁股就是手气不好。”\r\n\r\n家珍被拖出去时，双手紧紧捂着凸起的肚子，那里面有我的儿子啊，家珍没喊没叫，被拖到了大街上，那两个人扔开她后，她就扶着墙壁站起来，那时候天完全黑了，她一个人慢慢往回走。后来我问她，她那时是不是恨死我了，她摇摇头说：“没有。”\r\n\r\n脑袋里空空荡荡，像是被捅过的马蜂窝。\r\n\r\n我一动不动地看着她，凤霞就过来拉我的手，拉不动我她就哭了。看着凤霞哭，我心里就跟刀割一样。凤霞这么小的年纪就知道护着她爹，就是看着这孩子，我也该千刀万剐。\r\n\r\n听完他的话，我眼睛里酸溜溜的，我知道他不会和我拼命了，可他说的话就像是一把钝刀子在割我的脖子，脑袋掉不下来，倒是疼得死去活来。\r\n\r\n想想自己才挑了一天的钱就累得人都要散架了，祖辈挣下这些钱不知要累死多少人。到这时我才知道爹为什么不要银元偏要铜钱，他就是要我知道这个道理，要我知道钱来得千难万难。\r\n\r\n“人只要活得高兴，穷也不怕。”\r\n\r\n他们时常流出混浊的眼泪，这倒不是因为他们时常悲伤，他们在高兴时甚至是在什么事都没有的平静时刻，也会泪流而出，然后举起和乡间泥路一样粗糙的手指，擦去眼泪，如同掸去身上的稻草。\r\n\r\n家里值钱的东西都变卖光了以后，我娘就常常领着凤霞去挖野菜，我娘挎着篮子小脚一扭一扭地走去，她走得还没有凤霞快。她头发都白了，却要学着去干从没干过的体力活。看着我娘拉着凤霞看一步走一步，那小心的样子让我眼泪都快掉出来了。\r\n\r\n镶着两颗大金牙的嘴总是咧开笑着，有时骂看着不顺眼的佃户时也咧着嘴，我起先还以为他对人亲热，慢慢地就知道他是要别人都看到他的金牙。\r\n\r\n“按理说我也该借几个钱给你，俗话说是救急不救穷，我啊，只能救你的急，不会救你的穷。”\r\n\r\n人要是累得整天没力气，就不会去乱想了。\r\n\r\n那件绸衣我往身上一穿就赶紧脱了下来，那个难受啊，滑溜溜的像是穿上了鼻涕做的衣服。\r\n\r\n### 1\r\n\r\n长根那天走后，还来过一次，那次他给凤霞带来一根扎头发的红绸，是他捡来的，洗干净后放在胸口专门来送给凤霞。长根那次走后，我就再没有见到他了。\r\n\r\n家珍穿着水红的旗袍，手挽一个蓝底白花的包裹，漂漂亮亮地回来了。路两旁的油菜花开得金黄金黄，蜜蜂嗡嗡叫着飞来飞去。\r\n\r\n只要人活得高兴，就不怕穷。\r\n\r\n我最怕见到的还是我丈人，我不敢从米行那条街走，宁愿多绕一些路。\r\n\r\n弟兄们像牲畜一样扑上去乱抢，叠得一层又一层，跟我娘纳出的鞋底一样，他们嗷嗷乱叫着和野狼没什么两样。\r\n\r\n我们三个人边煮着米饭，边看着那些光脚在冬天里一走一跳的人，嘿嘿笑个不停。\r\n\r\n隔上不多时间，就过来一长串担架，抬担架的都猫着腰，跑到我们近前找一块空地，喊一、二、三，喊到三时将担架一翻，倒垃圾似的将伤号扔到地上就不管了。伤号疼得嗷嗷乱叫，哭天喊地的叫声是一长串一长串响过来。\r\n\r\n天一黑，又下起了雪。有一长段时间没有枪炮声，我们就听着躺在坑道外面几千没死的伤号呜呜的声音，像是在哭，又像是在笑，那是疼得受不了的声音，我这辈子就再没听到过这么怕人的声音了。一大片一大片，就像潮水从我们身上涌过去。\r\n\r\n“老子大小也打过几十次仗了，每次我都对自己说：老子死也要活着。子弹从我身上什么地方都擦过，就是没伤着我。春生，只要想着自己不死，就死不了。”\r\n\r\n我算计着自己活不到中午，到不了中午就该轮到我去死了。一个来月在枪炮里混下来后，我倒不怎么怕死，只是觉得自己这么死得不明不白实在是冤，我娘和家珍都不知道我死在何处。\r\n\r\n“你别走开，我找着了大饼就回来。”\r\n\r\n可他没有开枪，对我叫嚷着什么，我一听是要我爬出去，我心里一下子咚咚乱跳了，我又有活的盼头了。\r\n\r\n我们自动排出了二十多个队形，一个挨着一个每人领了两个馒头，我从没听到过这么一大片吃东西的声音，比几百头猪吃东西时还响。\r\n\r\n解放军让我回家，还给了盘缠。我一路急匆匆往南走，饿了就用解放军给的盘缠买个烧饼吃下去，困了就找个平整一点的地方睡一觉。我太想家了，一想到今生今世还能和我娘和家珍和我一双儿女团聚，我又是哭又是笑，疯疯癫癫地往南跑。\r\n\r\n“这下可要好好活了。”\r\n\r\n“家珍他们早在干活啦，你也歇够了。我知道你没吃饱，谁让你在水里待这么久？”\r\n\r\n“牛老了也和人老了一样，饿了还得先歇一下，才吃得下去东西。”\r\n\r\n老牛的肚皮耷拉下来，长长一条，它耕地时肚皮犹如一只大水袋一样摇来晃去。我注意到福贵耷拉下去的裤裆，他的裤裆也在晃动，很像牛的肚皮。\r\n\r\n家珍听了点着头，眼泪却下来了。做娘的心肠总是要软一些。我劝家珍想开点，凤霞命苦，这辈子看来是要苦到底了。有庆可不能苦一辈子，要让他念书，念书才会有个出息的日子。总不能让两个孩子都被苦捆住，总得有一个日后过得好一些。\r\n\r\n这当儿我看到凤霞站在田埂上，身旁一个五十来岁的男人拉着她的手。凤霞的眼泪在脸上哗哗地流，她哭得身体一抖一抖，凤霞哭起来一点声音也没有，她时不时抬起胳膊擦眼睛，我知道她这样做是为了看清楚她爹。\r\n\r\n家珍就告诉他，我们把凤霞送给别人家了，为了省下些钱供他上学。听到把凤霞送给了别人，有庆嘴一张哇哇地哭了，边哭边喊：\r\n“我不上学，我要姐姐。”\r\n\r\n有庆也没有错，他是凤霞带大的，他对姐姐亲，想姐姐。\r\n\r\n这孩子是逼我使劲揍他，真把我气坏了。我就使劲往他屁股上揍，这下他受不了了，哇哇地哭，我也不管，还是使劲揍。有庆总还小，过了一会，他实在疼得挺不住，求我了：\r\n“爹，别打了，我上学。”\r\n\r\n“就是全家都饿死，也不送凤霞回去。”\r\n家珍轻轻地笑了，笑着笑着眼泪掉了出来。\r\n\r\n原先我只觉得自己是个败家子，想不到我们队长也是个败家子。我啊，就站在不到百步远的地方，看着队长他们把好端端的油倒在茅草上，那油可都是从我们嘴里挖出来的，被他们一把火烧没了。那茅草浇上了我们吃的油\r\n\r\n队长是个喜欢听道理的人，不管谁说什么，他只要听着有理就相信。\r\n\r\n说完我出门就往村里羊棚去，心想这孩子太不懂事了，不帮着家珍干些家里的活，整天就知道割羊草，胳膊一个劲地往外拐。\r\n\r\n“他们不会宰我的羊了。”我说：“宰了才好。”\r\n\r\n我睡着以后，家珍一直没睡，不停地往火上加树枝，后来桶里的水快煮干了，她就拿着木桶去池塘打水，她身上没力气，拿着个空桶都累，别说是满满一桶水了，她提起来才走了五六步就倒在地上，她坐在地上歇了一会，又去打了一桶水，这回她走一步歇一下，可刚刚走上池塘人又滑倒了，前后两桶水全泼在她身上，她坐在地上没力气起来了，一直等到我被那声巨响吓醒。\r\n\r\n自己往我家从前的宅院，后来是龙二、现在是队长的屋子跑去，跑到队长屋前\r\n\r\n家珍反倒有些高兴，她在凤霞背上说：\r\n“治不了才好，哪有钱治病。”\r\n\r\n“这钢铁能造三颗炮弹，全部打到台湾去，一颗打在蒋介石床上，一颗打在蒋介石吃饭的桌上，一颗打在蒋介石家的羊棚里。”\r\n\r\n当初砸锅凭队长一句话，买锅了也是凭队长一句话。食堂把剩下的粮食按人头分到各家，我家分到的只够吃三天。好在田里的稻子再过一个月就收起来了，怎么熬也能熬过这一个月。\r\n\r\n他抬头看了我一眼，又说：“这些字够我用一辈子了。”\r\n\r\n### 2\r\n\r\n这天我进城卖柴，卖完了我花五分钱给有庆买了五颗糖，这是我这个做爹的第一次给儿子买东西，我觉得该疼爱疼爱有庆了。\r\n\r\n后来的一个多月里，有庆死活不理我，我让他干什么他马上干什么，就是不和我说话。这孩子也不做错事，让我发脾气都找不到地方。\r\n\r\n“有庆，你也慢慢长大了，爹以后不会再揍你了，就是揍你也不会让别人看到。”\r\n\r\n我亲眼看着自己的儿子，光着脚丫，鞋子拿在手里，满脸通红第一个跑完了十圈。这孩子跑完以后，反倒不呼哧呼哧喘气了，像是一点事情都没有，抬起一只脚在裤子上擦擦，穿上布鞋后又抬起另一只脚。\r\n\r\n我说了他一句：“他倒是像你爹。”\r\n\r\n“你给我、给你娘你姐姐争了口气，我很高兴。可我从没听说过跑步也能挣饭吃，送你去学校，是要你好好念书，不是让你去学跑步，跑步还用学？鸡都会跑！”\r\n\r\n嘴上说说的事让人不敢全信，不信又不敢，要不这日子过下去谁也没信心了。\r\n\r\n“把它卖掉总比宰掉它好。羊啊，是牲畜，生来就是这个命。”\r\n\r\n我路过一家小店时，掏出两分钱给有庆买了两颗硬糖，我想有庆辛辛苦苦了一年，也该给他甜甜嘴。\r\n\r\n我是一点办法都没有。女人啊，性子上来了什么事都干，什么话都说。我不让她干活，她就觉得是在嫌弃她。\r\n\r\n“有庆，你就去喝几口水填填肚子吧。”\r\n有庆也只能到池塘边去咕咚咕咚地喝一肚子水来充饥了。\r\n\r\n人一饿就什么缺德事都干得出来，明明是凤霞挖到一个地瓜，王四欺负凤霞不会说话，趁凤霞用衣角擦上面的泥时，一把抢了过去\r\n\r\n那声音响得就跟人跳进池塘似的，一巴掌全打在我心上。\r\n\r\n队长说：“这还不容易。”又是咔嚓一声将大的切下来一块，放进自己口袋，算是他的了。他拿起剩下的两块地瓜给我和王四，说：“差不多大小了吧？”\r\n\r\n我们一家四口人坐在桌前，喝起了热腾腾的米粥。这辈子我再没像那次吃得那么香了，那味道让我想起来就要流口水。\r\n\r\n我死后不要用麻袋包我，麻袋上都是死结，我到了阴间解不开，拿一块干净的布就行了，埋掉前替我洗洗身子。”\r\n\r\n我的话对家珍还是有用的，第二天早晨我醒来时，看到家珍正在看我，她轻声说：“福贵，我不想死，我想每天都能看到你们。”\r\n\r\n医生点点头，表示知道了，可他又说：\r\n“你为什么只生一个儿子？”\r\n这叫我怎么回答呢？我急了，问他：\r\n“我儿子还活着吗？”\r\n他摇摇头说：“死了。”\r\n\r\n“春生，你欠了我一条命，你下辈子再还给我吧。”\r\n\r\n### 3\r\n\r\n我看着那条弯曲着通向城里的小路，听不到我儿子赤脚跑来的声音，月光照在路上，像是撒满了盐。\r\n\r\n月光照在路上，像是撒满了盐。\r\n\r\n他们的兴奋是他们处在局外人的位置上。\r\n\r\n“做人不能忘记四条，话不要说错，床不要睡错，门槛不要踏错，口袋不要摸错。”\r\n\r\n我请他继续讲述自己，他有些感激地看着我，仿佛是我正在为他做些什么，他因为自己的身世受到别人重视，显示出了喜悦之情。\r\n\r\n家珍身上一点肉都没有了，扶着她就跟扶着一捆柴火似的。\r\n\r\n这个家一下子没了两个人，往后的日子过起来可就难了，等于是一口锅砸掉了一半，锅不是锅，家不成家。\r\n\r\n做医生的只要一句话，就能要我的命。\r\n\r\n那天晚上家珍和凤霞睡着以后，我一个人在屋外坐到天快亮的时候，先是呜呜地哭，哭了一阵我就开始想从前的事，想着想着又掉出了眼泪，这日子过得真是快，家珍嫁给我以后一天好日子都没过上，眼睛一眨就到了她要去的时候了。\r\n\r\n大伙都穷，借来的钱不够打棺材，后来队长给我凑了些村里的公款，才到邻村将木匠请来。\r\n\r\n我女人那晚上把我看了又看，叫了好几声： \r\n    “福贵。” \r\n\r\n\r\n人只要想吃东西，那就没事了。\r\n\r\n女人都是一个心眼，她认准的事谁也不能让她变。\r\n\r\n我们这辈子也算经历了不少事，人也该熟了，就跟梨那样熟透了该从树上掉下来。\r\n\r\n女人到了出嫁的时候，是什么都看着舒服，什么都听着高兴。\r\n\r\n说完这话自己先心疼上了，凤霞哪点比不上别人，就是不会说话。\r\n\r\n“条件这么好，会要凤霞吗？”\r\n我说：“那男的是偏头。”\r\n家珍这才有些放心。\r\n\r\n二喜见了我，说道：“屋顶的茅草该换了，我拉了车石灰粉粉墙。”\r\n\r\n“我女人我来背，你往后背凤霞吧。”\r\n\r\n看到二喜和凤霞像是两口子，一个烧火，一个做饭炒菜。两个你看看我，我看看你，看过后都咧着嘴笑了。\r\n\r\n“二喜，不是我想让你破费，实在是凤霞命苦，你娶凤霞那天多叫些人来，热闹热闹，也好叫村里人看看。”\r\n\r\n这样大手大脚把我都看呆了，心想扔掉的都是钱啊。\r\n\r\n她一看到我们，眼泪哗哗流了出来，她扭着身体哭着看我们。我一下子想起凤霞十三岁那年，被人领走时也是这么哭着看我，我一伤心眼泪也出来了，这时我脖子也湿了，我知道家珍也在哭。\r\n\r\n往常凤霞在屋里进进出出也不怎么觉得，如今凤霞一走，屋里就剩我和家珍，两个人看来看去，都看了几十年了，像是还没看够。\r\n\r\n“他们不会笑话我们吧？”我说：“我背着自己的女人有什么好笑话的。”\r\n\r\n我跑到村口一看，还真是二喜，翘着左边的肩膀，手里提着一包糕点，凤霞走在他旁边，两个人手拉着手，笑眯眯地走来。村里人见了都笑，那年月可是见不到男女手拉着手的，\r\n\r\n我往城里跑得这么勤快，跟年轻时一样了，只是去的地方不一样。\r\n\r\n家珍说：“话可不能这么说，人老了也是人，是人就得干净一些。”\r\n\r\n“城里人就是好，在村里是难得听到说我凤霞好。”\r\n\r\n二喜听后笑笑，没作声。二喜是实在人，娶凤霞时他依了我的话，钱花多了，欠下了债。到了私下里，他悄悄对我说：\r\n“爹，我还了债就给凤霞买毛线。”\r\n\r\n凤霞他们的枕巾上印着：千万不要忘记阶级斗争；床单上的字是：在大风大浪中前进。二喜和凤霞每天都睡在毛主席的话上面。\r\n\r\n一个人命再大，要是自己想死，那就怎么也活不了。\r\n\r\n可是想想嫁出去的女儿就是泼出去的水，凤霞早就是二喜的人了，不能在家里待得太久。\r\n\r\n“我也想不到，先前最怕的就是我和家珍死了凤霞怎么办，你娶了凤霞，我们心就定了，有了孩子更好了，凤霞以后死了也有人收作。”\r\n\r\n到了夏天，屋里蚊子多，又没有蚊帐，天一黑二喜便躺到床上去喂蚊子，让凤霞在外面坐着乘凉，等把屋里的蚊子喂饱，不再咬人了，才让凤霞进去睡。\r\n\r\n“生啦，是儿子。”    二喜一听急了，跳起来叫道：    “我没要小的。”    医生说：“大的也没事。”\r\n\r\n我是怎么也想不到家珍会是这么一副样子，她一颗泪水都没掉出来，只是看着凤霞，手在凤霞脸上和头发上摸着。\r\n\r\n“爹，我死了埋在这里。”    我叹了口气对二喜说：    “这块就留给我吧，我怎么也会死在你前面的。”\r\n\r\n人啊，活着时受了再多的苦，到了快死的时候也会想个法子来宽慰自己，\r\n\r\n坐在我对面的这位老人，用这样的语气谈论着十多年前死去的妻子，使我内心涌上一股难言的温情，仿佛是一片青草在风中摇曳，我看到宁静在遥远处波动。\r\n\r\n二喜不像别人家孩子的爹，是看着孩子长大。二喜觉得苦根背在身上又沉了一些，他就知道苦根又大了一些。\r\n\r\n“爹，我离不了苦根。”\r\n\r\n苦根大一些后也知道我是谁了，他常常听到二喜叫我爹，便记住了。我每次进城去看他们，坐在板车里的苦根一看到我，马上尖声叫起来，他朝二喜喊：\r\n“爹，你爹来了。”\r\n\r\n“我只有这点想想凤霞的福分。”\r\n\r\n我说：“我会摔死的，你不要我的命了？”他说：“我不要你的命，我要麻雀。”\r\n\r\n这样的日子过到苦根四岁那年，二喜死了。二喜是被两排水泥板夹死的。干搬运这活，一不小心就磕破碰伤，可丢了命的只有二喜，徐家的人命都苦。\r\n\r\n有庆、凤霞都死在那家医院里，没想到二喜到头来也死在了那里。你想想，我这辈子三次看到那间躺死人的小屋子，里面三次躺过我的亲人。我老了，受不住这些。去领二喜时，我一见那屋子，就摔在了地上。我是和二喜一样被抬出那家医院的。\r\n\r\n我说：“你爹不会来接你，我也不能送你回去，你爹死了。”他说：“我知道他死了，天都黑了还不来领我？”\r\n\r\n苦根是个好孩子，到他完全醒了，看我挑着担子太沉，老是停住歇一会，他就从两只箩筐里拿出两棵菜抱到胸前，走到我前面，还时时回过头来问我：    “轻些了吗？”    我心里高兴啊，就说：    “轻多啦。”\r\n\r\n“这两只鸡养大了变成鹅，鹅养大了变成羊，羊大了又变成牛。我们啊，也就越来越有钱啦。”\r\n\r\n做人还是平常点好，争这个争那个，争来争去赔了自己的命。像我这样，说起来是越混越没出息，可寿命长，我认识的人一个挨着一个死去，我还活着。\r\n\r\n牛是通人性的，我拉着它往回走时，它知道是我救了它的命，身体老往我身上靠，亲热得很，\r\n\r\n会看牛的告诉我，说它最多只能活两年三年的，我想两三年足够了，我自己恐怕还活不到这么久。谁知道我们都活到了今天，村里人又惊又奇，就是前两天，还有人说我们是——    “两个老不死。”\r\n\r\n“今天有庆、二喜耕了一亩，家珍、凤霞耕了也有七八分田，苦根还小都耕了半亩。你嘛，耕了多少我就不说了，说出来你会觉得我是要羞你。话还得说回来，你年纪大了，能耕这么些田也是尽心尽力了。”\r\n\r\n少年去游荡，中年想掘藏，老年做和尚。\r\n\r\n## 外文版评论摘要\r\n\r\n当这部沉重的小说结束时，活着的意志，是福贵身上唯一不能被剥夺走的东西。\r\n\r\n《活着》是不失朴素粗粝的史诗，斗争与生存的故事，给人留下了不可磨灭的残忍与善良的形象，在余华的笔下，人物在动物本能和人性之间苦苦挣扎。余华加诸叙述的那种冷酷的意志，使小说超出了常轨。\r\n\r\n叙述者看着老人和老牛在暮色苍茫中慢慢消失，留下他独自一人：“我看到广阔的土地袒露着结实的胸膛，那是召唤的姿态，就像女人召唤着她们的儿女，土地召唤着黑夜来临。”\r\n\r\n余华在《活着》中描绘了二十世纪中国的全貌……它以福贵的口吻讲述了二十世纪中的中国史……成为了当代中国文学的典范。\r\n\r\n除去作为背景的家族史，作品附带的描写中有对中国革命社会、意识蒙蔽和政治宣传的批评。\r\n\r\n生活超越一切财富，或者生活能带来有价值的财富？不惜一切代价地活着？\r\n\r\n成为历史的玩物的个体，历史表现出讽刺的力量，意识形态的斗争通向紧急状态和损失，也通向死亡和魔鬼。","type":"text/markdown","created":"20220409151832261","creator":"@oeyoews","modified":"20230929045124762","modifier":"oeyoews","page-cover":"https://wfqqreader-1252317822.image.myqcloud.com/cover/464/834464/t6_834464.jpg","tags":"books"},{"title":"测试数据的JS库","text":"* https://github.com/faker-js/faker\r\n* https://github.com/typicode/json-server","type":"text/markdown","created":"20230624033301396","creator":"oeyoews","modified":"20230726045248271","modifier":"oeyoews","tags":"JavaScript"},{"title":"消失的它","text":"","type":"text/markdown","created":"20231015090608041","creator":"Lenovo","modified":"20231015090830291","modifier":"Lenovo","tags":"电视剧"},{"title":"深浅拷贝","text":"浅拷贝和深拷贝是两种不同的对象复制方式，它们的区别在于拷贝的深度和引用关系。让我们详细了解一下它们的区别：\r\n\r\n1. **浅拷贝（Shallow Copy）**：\r\n   浅拷贝是创建一个新对象，将原始对象的属性值复制到新对象中。如果属性值是基本数据类型（例如数字、字符串、布尔值等），那么拷贝的是值本身。但如果属性值是引用类型（例如数组、对象、函数等），拷贝的是引用地址，新对象与原对象会共享同一个引用，因此对其中一个对象的修改会影响到另一个对象。\r\n\r\n   示例：\r\n   ```javascript\r\n   const originalArray = [1, 2, 3];\r\n   const shallowCopyArray = originalArray.slice();\r\n\r\n   originalArray[0] = 0;\r\n\r\n   console.log(shallowCopyArray); // Output: [1, 2, 3]\r\n   ```\r\n\r\n2. **深拷贝（Deep Copy）**：\r\n   深拷贝是创建一个新对象，同时递归复制原始对象的所有属性和嵌套对象。这意味着新对象和原对象完全独立，不共享任何引用关系，即使嵌套属性也会被递归地复制。\r\n\r\n   示例：\r\n   ```javascript\r\n   const originalObject = { a: 1, b: { c: 2 } };\r\n   const deepCopyObject = JSON.parse(JSON.stringify(originalObject));\r\n\r\n   originalObject.b.c = 0;\r\n\r\n   console.log(deepCopyObject); // Output: { a: 1, b: { c: 2 } }\r\n   ```\r\n\r\n需要注意的是，深拷贝有一些限制。它无法正确地处理一些特殊类型，如函数、正则表达式、循环引用等。此外，深拷贝会在复制过程中创建大量的临时对象，可能会导致性能问题。因此，在选择拷贝方式时，需要根据具体情况进行权衡。\r\n\r\n总结起来，浅拷贝只复制一层属性，深拷贝会递归复制所有嵌套属性，确保创建了一个完全独立的对象。\r\n\r\n浅拷贝和深拷贝在不同的使用场景中具有不同的应用。让我们看看它们在实际开发中的一些常见用途：\r\n\r\n**浅拷贝的使用场景：**\r\n\r\n1. **快速复制：** 当你只需要复制一个对象的第一层属性时，浅拷贝是一个快速且有效的方法。\r\n\r\n2. **性能优化：** 浅拷贝通常比深拷贝更快，因为它只复制了引用地址，而不是递归复制整个对象结构。在对性能要求较高的情况下，可以考虑使用浅拷贝。\r\n\r\n3. **共享状态：** 如果你希望多个对象共享一部分相同的属性，浅拷贝可以实现这种共享。修改其中一个对象的属性会影响其他对象。\r\n\r\n**深拷贝的使用场景：**\r\n\r\n1. **独立性要求：** 当你需要创建一个与原对象完全独立的对象，且不希望修改一个对象对另一个对象产生影响时，深拷贝是必需的。\r\n\r\n2. **递归属性：** 当对象中包含嵌套的对象或数组，而你需要递归地复制所有层级的属性时，深拷贝是唯一的选择。\r\n\r\n3. **数据传递：** 在数据传递过程中，特别是在多层嵌套的数据结构中，使用深拷贝可以确保传递的数据保持独立性，不受外部影响。\r\n\r\n4. **特殊数据类型：** 深拷贝可以正确地复制包括函数、正则表达式等特殊数据类型，而浅拷贝不能实现这些。\r\n\r\n综上所述，根据你的具体需求，选择浅拷贝还是深拷贝是很重要的。浅拷贝适用于快速复制和性能优化，而深拷贝适用于创建独立的对象、处理递归属性和传递数据等情况。","type":"text/markdown","created":"20230827145157329","creator":"oeyoews","modified":"20230827145234135","modifier":"oeyoews","tags":"JavaScript"},{"title":"激活你的windows(虽然我用Linux)","text":"https://github.com/massgravel/Microsoft-Activation-Scripts","type":"text/markdown","created":"20230824140418973","creator":"oeyoews","modified":"20230824140449937","modifier":"oeyoews","tags":""},{"title":"灵活性VS成本","text":"## 灵活性 VS 成本\r\n\r\n- [x] 高灵活性往往带来高成本\r\n      不要过分追求灵活性，灵活性往往带来很多额外成本(高开发成本、高维护成本、高复用成本)\r\n- [x] 限制灵活性反而能释放生产力","type":"text/markdown","created":"20230612142417407","creator":"oeyoews","modified":"20230726045248346","modifier":"oeyoews"},{"title":"玫红色","text":"玫红色又称玫瑰色，是红色系中比较偏冷的一种颜色，比标准红色要更接近紫色，在绘画中常用玫红和钴蓝相配，形成一种有紫色调的灰色，可以用来描绘多种阴影，单独使用适合在冷色调的画面中描绘红色物体，以与整个画面更加协调","type":"text/markdown","created":"20231027051604364","creator":"Lenovo","modified":"20231027051616081","modifier":"Lenovo","tags":"名词"},{"title":"电视剧","text":"<div class=\"my-8\" >\n<div class=\"dark:hidden\">\n<$echarts $tiddler=\"addon/tagpie.js\" $theme=\"auto\" doughnut=\"yes\" sort=\"descend\" $theme='light' filter=\"[tag[电视剧]]\"/>\n</div>\n<div class=\"hidden dark:block\">\n<$echarts $tiddler=\"addon/tagpie.js\" $theme=\"auto\" doughnut=\"yes\" sort=\"descend\" $theme='dark' filter=\"[tag[电视剧]]/>\n</div>\n</div>","type":"text/markdown","created":"20231015090659809","creator":"Lenovo","modified":"20231015090811094","modifier":"Lenovo","tags":""},{"title":"盗墓笔记","text":"## 第 1 章 七星鲁王 第一章 血尸\r\n\r\n50 年前，长沙镖子岭。\r\n\r\n平时候开枪的机会也少之有少，枪管一发热就卡壳了，这真是人倒霉，喝凉水都塞牙。\r\n\r\n## 第 2 章 七星鲁王 第二章 50 年后\r\n\r\n三年不开张，开张吃三年\r\n\r\n历史上盗墓的分南北两派，土夫子按习惯来分，应该属于南派，主要靠探土寻找古墓，民国前用探锥，民国后用洛阳铲，一只鼻子就能断定深浅朝代，现在很多小说里描写动不动就洛阳铲，其实北派是不用洛阳铲的，他们精于对陵墓位置、结构的准确判断，就是所谓的寻龙点穴。\r\n\r\n在桥上自杀不跳河——撞桥（巧）啊。”\r\n\r\n## 第 3 章 七星鲁王 第三章 瓜子庙\r\n\r\n八阵书图（字画，又叫藏画文），就是把一个地方详细的地理位置用特殊文法写出来，看起来是一堆毫无意义的文字，其实里面的信息非常丰富，是古时候行兵作战的时候用的一种密码。\r\n\r\n不过这小子特讨厌，整个儿一拖油瓶，一路上屁都没放一个，就直勾勾看着天，好象忧郁天会掉下来一样！\r\n\r\n轻声用杭州话说了一句：“这老头子有问题，小心。”\r\n\r\n## 第 4 章 七星鲁王 第四章 尸洞\r\n\r\n到那山洞还有一段路，这一段风景极其好，两边山势陡峻，山峦叠起，简直美不胜收，我一边赞叹，一边拿出数码相机，啪啦啪啦拍了很多照片。\r\n\r\n正扯着，那闷油瓶突然一摆手，轻声叫道：“嘘，听！有人说话！”我们被他这突如起来一个动作吓了一跳，马上屏气息，果然听到悉悉蔌蔌的声音从洞的深处传来。\r\n\r\n我还真没注意过那人的手，一看，还真不寻常，他的手，中指和食指特别的长，我马上联想到古时候发丘中郎将的双指探洞的工夫，我在我爷爷笔记上看到过相关的记载，那发丘郎将中的高手，这一双手指，稳如泰山，力量极大，可以轻易破解墓穴中的细小机关，而要练成这么一手绝活，非的从小练起不可，其过程必然是苦不堪言。\r\n\r\n## 第 5 章 七星鲁王 第五章 水影\r\n\r\n这时候，那闷油瓶也浮出了头，一看我快顶不住了，赶忙冲过来，一下子把两根手指插进那虫子的背脊，一发力，一扯，一条白花花的通心粉一样的东西被他扯了出来，可怜那虫子刚才还占尽上风，一秒都不到就歇菜了，我把那虫尸往船上一扔，感觉像做了场梦一样。\r\n\r\n## 第 6 章 七星鲁王 第六章 积尸地\r\n\r\n淘沙就不怕鬼，怕鬼就不淘沙\r\n\r\n我先听到边上的闷油瓶冒了句洋文出来\r\n\r\n那闷油瓶的手上不一会儿便滴满了血，他把血手往那白衣女子一指，那女子竟然跪了下来。我们看的呆掉了，闷油瓶对三叔说，：“快走，千万不要回头看！”\r\n\r\n## 第 7 章 七星鲁王 第七章 100 多个人头\r\n\r\n那闷油瓶子好象失血过多，一直没醒过来，我把他扶到牛车上，这人也真是的，身子软的像个女人似的，好象没什么骨头一样。\r\n\r\n这荒山野领的造别墅，不是华侨就是盗墓啊。\r\n\r\n## 第 8 章 七星鲁王 第八章 山谷\r\n\r\n“人为鸟死——“大奎念念到，潘子踢了他一脚：“有文化不？为鸟死，你去为*死啊。”\r\n\r\n## 第 10 章 七星鲁王 第十章 影子\r\n\r\n古人讲话非常简洁，而且非常有技巧，比如说，一个：“然”，我记得一个齐国的国君问他的军师一个问题，那军师点头一笑，说：“然”。那国君就回去琢磨了半天想着个然到底是同意还是反对，结果就积劳成疾了，弥留之际就把自己考虑的答案和军师说了，问军师当时是不是这个意思，那军事呵呵一笑：“然”。那皇帝立马就断气了。\r\n\r\n那玉门的边上，有两个雕像，是两个饿面鬼，一个手里拿着一只鬼爪，一个手里举着一只印玺。混身漆黑。\r\n\r\n## 第 11 章 七星鲁王 第十一章 七星棺\r\n\r\n我们看清楚了这怪物真面目，它就像。。。就像一个人把一大瓦罐套在头上面。。。靠，你爷爷的。\r\n\r\n因为外面现在一点光线也没有了，一片漆黑，我也不知道那尸体在搞什么东西，如果他只不停的坐起来，躺下去，锻炼腹肌，我也倒不怕它。就怕他不知道好歹走过来。\r\n\r\n## 第 12 章 七星鲁王 第十二章 门\r\n\r\n然后还有一张，上面画了着一个张牙舞爪类似于树，又像是一只鬼爪东西。\r\n\r\n## 第 14 章 七星鲁王 第十四章 闷油瓶\r\n\r\n就在这个时候，突然那顶上又是一声机关响，又一个人从上面跳了下来，注意，这个人是跳下来的，不是摔下来的，所以他落的时候很稳，但是落地的份量非常重，他一躬身缓冲，单手撑地，呼了口气，那些尸蹩先是一楞，突然间就像疯了一样到处乱撞起来，拼了命的想远离这个人，原本像潮水一样涌过来的这些大虫子，这个时候同样像潮水一样退了下去。消失在墙壁上的几处钩穴深处。\r\n\r\n## 第 16 章 七星鲁王 第十六章 小手\r\n\r\n人身负重伤，3 个人不知去向，这种\r\n\r\n## 第 17 章 七星鲁王 第十七章 洞\r\n\r\n如果一个人一下遇到突发事情太多，反而会变的冷静起来\r\n\r\n胖子一个肥猪打挺跳起来，\r\n\r\n## 第 23 章 七星鲁王 第二十三章 棺椁\r\n\r\n三叔大笑：“这棵叫九头蛇柏，我早就想到了，你没看到那些个藤蔓怎么样都不敢碰这里的石头嘛？这石头叫天心岩，专克九头蛇柏，我们弄点石头灰涂在身上，保准顺顺利利的。”\r\n\r\n## 第 24 章 七星鲁王 第二十四章 活尸\r\n\r\n一般战国诸侯王都是二重椁，三层棺\r\n\r\n## 第 26 章 七星鲁王 第二十六章 紫玉匣子\r\n\r\n闷油瓶拔出树上的刀，躺到一边的玉石床边上，默默的盯着那具鲁殇王的尸体，眼神迷离了起来。\r\n\r\n闷油瓶淡淡道：“他当然不会，因为到最后，躺在玉俑里的，早就不是鲁殇王，而是他自己。”\r\n\r\n## 第 27 章 七星鲁王 第二十七章 谎言\r\n\r\n闷油瓶也非常吃惊，一拍我的肩膀，说:”我们快点离开，蹩王在在这里，我克制不住这些尸蹩，非常棘手!”\r\n\r\n闷油瓶看到我想上去帮大奎，拉住我咬着牙说:”不能碰他，碰到就死!”.\r\n\r\n## 第 30 章 怒海潜沙 第一章 蛇眉铜鱼\r\n\r\n墓葬自人类认识到死亡以来，就一直是人类特有的人文活动，其历史与人类的历史等长，各个时期的墓葬中都蕴藏了大量当时人类生活的信息，包罗衣食住行各个方面，所谓事死如事生，是古人一直传承到现在墓葬规律。\r\n\r\n三叔意味深长的笑了笑，很坚决的说道：“不行，接下来的事情，我就算带进坟墓里不会说。”\r\n\r\n## 第 32 章 怒海潜沙 第三章 英雄山老海\r\n\r\n我对于国宝外流非常反感，心里盘算着最好能找一个爱国的企业家，半卖半送也可以，国宝当然要放在中国人房里。\r\n\r\n## 第 35 章 怒海潜沙 第六章 海南\r\n\r\n在大海中景色单调，让我留下印象的，是那种宝石一般的蓝色，广阔无垠的深蓝色与远天衔接，犹如一块缓缓隆起的蓝色大陆，闪着远古洪荒般的琉璃之光。\r\n\r\n## 第 36 章 怒海潜沙 第七章 鬼船\r\n\r\n她发抖着说道：“这艘船是 k5－883！”\r\n\r\n## 第 37 章 怒海潜沙 第八章 枯手 改\r\n\r\n看似是一个天大的巧合，其实在某种程度上是必然。\r\n\r\n我听了这句话，隐约感觉上事情似乎有点不对劲，三叔最讨厌计划，他乱七八糟的生活已经过了大半辈子，何以会突然性情大变？\r\n\r\n## 第 47 章 怒海潜沙 第十八章 第一次解迷\r\n\r\n闷油瓶哦了一声，突然一笑，说：“原来是这么一回事情——”\r\n\r\n## 第 48 章 怒海潜沙 第十九章 继续解迷\r\n\r\n这人就是这样，如果自己死定了，就什么事情都不想去做，但一知道还有一线希望，全身的智慧都会调动起来。\r\n\r\n## 第 50 章 怒海潜沙 第二十一章 一个人\r\n\r\n人心是最不可测的，为了一点点根本没有事实依据的事情，这些人的命就如果草芥一样被夺去了。\r\n\r\n## 第 51 章 怒海潜沙 第二十二章 瓷画\r\n\r\n闷油瓶淡淡说道:“凡事无绝对.”\r\n\r\n这世界上最恐怖的东西，永远是在自己的心里\r\n\r\n## 第 54 章 怒海潜沙 第二十五章 石碑\r\n\r\n突然听到边上的闷油瓶说道：“这地方我好象来过！”\r\n\r\n## 第 57 章 怒海潜沙 第二十八章 奇门盾甲\r\n\r\n对于机关的原理，张起灵并不陌生，用他自己的话说，他对于中国古墓的陷阱机关的了解，超过世界上任何人（原话），他对于机关的工作原理，起源，缺点，甚至发明者的名字，都非常了解。\r\n\r\n## 第 58 章 怒海潜沙 第二十九章 生门\r\n\r\n奇门遁甲阵又叫八阵，分八个门开门休门生门死门惊门伤门杜门景门，生门为生，死门为死，入其他各门，则又见八门，周而复始。\r\n\r\n## 第 60 章 怒海潜沙 第三十一章 血字\r\n\r\n闷油瓶伸手就去开那个暗门，弄了两下，突然骂了一声，转过头来对我说道：“有人在外面把门轴卡死了！”\r\n\r\n“吴三省害我，走投无路，含冤而死，天地为鉴——解连环。”\r\n\r\n## 第 62 章 怒海潜沙 第三十三章 盗洞\r\n\r\n闷油瓶看着好笑，也直摇头，我还是第一次看见他不是苦笑，不由也觉得他变的似乎有点人情味起来，看样子人之间还是要多交流的嘛。\r\n\r\n## 第 70 章 怒海潜沙 第四十一章 脱出\r\n\r\n闷油瓶露出了不敢相信的表情的，看样子他对自己刚才的判断很有信心，没想到会出错误。\r\n\r\n我定了定神，看了一下四周，这个时候已经是夕阳晚照，海平线上的火烧云倒影在海水里，分外的妖娆，太阳是深红色，发出昏黄的光芒，把一切裹在一团柔和里，形成一幅非常瑰丽安详的景象。\r\n\r\n## 第 71 章 怒海潜沙 第四十二章 总结\r\n\r\n“天真无邪同志，吃饭了，自己拿筷子。”\r\n\r\n## 第 80 章 秦岭神树篇 第九章 侵路\r\n\r\n人一但失去目标，各种不利因数就回无限放大\r\n\r\n## 第 87 章 秦岭神树篇 第十六章 休息\r\n\r\n爷爷说的对，人心险恶，这个世界上真是什么样的人都有。\r\n\r\n## 第 91 章 秦岭神树篇 第二十章 孔雀花翎\r\n\r\n真是老母鸡管自己叫妈——自己下（吓）自己。\r\n\r\n## 第 105 章 秦岭神树篇 第三十三章 鬼雾\r\n\r\n棺材代表着钱和权力不能控制的死亡，是非人力所能撼动的权威，这一点倒斗的人反而很难体会。\r\n\r\n## 第 106 章 秦岭神树篇 第三十四章 偷袭\r\n\r\n要镇定下来，这个时候其实根本没有选择，只有去面对，害怕和找借口根本是等死的表现。\r\n\r\n## 第 130 章 云顶天宫篇 第十五 五圣雪山\r\n\r\n天下最难过三条的边境线，一条是印度和巴基斯坦，一条是以色列和黎巴嫩，还有一条，就是三圣山的这一条只有 14 公里长的边防线。\r\n\r\n我顺着他的手指指的方向一看，只见一边的闷油瓶已经跪了下来，朝着远处的三圣雪山，十分恭敬的低下了头。原本面无表情的脸上，显露出了一种淡淡的，十分悲切的神情。\r\n\r\n## 第 136 章 云顶天宫篇 第二十一 博弈\r\n\r\n闷油瓶道：“你不觉得奇怪吗？我们到了这里，好像情绪都很焦躁，连吴邪都发火了。”\r\n\r\n## 第 137 章 云顶天宫篇 第二十二 骚动\r\n\r\n相信所有的人都有体会，在黑暗遇到自己恐惧的东西，你一个人逃跑，你跑不了多远就会停下来，但是如果大家一起跑，到后来就肯定一发而不可收拾，你的想象力和落单的恐惧不会让你停下来。\r\n\r\n而闷油瓶是职业级别的突然失踪人员，他在遇到情况的时候一直会习惯性的殿后，然后突然失踪是非常正常的事情。\r\n\r\n## 第 139 章 云顶天宫篇 第二十四 百足龙神\r\n\r\n前走三后走四，是土夫子的土语，意思是做事情，做之前哟啊考虑三步，做之后要考虑四步。土夫子在地下，每动一样的东西都是性命悠关地，所以你在做任何事情前，都必须考虑到后三步会发生的事情和该处理的办法，如果发现你无发解决，你这事情就不能做。而且这样的考虑必须养成习惯。\r\n\r\n## 第 141 章 云顶天宫篇 第二十六 藏尸阁\r\n\r\n“连环扣”是一种骗术，是外八行里老千一个“雀”字局里的伎俩，讲的是把真的东西做成假的，再做成真的，然后留一点破绽，让其他人看的时候，看到破绽，看破最外面“真”的面纱，以为这东西是假的，其实这东西确实是真的，也就是空城计的一种。\r\n\r\n## 第 145 章 云顶天宫篇 第二十九 火山口 贰\r\n\r\n盗墓代表着人类一种最原始的欲望，求得财富和探询死亡，这种刺激，恐怕是人就无法避免的。\r\n\r\n## 第 146 章 云顶天宫篇 第三十 门殿\r\n\r\n在与传统的墓葬观念中，陵和墓经常是混为一谈，其实陵墓，是两种不同的东西，陵就是用来祭祀和入殓仪式的地上建筑，而墓，才是指地下的地宫。\r\n\r\n## 第 149 章 云顶天宫篇 第三十 门殿 肆\r\n\r\n葬书上说：地有四势，气从八方，帮砂以左为青龙，右为白虎，前为朱雀，后为玄武。玄武垂头，朱雀翔舞，青龙蜿蜒，白虎顺俯。形势反此，法当破死。故虎蹲谓之衔尸，龙踞谓之嫉主，玄武不垂者拒尸，朱雀不舞者腾去……\r\n\r\n## 第 157 章 云顶天宫篇 第三十八 黄金中的死人\r\n\r\n人类对于黄金的喜爱，已经写入了基因中，变成了与生俱来的，不可抗拒的本能了，他真他娘的说对了。\r\n\r\n## 第 168 章 云顶天宫篇 第四十九 唯一的出口\r\n\r\n又前进了一段时间，胖子突然回头问我：“你老实告诉我，你和那小哥有什么特殊的关系?”　　我给胖子问的呛了一声，不知道该怎么回答，随即想到是自己理解错误了，他问的不是我想的那种关系。\r\n\r\n我不想阿宁知道我有着两条铜鱼在手上，所有很多事情我都不能明讲。\r\n\r\n## 第 173 章 云顶天宫篇 第五十四 天与地的差距 &amp;amp; 第五十五 永远无法解开的谜团\r\n\r\n我看到闷油瓶注意到了我们这边，把头转了一转，正看到我和胖子的脸，他突然意味深长的笑了笑，动了动嘴巴，说的是：“再见。”\r\n\r\n## 第 174 章 云顶天宫篇 第五十六 修整之后\r\n\r\n这大概就是所谓的战争倦怠群候诊，很多越战的老兵，从战场上回来之后，做什么事情都提不起精神，因为他们在战场上已经看到了人类的终极了，很多美好生活的谎言，对于他们来说太虚假了。\r\n\r\n## 第 175 章 蛇沼鬼城篇 第一 三叔的醒来\r\n\r\n常常就想，那挨千刀的闷油瓶，他现在在干什么呢？\r\n\r\n自古老三怕老二，老二永远是家族中最狠的，因为老大是需要超脱的，高出兄弟一头的，那实际办事的，就是老二了。\r\n\r\n发誓我是当饭吃的，哪能当真，当即就发了一个全家死绝的毒誓。\r\n\r\n## 第 182 章 蛇沼鬼城篇 第八 西沙的前奏\r\n\r\n来人姓解，叫做解连环，大概是取“怨怀无托。嗟情人断绝，信音辽邈。纵妙手能解连环”里面的字。\r\n\r\n## 第 183 章 蛇沼鬼城篇 第九 录影带\r\n\r\n我们知道中国八大天书：《仓颉书》、《夏禹书》、“红岩天书”、“夜郎天书”、“巴蜀符号”、蝌蚪文、“东巴文书”以及“峋嵝碑”，都是文字孤本，没法进行破译。\r\n\r\n## 第 196 章 蛇沼鬼城篇 第二十四章 死而复生的人\r\n\r\n裘德考背叛了爷爷，三叔背叛了裘德考，楚哥背叛了三叔，然后阿宁背叛了我们，人，真是可怕的动物。\r\n\r\n## 第 209 章 蛇沼鬼城篇(中) 第十二章 文锦的笔记(上)\r\n\r\n长白山——云顶天宫 \r\n  瓜子庙——七星鲁王宫 \r\n  卧佛岭——天观寺佛塔 \r\n  沙头礁——海底沉船墓\r\n\r\n## 第 210 章 蛇沼鬼城篇(中) 第十二章 文锦的笔记(下)\r\n\r\n1993 年 6 月 18 日，看来，我看到了终极！\r\n\r\n## 第 213 章 蛇沼鬼城篇(中) 第十五章 重逢\r\n\r\n然而现实却是他捂着我的嘴，黑暗中，我一点呻吟也发不出来，动也不能动，而且我明显感觉到他的力气一直在持续着，他根本就没打算放手，而是想一直这么制着我。这让我很不舒服，我又用力挣扎了一下，他压得更紧，我几乎喘不过气来。\r\n\r\n不过闷油瓶竟然会成阿宁的顾问，感觉很怪，我有点被背叛的感觉。\r\n\r\n## 第 216 章 蛇沼鬼城篇(中) 第十八章 口信\r\n\r\n我说不出话，想了想才道：“没有你说的这么夸张，你要是消失，至少我会发现。”\r\n\r\n## 第 225 章 蛇沼鬼城篇(中) 第二十七章 第一场雨\r\n\r\n最开心的是闷油瓶真的是站在我们这边的，那就万事大吉了。\r\n\r\n## 第 230 章 蛇沼鬼城（中） 第三十二/三章 青苔下的秘密\r\n\r\n他自己的世界里，一直只有他一个人，所以他根本没有必要表露任何的东西。\r\n\r\n## 第 231 章 蛇沼鬼城（中） 第三十四/五/六章 蛇骨\r\n\r\n在危难中和你并肩的人，并不一定能和你共富贵，而在危难中背叛你的人，也并不一定不能相交，世事无常，夫妇共勉之。\r\n\r\n## 第 234 章 蛇沼鬼城（中) 第四十一章 蛇王\r\n\r\n我们忙去看阿宁，我上去抱起她，却见她脸上的表情已经凝固了，喉咙动着想说话，眼里流着眼泪，似乎有一万个不甘心。我头皮一下就麻了起来，不知道怎么办了，整个人发起抖来。接着，只是几秒的工夫，她的眼神就涣散了，整个人软了下来，然后头也垂了下来。\r\n\r\n## 第 235 章 蛇沼鬼城（中) 第四十二/四十三/四十四章 蛇沼鬼城\r\n\r\n两分钟后，阿宁停止了呼吸，在我怀里死去了。凌乱的短发中俏丽得让人捉摸不透的脸庞凝固着一个惊讶的表情，我们围着她，直到她最后断气，静下来，时间好像凝固了一样。\r\n\r\n凭空出现的一个人，没有过去，没有将来，似乎和这个世界没有任何的联系\r\n\r\n## 第 236 章 蛇沼鬼城（中) 第四十五/六章 尸体的脚印&蛇的阴谋\r\n\r\n闷油瓶仔细一看，惊叫了一声：“天哪，是陈文锦!”说着一下冲入了沼泽，向那个人奔去。\r\n\r\n## 第 237 章 蛇沼鬼城（下) 第一章 追击\r\n\r\n在很多时候，慢了半拍就等于失去了所有的机会。\r\n\r\n## 第 238 章 蛇沼鬼城（下) 第二/三/四/五章\r\n\r\n人活着才是人，死了就是个东西，臭皮囊而已\r\n\r\n## 第 243 章 蛇沼鬼城（下) 第十六到二十章\r\n\r\n我笑起来，感觉只有闷油瓶在的时候，胖子的笑话听起来才好笑\r\n\r\n大概是因为闷油瓶在的关系，这一次睡沉过去了，觉得特别的安心，到了傍晚才醒来。\r\n\r\n这和战争一样，在人人都有很大可能会死的时候，人们关心的只是事情的结果，而不是单个人的安危。\r\n\r\n闷油瓶摇头：“你们警觉性太低，如果我们判断正确，那么这种变故将极其凶险，恐怕你们无法应付，今天晚上我守全夜，你们好好休息。”\r\n\r\n## 第 247 章 蛇沼鬼城（下) 第二十五/二十六章\r\n\r\n胖子最烦我这个样子，他说我就是个林黛玉，整天不知道在琢磨什么，这人世间的东西哪有这么多好琢磨的，没心没肺地活着也是蹬腿死，你机关算尽也是蹬腿死，反正结局都一样，你管中间那个羁绊干什么。\r\n\r\n那是一种戏称，老鸨其实是一种鸟，古时候有人发现，老鸨这种鸟，只有雌鸟，没有雄鸟，它们要繁衍后代，可以和任何其他品种的鸟类交配，为万鸟之妻，所以人们就用‘老鸨’来代称人尽可夫的妓女。\r\n\r\n## 第 266 章 谜海归巢 第十一章 机关\r\n\r\n忽然就看到闷油瓶从血尸群里翻了出去，犹如天神一般踩着一边的几乎垂直的岩壁竟然蹬了上去，然后一纵跳出了包围圈，借着冲击力就地一滚就翻到了一处血尸稀疏的地方，接着就看他几乎是毛腰贴着地面在跳，从血尸之间迅速穿过，瞬间就退到丹炉边上。\r\n\r\n## 第 267 章 谜海归巢 第十二章　  近了\r\n\r\n殿后的黑瞎子就笑，这两个人一个黑一个白，一个冷面一个傻笑，简直好像黑白无常一样，让人无语。\r\n\r\n## 第 270 章 谜海归巢 第十五章　  等待\r\n\r\n人只有在无法帮助自己想帮的人的时候才会觉得自己渺小。\r\n\r\n## 第 275 章 谜海归巢 第二十章　  尾声\r\n\r\n比鬼神更可怕的东西，是人心。\r\n\r\n## 第 276 章 阴山古楼 第一章 盗墓笔记\r\n\r\n别人拼命想掩盖的，必然是你不希望看到的，所以，追寻别人的秘密必然要承担知道秘密的后果。\r\n\r\n很少有人能有忘掉一切的机会，而幸运地忘掉的人，却又不顾一切地想记起来，这种轮回简直是一个人性的悖论。\r\n\r\n青山不改绿水长流，后会有期。\r\n\r\n庄周梦蝶，醒后不知道自己是在做化人之梦的蝴蝶，还是在做化蝶之梦的凡人\r\n\r\n## 第 287 章 阴山古楼 第十三章 古怪的村子\r\n\r\n故事和现实生活的区别就是，故事你总能在关键时候加快节奏，但是现实生活总他娘的会出意外。\r\n\r\n## 第 290 章 阴山古楼 第十六章 巡山\r\n\r\n想想自己也是，好像人最大的本事就是折腾自己。\r\n\r\n## 第 293 章 阴山古楼 第十九章 老头\r\n\r\n鹿角龙鳞，踩火焚风，和闷油瓶身上的如出一辙。\r\n\r\n## 第 294 章 阴山古楼 第二十章 盘马老爹\r\n\r\n我心说我靠，好酷的老头，有闷油瓶的风范，难道这家伙是瓶爸爸？\r\n\r\n“说你们两个在一起，迟早有一个会被另一个害死。”\r\n\r\n## 第 298 章 阴山古楼 第二十四章 心理战\r\n\r\n诈人的诀窍就是让别人以为你基本上都知道了，从而在整个对话的形式上，把询问变成一种质问。\r\n\r\n## 第 303 章 阴山古楼 第二十九章 脑筋急转弯\r\n\r\n这人又是典型的自我放逐型人格，心在桃园外，兀自笑春风，谁也进不了他心里。\r\n\r\n## 第 304 章 阴山古楼 第三十章 虹吸效应\r\n\r\n世界上的一切都很简单，而人似乎是最复杂的，这种复杂又是他们抗拒却又逃避不了的。\r\n\r\n## 第 305 章 阴山古楼 第三十一章 湖底\r\n\r\n闷油瓶的内裤是胖子买的，上面有两只小鸡，把云彩笑得差点晕过去。\r\n\r\n## 第 310 章 阴山古楼 第三十六章 心理战 2\r\n\r\n做事情可以失败，但不可以在没有第二次机会的时候失败。\r\n\r\n## 第 311 章 阴山古楼 第三十七章 风雨无阻\r\n\r\n人就是这样，一天两天可以吓到半死，天天吓就皮了。\r\n\r\n## 第 316 章 阴山古楼 第四十二章 瑶家大院\r\n\r\n〖已勒燕然高奏凯 \r\n  犹思曲阜低吟诗〗\r\n\r\n## 第 329 章 阴山古楼 第五十五章 这里的石头\r\n\r\n当所有的不可能都排除后，再不可能，也是事实。\r\n\r\n## 第 333 章 阴山古楼 第五十九章 有三十五个\r\n\r\n他忽然朝我笑了笑，道：“还好，我没有害死你……”\r\n\r\n## 第 334 章 阴山古楼 第六十章 脱出\r\n\r\n“就是死，你们也给我死在地面上。”我咬牙道。\r\n\r\n## 第 339 章 阴山古楼 第六十五章 不速之客\r\n\r\n正思索着该怎么办，忽然身后的闷油瓶捏了我肩膀一下。　　捏得恰到好处，我舒服得一缩脖子，心说这家伙良心发现要给我按摩，却听他轻声道：“你看。”\r\n\r\n## 第 342 章 邛笼石影 第二章 老档案\r\n\r\n拥有东西，并不意味着拥有这东西的价值。\r\n\r\n## 第 343 章 邛笼石影 第三章 笔迹\r\n\r\n“对于我，一切都结束了，但对你来说，其实什么都没有开始。”\r\n\r\n## 第 345 章 邛笼石影 第五章 拍卖会\r\n\r\n闷油瓶身材匀称，面无表情，穿着西装倒是非常潇洒，惹眼得要命。\r\n\r\n## 第 346 章 邛笼石影 第六章 拍卖\r\n\r\n因为人不可貌相，谁也不知道对方的底细，做得七分奉承三分原则才能立于不败之地。当官如此，当服务员亦是如此。\r\n\r\n## 第 347 章 邛笼石影 第七章 霍霍霍霍\r\n\r\n胖子自然也是心中不爽，脸抖了抖，给闷油瓶使了个眼色：“小哥，整好队形，咱俩好好给天真同志得瑟一下。”三个人站起来就昂着头跟着那伙计往楼梯口去了。\r\n\r\n“菱茎时绕钏，棹水或沾妆。不辞红袖湿，唯怜绿叶香。此屋名取自刘孝绰的《遥见美人采荷》。”\r\n\r\n我是黑社会我是黑社会，老子走路带风老子走路带风。\r\n\r\n## 第 351 章 邛笼石影 第十一章 点天灯\r\n\r\n聪明的女人最大的特点就是知道事情做到什么份上正好。\r\n\r\n## 第 353 章 邛笼石影 第十三章 霍秀秀\r\n\r\n我看向闷油瓶，想问问他的想法，一想问他肯定没用，这家伙就在斗里机灵，在地面上属于生活能力九级伤残者。\r\n\r\n## 第 354 章 邛笼石影 第十四章 样式雷（上）\r\n\r\n琉璃孙也许永远也想不明白，那根钢管是如何从四十米外飞出准确地打到他的脑袋上的。\r\n\r\n## 第 358 章 邛笼石影 第十八章 背负着一切的麒麟（一）\r\n\r\n闷油瓶没有回答她，反而转身对我道：“带我回家。”说着，头也不回地向外走去。\r\n\r\n## 第 367 章 邛笼石影 第二十七章 史上最大盗墓活动（三）\r\n\r\n人往往就是这样，在事后想着当时应该这样当时应该那样，其实真的让他回到当时，他也许还是没有那个胆量。\r\n\r\n## 第 372 章 邛笼石影 第三十二章 样式雷（下）\r\n\r\n很多时候，一件事情，你即使再渴望，但是拖得太久，你也会慢慢失去锐气\r\n\r\n胖子立即道：“我们三个是一条心，共同进退，绝对不会被你们挑拨的，不过天真说不去，那是你们的诚意还不够。”\r\n\r\n## 第 374 章 邛笼石影 第三十四章 四川和分别\r\n\r\n可惜，有些路，走上去就不能回头，决绝的人可以砍掉自己的脚，但是心还是会继续往前。\r\n\r\n有时候总觉得，人的成长，是一个失去幸福的过程，而非相反。\r\n\r\n## 第 376 章 邛笼石影 第三十六章 巢（上）\r\n\r\n小花坐在一块石头上，双脚悬空荡着，下面就是万丈深渊，他看着雪山，眼中是万分肃穆的神采。\r\n\r\n## 第 377 章 邛笼石影 第三十七章 巢（下）\r\n\r\n坦然得让我自己都感觉到可怕。我在临睡前忽然意识到，自己真的变了。\r\n\r\n## 第 380 章 邛笼石影 第四十章 怪家伙\r\n\r\n我想着如果小花挂掉或者出事了，我怎么面对解家的人，我们吴家会不会被披上“解家收割机”之类的外号。\r\n\r\n## 第 390 章 邛笼石影 第五十章 进入机关之内\r\n\r\n闷油瓶在就好了，我再次出现了这样的念头，忽然就发现，那么多次化险为夷，原来不是我命好，我身边的那两个人解决了那么多的问题，我已经当成理所当然的了。\r\n\r\n## 第 393 章 邛笼石影 第五十三章 蛇咬\r\n\r\n不由又想起了胖子和闷油瓶，如果是他们在，那满身黑毛的家伙一定会在划伤我后背之前就被拧断脑袋了，或者我会看到胖子踩着那些陶罐冲出来把一切搞砸，但是我一定会得救。\r\n\r\n1896528 02200059\r\n\r\n## 第 400 章 邛笼石影 第六十章 轮回恐惧之面孔\r\n\r\n有些面具戴得太久，就摘不下来了。\r\n\r\n## 第 401 章 大结局（上） 第一章 吴邪心中的另一个人\r\n\r\n很多东西，一开始你会觉得无法接受，但一旦你接受了，也就这么回事而已。\r\n\r\n头发染成了斑白的颜色，三叔的斑白是他历经多少年痛苦才沉淀下来的痕迹，而我的斑白，却只需要几个小时，就看着毫无差别，这么一来，反而觉得三叔的痛苦是多么的不值得。\r\n\r\n我只是给你一张皮，这张面具除了戴在你的脸上，还需要你自己戴到你的心上。\r\n\r\n## 第 402 章 大结局（上） 第二章 由内而外的破绽\r\n\r\n那一刻，我忽然觉得自己开始失去了什么，那失去的东西一定是平时没有注意到的，就在这一刻，我忽然觉得无比的沮丧。\r\n\r\n## 第 403 章 大结局（上） 第三章 王八邱\r\n\r\n比鬼神更可怕的，是人心\r\n\r\n“有些事情你是扛不住的。”\r\n\r\n“送三爷去‘老地方’，遇到王八邱，直接打死，算我的。”\r\n\r\n## 第 404 章 大结局（上）第四章 世间有朵解语花\r\n\r\n人只要第一口气被压住，后面再横也横不起来。\r\n\r\n## 第 407 章 大结局（上） 第七章 吴邪的反击\r\n\r\n潘子是一条恶犬，一条只有三爷才能拴住的恶犬，三爷并不可怕，但是三爷手下有个疯子，他不要命，不怕死，只听三爷的话。所以，不要得罪三爷。\r\n\r\n## 第 409 章 大结局（上） 第九章 吴三省时代的终结\r\n\r\n“面具这种东西，能有第一张就有第二张。”小花让我别说话，继续拿出手机给我看，“我们解家人，做事情从来不会不留后手。”\r\n\r\n## 第 410 章 大结局（上） 第十章 曲终人散\r\n\r\n“压力这种东西，说着说着，就没了。”\r\n\r\n醒来的时候，已经是第二天早上了，我看到小花和潘子躺在我房间的沙发上，两个人身上全是血迹，都睡得很熟。我看了看窗外明媚的阳光，就知道一切都已经结束了。\r\n\r\n## 第 411 章 大结局（上） 第十一章 裘德考的邀请\r\n\r\n我心里咯噔一声，第一个念头竟然是：这么快又丢了，真他妈败家。\r\n\r\n## 第 415 章 大结局（上） 第十五章 缝隙里的胖子\r\n\r\n“我是天真，我听到了。”\r\n\r\n## 第 416 章 大结局（上） 第十六章 胖子肚子上的神秘图形\r\n\r\n潘子轻声道：“小三爷，这些孩子，都是苦出身，我们在考虑事情的时候，要给他们留点余地。他们并不是炮灰，他们也都是命。”　　我看着潘子，忽\r\n\r\n## 第 425 章 大结局（上） 第二十五章 没有选择\r\n\r\n“天真，你原来的脸挺好看啊，何必整得和你那三叔一样，”胖子轻声道。\r\n\r\n有些闲难，未必像别人说的那么难\r\n\r\n“天真，你不懂”胖子指了指身后，“你信任所有人。见人就掏心掏肺，我和你不一样，这后面的人，我一个也不信任，”\r\n\r\n## 第 427 章 大结局（上） 第二十七章 我看到了我自己\r\n\r\n人似乎总是这样，当有了一个焦点的时候，往往会忽视真正的危险。\r\n\r\n## 第 430 章 大结局（上） 第三十章 孤立无援\r\n\r\n打击这东西，只要没把人打垮打死，对人总是有帮助的。\r\n\r\n## 第 437 章 大结局（上） 第三十七章 赶路\r\n\r\n所有人在一开始就已经做好了迎接自己结局的准备\r\n\r\n## 第 441 章 大结局（上） 第四十一章 古镜中的玄机\r\n\r\n一个现象一定有一个起点和终点。有的时候这个起点和终点本身并不重要，重要的是，起点是如何到达终点的，只要通过不停地改变参数，仔细观察变化，就能知道很多线索。\r\n\r\n凡事都要看目的，由目的才能推测出很多从正面推测想不到的方面\r\n\r\n## 第 442 章 大结局（上） 第四十二章 山洞顶部有东西\r\n\r\n“老子他娘活跃气氛，你丫心急就心急，别老挤兑我，再啰嗦我把你日出烟来，你他娘还不一定是紫烟呢。”胖子就怒了。\r\n\r\n## 第 444 章 大结局（上） 第四十四章 流沙陷阱\r\n\r\n显然，恐惧才是人类的第一生产力。\r\n\r\n## 第 447 章 大结局（上） 第四十七章 终于见到了张家古楼\r\n\r\n他们在哪里？我心中的急切一下就爆发出来：“张起灵！”我大吼了一声。\r\n\r\n## 第 452 章 大结局（下） 第一章 张起灵这个名字的意义\r\n\r\n我脑子里出现了一大排闷油瓶带着黑金古刀列队出操的景象——这真是可怕，不过也够气势逼人。\r\n\r\n## 第 454 章 大结局（下） 第三章 所有人都死了\r\n\r\n“醒醒，回家了。”我拍了拍他的脸。忽然我就觉得很好笑。我转头对胖子笑了起来：“你看看小哥。”\r\n\r\n## 第 456 章 大结局（下） 第五章 切掉了头颅\r\n\r\n“家有一哥，如有一宝啊！”胖子说道。\r\n\r\n## 第 458 章 大结局（下） 第七章 神秘的棺材\r\n\r\n我心说，要养活小哥可贵着呢！这种大人物，就算是打电话去公安局报失踪案的电话费也远远高于几个古董。咱们和小哥是朋友关系——我听其他一些人说过，哑巴张夹喇嘛的价位高得吓死人，出场费肯定比周杰伦高，虽然他一首歌也不会唱\r\n\r\n## 第 459 章 大结局（下） 第八章 冲锋枪和粽子\r\n\r\n闷油瓶为了避免多生事端，选择了从其他的途径通过一这也是他的风格，绝对不走别人给他安排好的道路。\r\n\r\n## 第 462 章 大结局（下） 第十一章 雾气弥漫\r\n\r\n“先把小哥带出去。”我忽然镇定了下来，一边对胖子说，一边把小哥从背上翻了下来，然后用公主抱将小哥抱了起来，把小哥的头伸入了网中间的空隙里。胖子在那边也用同样的动作，一点一点把小哥接了过去。\r\n\r\n“你想干什么？”我问他。潘子道：“你往前走吧。小三爷你大胆地往前走啊，往前走，别回头。”潘子说着说着，就唱了起来，\r\n\r\n## 第 463 章 大结局（下） 第十二章 再次获救\r\n\r\n“你的局，未必是小哥的局。”胖子说道，\r\n\r\n## 第 464 章 大结局（下） 第十三章 回归\r\n\r\n我闭上眼睛，努力不让自己哭出来。胖子的哭号声还在我的耳边回荡。我想起了云彩的那张画，画里的我们，第一次去巴乃的我们。虽然心中充满了谜团，但我们看上去很幸福，因为那个时候，命运还在我们自己的手里。\r\n\r\n人真是一种奇怪的生物，他们最重要的目的是生存，然而生存却往往不是这个人最大的烦恼。当人满足了自己所有的需要时，他们往往会为自己寻一个无法解决的烦恼。\r\n\r\n我没有感觉到一点恐惧。只觉得绝望，那种绝望无时无刻不在吞噬着我。\r\n\r\n## 第 475 章 大结局（下） 第二十四章 交代和流水账\r\n\r\n很多男人，并不是因为这样那样而被人记住，他被人记住，是因为他永远不会回来了。\r\n\r\n比麻木更深的一层，就是淡然，对于死亡的淡然。\r\n\r\n## 第 476 章 大结局（下） 第二十五章 闷油瓶的道别\r\n\r\n“我来和你道别的。”他道，“这一切完结了，我想了想我和这个世界的关系，似乎现在能找到的，只有你了。”\r\n\r\n## 第 477 章 大结局（下） 第二十六章 又到二道白河\r\n\r\n这个时候，闷油瓶才看向我，对我道：“你不能跟着我去。”“如果我劝你别去，你会不去吗？”我问他。他摇头，我就火大了：“狗日的，所以，如果你劝我别去，我也不会听的。所以你别多嘴了，我就要跟着。” \r\n  他看向我，又把脸转了过去，真的就不说话了。\r\n\r\n黄昏中，我又看到了熟悉的景象：雪山在夕阳下，呈现出一种温暖与冰冷完全无缝衔接的感觉。当时闷油瓶就在同样的夕阳下，对着远处的雪山膜拜。但是这一次他并没有跪下来，而是淡淡地看着，夕阳照在他的脸上，有一种极致的苍凉之感。\r\n\r\n## 第 478 章 大结局（下） 第二十七章 圣雪山\r\n\r\n一路上，只有我在不停地说话，说这个世界的美好，说还有什么地方是他没有去过的，什么地方有着无比诱人的美食。他始终没有说话，也没有表现出任何厌烦的情绪。\r\n\r\n你一个很好的朋友，执意寻死，你看着他，但是你阻止不了他，你和他之间隔着一层用任何工具都无法打穿的东西。你能用任何方式去触碰到这个东西，但是你却找不到可以将它攻破的缺口。\r\n\r\n## 第 479 章 大结局（下） 第二十八章 雪盲\r\n\r\n“也行，随便你怎么样，如果你真的把我打晕了，我也没有什么可说，但是我希望你知道，如果你需要有一个人陪你走到最后，我是不会拒绝的。”我道，“我要陪你去，这是我自己的决定，所以你不用纠结。”\r\n\r\n## 第 480 章 大结局（下） 第二十九章 故地\r\n\r\n我接过鬼玉玺，他就道：“你带着这个东西，来到青铜门前，门就会打开。十年之后，如果你还记得我，你可以带着这个东西，打开那道青铜门。你可能还会在里面看到我。”\r\n\r\n## 第 482 章 《后记》上\r\n\r\n史蒂芬在《黑暗塔》的序里曾经说过：我写这本书，赚了很多的钱，但是写作这本书最初的快乐，和钱一点关系也没有。\r\n\r\n我总觉得有一个世界，已经在其他地方形成。因为我敲动键盘，那个世界慢慢地长大、发展，里面的人物也开始有了自己的灵魂。\r\n\r\n## 第 483 章 《后记》下\r\n\r\n情绪是一种不可以定量的东西，伤心就是伤心，开心就是开心。我写作是为了寻找我最初的快乐，如果因为小小的失去，就拿出自己百分百之百的伤心来，那是很不值当的。\r\n\r\n成绩好的学生，体育一般都不会太好；如果体育好的学生，成绩一般都不怎么样；成绩和体育都好的学生，一般都长得丑；成绩和体育都好，长得又不丑的同学，一般都会早恋然后被开除；成绩和体育都好，长得不丑，而且特别规矩不早恋的同学，后来都变成了 gay 了。\r\n\r\n喜欢一件事情，坚持做下去，总是可以成功的。\r\n\r\n“这是我的朋友，请你们走开，告诉你们老板，如果我的朋友受到任何一点伤害，我一定会杀死他，即使跑到天涯海角，我也能找到他，反正我有的是时间。”闷油瓶淡淡地说出了这句话，身后是不知所措的胖子和吴邪。","type":"text/markdown","author":"南派三叔","created":"20230929044832226","creator":"oeyoews","modified":"20230929045339938","modifier":"oeyoews","page-cover":"https://wfqqreader-1252317822.image.myqcloud.com/cover/309/464309/t6_464309.jpg","tags":"books"},{"title":"知识管理","text":"知识管理（Knowledge Management）是一种组织或个人对知识的有效获取、创建、共享和应用的过程。它旨在帮助组织或个人有效地管理和利用其知识资源，以提高工作效率、创新能力和竞争力。\r\n\r\n以下是知识管理的一些关键方面：\r\n\r\n1. 知识获取：知识管理包括收集、整理和存储各种知识资源的过程。这可能包括内部知识、外部知识、经验教训、最佳实践、研究报告、专家意见等。知识获取可以通过各种途径实现，如文档归档、信息采集、调查研究等。\r\n\r\n2. 知识创建：知识管理鼓励组织或个人通过知识创造活动产生新的知识。这可以通过团队合作、创新研发、实验和经验分享来实现。知识创建涉及到从已有知识中提取新见解、理论或解决方案的过程。\r\n\r\n3. 知识共享：知识管理鼓励组织或个人共享知识，以便其他人可以从中获益。共享可以通过内部沟通渠道（如会议、培训、内部社交网络）或知识库和协作平台来实现。共享知识有助于避免重复工作、提高团队协作和加速问题解决。\r\n\r\n4. 知识应用：知识管理的最终目标是将知识应用于实际工作中，以提高业务绩效和创造价值。这包括将知识转化为实际操作、制定决策、解决问题、改进流程等方面。知识应用需要将知识与组织的具体需求和目标相结合。\r\n\r\n5. 知识评估和演进：知识管理还涉及对知识进行评估和演进的过程。这包括对知识质量、可用性、适用性和影响力进行评估，并采取相应的措施来完善和更新知识资源。知识管理应该是一个不断改进和适应变化的循环过程。\r\n\r\n知识管理可以通过技术工具来支持，如知识库系统、文档管理系统、协作平台和社交网络等。它还需要组织文化的支持，鼓励知识共享、学习和创新的价值观。\r\n\r\n通过有效的知识管理，组织可以更好地利用其内部和外部知识资源，提高员工的工作效率和创新能力，增强竞争优势，并实现可持续发展。","type":"text/markdown","created":"20230621094558102","creator":"oeyoews","modified":"20230726045248433","modifier":"oeyoews"},{"title":"社会工程学","text":"社会工程学，又称社会工程或社会工程攻击，是一种信息安全领域的术语，用来描述一种攻击技巧，其中攻击者试图欺骗、欺诈或操纵人类，以获取敏感信息、访问受限资源或执行某种有害操作。社会工程学攻击通常不是基于技术漏洞，而是针对人类心理和社会工作方式的漏洞。\n\n社会工程学攻击的示例包括钓鱼攻击，其中攻击者伪装成信任的实体，以欺骗个人提供敏感信息，以及社交工程攻击，其中攻击者通过操纵人们的社会互动来实现其目标。\n\n为保护自己免受社会工程学攻击，重要的是提高信息安全意识，教育员工警惕潜在的威胁，避免轻信不明链接或提供敏感信息，以及采取安全措施，如多因素认证，以增强数据和资源的保护。","type":"text/markdown","created":"20231011113445889","creator":"Lenovo","modified":"20231011113510137","modifier":"Lenovo","tags":"名词"},{"title":"视频信息流鸦片","text":"类似于抖音这样的视频应用之所以能够让人停不下来，主要是因为它们采用了一系列心理和设计策略来吸引用户并增加他们的参与度。\r\n\r\n1. 短时视频：抖音等应用提供的视频通常都是很短的，通常只有几十秒甚至更短。这种短时视频形式让人们可以快速地观看一个又一个视频，这种连续性和即时性能够吸引人们一直浏览下去。\r\n\r\n2. 智能推荐算法：抖音等应用会使用智能推荐算法，根据用户的兴趣和行为，自动推荐相关的视频内容。这种个性化推荐能够精准地满足用户的需求，使用户感到被关注和被理解，从而保持兴趣并持续浏览。\r\n\r\n3. 上瘾性设计：抖音等应用的用户界面和设计经过精心设计，采用了一些心理上的技巧来增加用户的参与度。例如，无限滚动的界面设计让用户可以不断发现新的内容，满足好奇心和探索欲望。此外，应用还使用了一些声音、视觉和动画效果，以及互动元素，使用户更容易沉浸其中。\r\n\r\n4. 社交因素：抖音等应用注重社交互动，用户可以关注其他用户、点赞、评论和分享视频。这种社交元素增加了用户的参与感，他们希望与其他用户互动并得到认可，从而使他们保持在应用中的时间更长。\r\n\r\n5. 多样化的内容：抖音等应用提供了广泛的内容类型，涵盖了音乐、舞蹈、搞笑、美食、旅行等各种各样的主题。这种多样性使用户可以根据自己的喜好选择感兴趣的内容，避免了单调性和厌倦感。\r\n\r\n需要注意的是，这些应用的目标是尽可能地吸引用户的注意力和时间，以增加广告曝光和用户活跃度。因此，在使用此类应用时，我们应该保持适度的使用，并注意自己的时间分配，避免沉迷于其中影响生活和工作。","type":"text/markdown","created":"20230623160109743","creator":"oeyoews","modified":"20230726045248405","modifier":"oeyoews","publish":"public"},{"title":"程序员的心理疾病","text":"## 程序员的心理疾病\n\n由于程序员工作的性质，他们长期以来受到的所谓“黑客”式的“熏陶”，形成了一种行业性的心理疾病。患了这种病的人对于很多新入行的人，甚至一些外行人士造成了持续的伤害。慢慢的，这些不幸的受害者也形成了“条件反射”，进而成为了这个心理变态的系统的一部分，导致越来越多的人，越来越快的变成“怪胎”。这是一件可怕的事情，所以我觉得有必要警醒一下。\n\n这里我就简单的把我所观察到的一些症状总结一下，希望作为对于 IT 业界人士的警示，有则改之，无则加勉。也希望为遇到类似问题的新手和外行人士提供一些精神上的支持，以免他们也成为这个系统的一部分。\n\n### 无自知之明\n\n由于程序员的工作最近几年比较容易找，工资还不错，所以很多程序员往往只看到自己的肚脐眼，看不到自己在整个社会里的位置其实并不是那么的关键和重要。很多程序员除了自己会的那点东西，几乎对其它领域和事情完全不感兴趣，看不起其他人。这就是为什么我的前同事 TJ 作为一个资深的天体物理学家，在一个软件公司里面那么卑微。貌似会写点 node.js，iOS 软件的人都可以对他趾高气昂的样子，而其实这些东西的价值哪里可能跟 TJ 知道的物理知识相提并论。很多\u001c科学家其实都可以轻而易举的掌握程序员知道的那点东西，有人却认定了他们不是这个专业的，不懂我们的东西，或者故意把问题搞复杂，让他们弄不明白。\n\n其实对于一个物理学家，他心目中知识的价值是这样排序的：\n\n[![](http://www.yinwang.org/images/shelf-life.png)](http://abstrusegoose.com/531)\n\nCOBOL 在那么靠前的位置我觉得是用来搞笑的，不过你大致看到了很多 IT 技术在真正的科学家眼里的价值和它们的有效期。\n\n如果力学工程师犯了错误，飞机会坠毁；如果结构工程师犯了错误，大桥会垮塌；可是如果软件工程师犯了错误，大不了网站挂掉一小时，重启一下貌似又好了。所以所谓“软件工程师”，由于门槛太低，他们的工作严谨程度，其实是没法和力学工程，结构工程等真正的工程师相提并论的。实际上“软件工程”这个名词根本就是扯淡的，软件工程师也不能被叫做“工程师”。跟其他的工程不一样，软件工程并不是建立在科学的基础上的—计算机科学其实不是科学。\n\n### 垃圾当宝贝\n\n按照 Dijkstra 的说法，“软件工程”是穷途末路的领域，因为它的目标是：如果我不会写程序的话，怎么样才能写出程序？\n\n为了达到这个愚蠢的目的，很多人开始兜售各种像减肥药一样的东西。面向对象方法，软件“重用”，设计模式，关系式数据库，NoSQL，大数据…… 没完没了。只要是有钱人发布的东西，神马垃圾都能被吹捧上天。Facebook 给 PHP 做了个编译器，可以编译成 C++，还做了个 VM，多么了不起啊！其实那种东西就是我们在 Indiana 第一堂课就写过的，只不过我们是把比 PHP 好很多的语言翻译成 C。我们根本不想给 PHP 那么垃圾的语言做什么编译器，让垃圾继续存活下去并不能证明我们的价值。\n\n其实软件里面有少数永恒的珍宝，可惜很少有人理解和尊重它们的价值。这在其它的工程领域看来是不可思议的，然而这却是事实。由于没有科学作为理论的基础，没有实验作为检验它们的标准，软件行业的很多东西就像现代艺术一样，丑陋无比的垃圾还能摆在外表堂皇的“现代艺术博物馆”里面，被人当成传世大作一样膜拜。\n\n为了凸显自己根本不存在的价值，又提出一些新的“理念”，就像有些现代艺术家一样，说“艺术的目的不是为了美，而是为了自由。”哦，这就是为什么你们可以自由地把那些让人反胃的东西放在博物馆里，还要买门票才能参观？\n\n### 宗教斗争\n\n当然了因为没有实质的技术，为了争夺市场和利益，各种软件的理念就开始互相倾轧。一会儿说软件危机啦，面向对象方法来拯救你们！一会儿又提出设计模式。过了一会儿又有人说这些设计模式里面有些模式是“反模式”，然后又有人把函数式编程包装起来，说是面向对象编程的克星，一会儿是关系式数据库，一会儿是 NoSQL，一会儿是 web，一会儿是 cloud，一会儿又是 mobile…… 每个东西都喜欢把自己说成是未来的希望。\n\n这就是为什么有人说在软件行业里需要不停地“学习”，因为不断地有人为了制造新的理念而制造新的理念。在这样一个行业里，你会很难找到一个只把程序语言或者技术当成是工具的人。如果有人问你对某个语言或者技术的评价，是非常尴尬甚至危险的事情，所以最可靠的办法就是不做评论，什么都不要说。\n\n[![](http://www.yinwang.org/images/bloop.png)](http://abstrusegoose.com/503)\n\n### 引难为豪\n\n在 IT 行业里批评一个技术难用，是一件非常容易伤自尊的事情，因为立马会有人噼里啪啦打出一些稀奇古怪的命令或者一大篇代码，说：就是这么简单！然后你就发现，这些人完全不明白什么叫做设计，他们以自己能用最快的速度绕过各种前人的设计失误为豪，很多程序员甚至以自己[打字快](http://www.codinghorror.com/blog/2008/11/we-are-typists-first-programmers-second.html)为豪。\n\n往往也就是这些自诩打字快的人喜欢使用过度复杂的方法来解决问题。我可以告诉你，我打字的速度是相当之慢的。我大量的使用鼠标，方向键，而且把 Emacs 里最常用的功能都尽量绑到 F 功能键上，这样我就可以用一个指头启动一个功能。Dan Friedman 的打字速度就更慢，而且他经常故意使用“一指禅”。为什么呢？因为我们写出来的代码非常精辟，几乎不带多余的垃圾，所以根本不需要打很快。\n\n当遇到这样引难为豪的人，我的经验是，千万不要恭维他们。你必须嘲笑这些东西的设计，并且指出它们的失误之处，否则你不但助长了这些人的气焰，让这种风气继续延续下去，而且将来自己的自尊也难保了。很可惜，并不是每个人都有这种勇气把这些话说出来，这就造成了今天的局面，纷繁复杂的垃圾充斥着世界。\n\n爱因斯坦说，你需要很多的天才和非常大的勇气，才能追求到简单。非常大的勇气…… 也许就是这个意思。\n\n### 去读文档！\n\n不知从什么时候开始，人们开始引用 Eric Raymond 的一篇叫做《提问的艺术》的文章，这篇文章后来就成为了对提问者没礼貌的借口。由于这篇文章的误导，当你希望同事能给你一个\u001c手把手的演示的时候，他们往往会丢给你一篇不知道什么时候写的文档，让你自己去读，仿佛文档就可以代替人之间的直接互动。况且不说这文档可能已经过时，里面有很多地方已经不符合最新的设计，而这意味着在潜意识里，他们觉得高你一等。\n\n对于这种现象有一个专门的词汇，叫做 RTFM（Read The Fucking Manual）：\n\n[![](http://www.yinwang.org/images/the_fucking_manual.png)](http://abstrusegoose.com/227)\n\n在 IRC 的聊天室里，由于隔着网络的屏障，这种对提问者没礼貌的现象就更加嚣张。我曾经有几次去 Java 的聊天室问一些貌似基础，而其实很深入的语言设计问题，结果没有一次不是以收到像“去读 API！”这样的回答而结束。API 谁不会读，然而我需要的是一个有血有肉的人对此的理解。所以后来我根本不去 IRC 这种地方了，因为那里面对你打字的基本上已经不是人类了。他们觉得你问问题浪费了他们的时间，好像他们一天到晚泡在 IRC 里面就是在做什么正事似的。不想回答问题，不开口还不行吗。后来你发现，原来在 IRC 里面训斥新手就是这些人唯一的乐趣，所以其实他们是非开口说话不可的。然而这次他们遇到的却不是个新手，而是一个可以把 Java 整个造出来的人。\n\n像 Haskell 之类的聊天室貌似稍微友好一点，然而后来你发现他们显得友好是有所企图的。因为当时 Haskell 还没有很多人用，他们需要吸引新手，所以竭尽所能的诱导他们。而一旦它用户稍微多了一点，有声势了，就有人开始居高临下，成为专家一样的人物。他们就开始写书，然后就开始牛气哄哄的了。然后你就会发现当对 Haskell 的设计提出异议的时候，这些“id”们是多么的不友好，有理也说不清。所以最后你发现，其实所有语言的所谓“社区”都一个德行。如果 Haskell 有一天像 Java 一样如日中天（当然不大可能），肯定对大部分问题的答案也就是“去读 API！”其实它已经在向这一步发展了。\n\n不得不指出，《提问的艺术》等介绍“黑客文化”的文章对于这种现象的出现有着极大的责任。说穿了，写这些文章的人一般都是 Unix 的跟屁虫。这种文章试图抹去人类文明几千年来传承的文化，而重新给“礼貌”做出定义。其结果是，人类的文明因为这些文章，在程序员的世界里倒退了几十甚至几百年。很多外行人人不喜欢跟程序员说话，叫他们是 nerd，就是这个原因。\n\n[![](http://www.yinwang.org/images/the_DARPA_conspiracy.png)](http://abstrusegoose.com/416)\n\n### 不要提问，不要谦虚，不要恭维\n\n跟上面的症状相似，程序员世界里的一条重要的潜规则是：只有菜鸟才会问问题。所以如果你有任何机会可以自己得到答案，就不要试图向人“请教”，尤其不要显得好奇，否则你就会被认为是菜鸟。我有几次不耻下问的经历，最后导致了我被人当成菜鸟。我只是觉得那问题有趣，也许能够启发我设计自己的东西，所以吃饭时觉得是个话题可以说一下，结果呢就有人忙着鄙视你，那么小的问题都没搞清楚。正确的态度应该是诚实，直接，见惯不惊，那有什么大不了的，我什么没见过，我很怀疑。\n\n随之而来的引论就是：不要谦虚！那些“职场经验”之类的文章告诉你的进入新的公司工作，要谦虚好问，对 IT 公司是不管用的。有的大 IT 公司有所谓的“文化”，比如叫你要“humble”，其实只是用来贬低你价值的借口。他们只是想让你安于“本分”，做一些微不足道，不能发挥你才能的工作。看看那些叫你要 humble 的人，他们 humble 吗？所以跟江湖一样，在 IT 公司里面一件很重要的事情是，亮出自己的宝剑和绝招，给人下马威。介绍自己的东西一定要自豪，这就是世界上最好的，无敌的，没有其他人能做到！不能有任何保留。不要像科学家一样介绍自己技术的局限性，否则随之而来的就是有些人对你价值的怀疑和对你自信心的打击。\n\n另外要注意的是对于别人介绍的东西，不要轻易地表扬或者点头，否则有人就更有气势了。你要问这样的问题：这里面有什么新的东西吗？这个事情，另外一种技术早就能做了啊，没觉得有什么了不起。\n\n### 以语言取人\n\n你的软件是什么语言写的，告诉别人的时候是千万要小心的，不到万不得已最好不要说。因为十有八九，对方会立即在心里对你的软件的价值做出判断，光凭你用的是什么语言。\n\n很多程序员都以自己会用最近流行的一些新语言为豪，以为有了它们自己就成了更好的程序员。他们看不到，用新的语言并不能让他们成为更好的程序员。其实最厉害的程序员无论用什么语言都能写出很好的代码。在他们的头脑里其实只有一种很简单的语言，他们首先用这种语言把问题建模出来，然后根据实际需要“翻译”成最后的代码。这种在头脑里的建模过程的价值，是很难用他最后用语言的优劣来衡量的。\n\n有时候高明的程序员用一个语言并不是因为他只会用那种语言，而是其他的原因。他们的头脑里有着万变不离其宗的理念，可以让他们立即掌握几乎任何语言或者工具，所以他们对所谓的“新语言”都不以为然。可是很多人误以为他们不愿意学习“新东西”，从而从心里鄙视他们。其实计算机的世界里哪里有很多新的东西，只不过是有人给同样的东西起了很多不同的名字而已。如果连这样的程序员都不能理解你的技术，就说明你的技术设计有问题，而不是他们有问题。就像 Seymour Cray 说的，我只能理解简单的东西，如果它太复杂了，我是不能理解的。\n\n早些年的时候，大家都认为招募某种特定语言的程序员是一种浮浅的做法，很多公司看重的都是解决问题的能力。可是近些年我发现这些浮浅的做法越来越普遍。可以说现在像 Google 这样的公司面试员工的方式和态度，其实还不如八年前我的第一份国内工作。而这种现象在使用 Python，Ruby，JavaScript 等“流行语言”的公司里就更为普遍。\n\n### 跟屁虫\n\n有些程序员对新手和同事是那么的不友好，然而对大牛们拍马屁的功夫可真是出类拔萃。我刚到旧金山的几个月有时候参加一些程序语言的“meetup”，后来我发现这种 meetup 都是宗教气氛非常浓厚的地方，跟传销大会差不多。Scala 的 meetup 里面的人几乎全都对 Scala 和 Martin Odersky 顶礼膜拜，甚至把 Rod Johnson 请来说一堆胡话。Clojure 的，当然基本上把 Rich Hickey 当成神，甚至称他为“二十一世纪最重要的思想家之一”。各种 talk 总是宣扬，哇，我们用 Scala/Clojure 做出了多么了不起的东西云云，其实只不过是在向你兜售减肥药。\n\n很多人喜欢做这些新的语言和技术的“evangelist”，尽显各种马屁神功，然后就开始写书，写 blog，…… 目的就是成为这个“领域”的第一批专家。这就难怪了，再垃圾的语言也有一大批人来鼓吹。因为这些没真本事的人，随便把一个东西捧上天都有自己的好处。\n\n由于受到这些“先知”的影响，有些人开始在他们自己的公司里“布道”。比如有人在 Python 的 meetup 集会时告诉我，他试图在自己的小组里推 Python，可是一些老顽固一定要用 Java，认为 Java 才是王道。很鄙夷不高兴的样子。我并不认为 Java 是很好的语言，然而 Python 也好不到哪去。它们在我眼里只不过是临时拿来用一下的工具，可是我仍然能用它们写出一流的代码。\n\n看到这些宗教性质的聚会，我终于理解了一些地区是如何被从一个国家分裂出去，最后沦落为另外一个国家殖民地的。最早的时候，一般是派传教士过去“传经”，然后就煽动一小部分人起来造反。到后来就可以名正言顺的以“保护传教士”，“保护宗教自由”，“维持和平”等理由把军舰开到别人家门口……\n","type":"text/markdown","created":"20231030053303672","creator":"太微搜藏","modified":"20231030053303672","modifier":"太微搜藏","tags":"剪藏","url":"https://www.yinwang.org/blog-cn/2014/02/09/programmer-mental"},{"title":"笔记软件商业化","text":"笔记软件的商业化都是靠第三方云服务盈利吗?似乎是目前比较大众的做法","type":"text/markdown","created":"20231012105054058","creator":"Lenovo","modified":"20231012105158717","modifier":"Lenovo","tags":""},{"title":"类型断言","text":"在 TypeScript 中，`<>` 语法通常用于指定泛型类型参数或类型断言。\r\n\r\n1. 泛型类型参数：在泛型类型或函数的定义中，`<>` 用于指定一个或多个类型参数。示例代码如下：\r\n\r\n```typescript\r\ninterface Array<T> {\r\n  // ...\r\n}\r\n\r\nfunction identity<T>(arg: T): T {\r\n  return arg;\r\n}\r\n\r\nconst arr: Array<number> = [1, 2, 3];\r\nconst value: string = identity<string>(\"Hello\");\r\n```\r\n\r\n在上述代码中，`<>` 语法用于指定泛型类型参数 `T`。在数组接口 `Array<T>` 中，`<T>` 表示数组的元素类型为泛型类型 `T`。而在 `identity<T>` 函数中，`<T>` 表示参数和返回值的类型为泛型类型 `T`。\r\n\r\n2. 类型断言：`<>` 语法也可以用于类型断言，即告诉编译器某个表达式的具体类型。不过，从 TypeScript 1.6 版本开始，建议使用更简洁的 `as` 语法进行类型断言，而非使用 `<>`。示例代码如下：\r\n\r\n```typescript\r\nconst value: any = \"Hello, World!\";\r\nconst length: number = (value as string).length;\r\n```\r\n\r\n在上述代码中，`(value as string)` 使用 `as` 语法将 `value` 断言为 `string` 类型，并通过 `.length` 获取其长度。\r\n\r\n总结：在 TypeScript 中，`<>` 语法通常用于指定泛型类型参数或进行类型断言。然而，对于类型断言，建议使用更简洁的 `as` 语法。","type":"text/markdown","created":"20230724154957433","creator":"oeyoews","modified":"20230726045248336","modifier":"oeyoews","tags":"TypeScript"},{"title":"编程的智慧","text":"## 编程的智慧\n\n编程是一种创造性的工作，是一门艺术。精通任何一门艺术，都需要很多的练习和领悟，所以这里提出的“智慧”，并不是号称一天瘦十斤的减肥药，它并不能代替你自己的勤奋。然而由于软件行业喜欢标新立异，喜欢把简单的事情搞复杂，我希望这些文字能给迷惑中的人们指出一些正确的方向，让他们少走一些弯路，基本做到一分耕耘一分收获。\n\n### 反复推敲代码\n\n有些人喜欢炫耀自己写了多少多少万行的代码，仿佛代码的数量是衡量编程水平的标准。然而，如果你总是匆匆写出代码，却从来不回头去推敲，修改和提炼，其实是不可能提高编程水平的。你会制造出越来越多平庸甚至糟糕的代码。在这种意义上，很多人所谓的“工作经验”，跟他代码的质量其实不一定成正比。如果有几十年的工作经验，却从来不回头去提炼和反思自己的代码，那么他也许还不如一个只有一两年经验，却喜欢反复推敲，仔细领悟的人。\n\n有位文豪说得好：“看一个作家的水平，不是看他发表了多少文字，而要看他的废纸篓里扔掉了多少。” 我觉得同样的理论适用于编程。好的程序员，他们删掉的代码，比留下来的还要多很多。如果你看见一个人写了很多代码，却没有删掉多少，那他的代码一定有很多垃圾。\n\n就像文学作品一样，代码是不可能一蹴而就的。灵感似乎总是零零星星，陆陆续续到来的。任何人都不可能一笔呵成，就算再厉害的程序员，也需要经过一段时间，才能发现最简单优雅的写法。有时候你反复提炼一段代码，觉得到了顶峰，没法再改进了，可是过了几个月再回头来看，又发现好多可以改进和简化的地方。这跟写文章一模一样，回头看几个月或者几年前写的东西，你总能发现一些改进。\n\n所以如果反复提炼代码已经不再有进展，那么你可以暂时把它放下。过几个星期或者几个月再回头来看，也许就有焕然一新的灵感。这样反反复复很多次之后，你就积累起了灵感和智慧，从而能够在遇到新问题的时候直接朝正确，或者接近正确的方向前进。\n\n### 写优雅的代码\n\n人们都讨厌“面条代码”（spaghetti code），因为它就像面条一样绕来绕去，没法理清头绪。那么优雅的代码一般是什么形状的呢？经过多年的观察，我发现优雅的代码，在形状上有一些明显的特征。\n\n如果我们忽略具体的内容，从大体结构上来看，优雅的代码看起来就像是一些整整齐齐，套在一起的盒子。如果跟整理房间做一个类比，就很容易理解。如果你把所有物品都丢在一个很大的抽屉里，那么它们就会全都混在一起。你就很难整理，很难迅速的找到需要的东西。但是如果你在抽屉里再放几个小盒子，把物品分门别类放进去，那么它们就不会到处乱跑，你就可以比较容易的找到和管理它们。\n\n优雅的代码的另一个特征是，它的逻辑大体上看起来，是枝丫分明的树状结构（tree）。这是因为程序所做的几乎一切事情，都是信息的传递和分支。你可以把代码看成是一个电路，电流经过导线，分流或者汇合。如果你是这样思考的，你的代码里就会比较少出现只有一个分支的 if 语句，它看起来就会像这个样子：\n\n```plain\nif (...) {\n  if (...) {\n    ...\n  } else {\n    ...\n  }\n} else if (...) {\n  ...\n} else {\n  ...\n}\n```\n\n注意到了吗？在我的代码里面，if 语句几乎总是有两个分支。它们有可能嵌套，有多层的缩进，而且 else 分支里面有可能出现少量重复的代码。然而这样的结构，逻辑却非常严密和清晰。在后面我会告诉你为什么 if 语句最好有两个分支。\n\n### 写模块化的代码\n\n有些人吵着闹着要让程序“模块化”，结果他们的做法是把代码分部到多个文件和目录里面，然后把这些目录或者文件叫做“module”。他们甚至把这些目录分放在不同的 VCS repo 里面。结果这样的作法并没有带来合作的流畅，而是带来了许多的麻烦。这是因为他们其实并不理解什么叫做“模块”，肤浅的把代码切割开来，分放在不同的位置，其实非但不能达到模块化的目的，而且制造了不必要的麻烦。\n\n真正的模块化，并不是文本意义上的，而是逻辑意义上的。一个模块应该像一个电路芯片，它有定义良好的输入和输出。实际上一种很好的模块化方法早已经存在，它的名字叫做“函数”。每一个函数都有明确的输入（参数）和输出（返回值），同一个文件里可以包含多个函数，所以你其实根本不需要把代码分开在多个文件或者目录里面，同样可以完成代码的模块化。我可以把代码全都写在同一个文件里，却仍然是非常模块化的代码。\n\n想要达到很好的模块化，你需要做到以下几点：\n\n* 避免写太长的函数。如果发现函数太大了，就应该把它拆分成几个更小的。通常我写的函数长度都不超过 40 行。对比一下，一般笔记本电脑屏幕所能容纳的代码行数是 50 行。我可以一目了然的看见一个 40 行的函数，而不需要滚屏。只有 40 行而不是 50 行的原因是，我的眼球不转的话，最大的视角只看得到 40 行代码。\n\n  如果我看代码不转眼球的话，我就能把整片代码完整的映射到我的视觉神经里，这样就算忽然闭上眼睛，我也能看得见这段代码。我发现闭上眼睛的时候，大脑能够更加有效地处理代码，你能想象这段代码可以变成什么其它的形状。40 行并不是一个很大的限制，因为函数里面比较复杂的部分，往往早就被我提取出去，做成了更小的函数，然后从原来的函数里面调用。\n\n* 制造小的工具函数。如果你仔细观察代码，就会发现其实里面有很多的重复。这些常用的代码，不管它有多短，提取出去做成函数，都可能是会有好处的。有些帮助函数也许就只有两行，然而它们却能大大简化主要函数里面的逻辑。\n\n  有些人不喜欢使用小的函数，因为他们想避免函数调用的开销，结果他们写出几百行之大的函数。这是一种过时的观念。现代的编译器都能自动的把小的函数内联（inline）到调用它的地方，所以根本不产生函数调用，也就不会产生任何多余的开销。\n\n  同样的一些人，也爱使用宏（macro）来代替小函数，这也是一种过时的观念。在早期的 C 语言编译器里，只有宏是静态“内联”的，所以他们使用宏，其实是为了达到内联的目的。然而能否内联，其实并不是宏与函数的根本区别。宏与函数有着巨大的区别（这个我以后再讲），应该尽量避免使用宏。为了内联而使用宏，其实是滥用了宏，这会引起各种各样的麻烦，比如使程序难以理解，难以调试，容易出错等等。\n\n* 每个函数只做一件简单的事情。有些人喜欢制造一些“通用”的函数，既可以做这个又可以做那个，它的内部依据某些变量和条件，来“选择”这个函数所要做的事情。比如，你也许写出这样的函数：\n\n  ```plain\n  void foo() {\n    if (getOS().equals(\"MacOS\")) {\n      a();\n    } else {\n      b();\n    }\n    c();\n    if (getOS().equals(\"MacOS\")) {\n      d();\n    } else {\n      e();\n    }\n  }\n  ```\n\n  写这个函数的人，根据系统是否为“MacOS”来做不同的事情。你可以看出这个函数里，其实只有`c()`是两种系统共有的，而其它的`a()`, `b()`, `d()`, `e()`都属于不同的分支。\n\n  这种“复用”其实是有害的。如果一个函数可能做两种事情，它们之间共同点少于它们的不同点，那你最好就写两个不同的函数，否则这个函数的逻辑就不会很清晰，容易出现错误。其实，上面这个函数可以改写成两个函数：\n\n  ```plain\n  void fooMacOS() {\n    a();\n    c();\n    d();\n  }\n  ```\n\n  和\n\n  ```plain\n  void fooOther() {\n    b();\n    c();\n    e();\n  }\n  ```\n\n  如果你发现两件事情大部分内容相同，只有少数不同，多半时候你可以把相同的部分提取出去，做成一个辅助函数。比如，如果你有个函数是这样：\n\n  ```plain\n  void foo() {\n    a();\n    b()\n    c();\n    if (getOS().equals(\"MacOS\")) {\n      d();\n    } else {\n      e();\n    }\n  }\n  ```\n\n  其中`a()`，`b()`，`c()`都是一样的，只有`d()`和`e()`根据系统有所不同。那么你可以把`a()`，`b()`，`c()`提取出去：\n\n  ```plain\n  void preFoo() {\n    a();\n    b()\n    c();\n  ```\n\n  然后制造两个函数：\n\n  ```plain\n  void fooMacOS() {\n    preFoo();\n    d();\n  }\n  ```\n\n  和\n\n  ```plain\n  void fooOther() {\n    preFoo();\n    e();\n  }\n  ```\n\n  这样一来，我们既共享了代码，又做到了每个函数只做一件简单的事情。这样的代码，逻辑就更加清晰。\n\n* 避免使用全局变量和类成员（class member）来传递信息，尽量使用局部变量和参数。有些人写代码，经常用类成员来传递信息，就像这样：\n\n  ```plain\n   class A {\n     String x;\n\n     void findX() {\n        ...\n        x = ...;\n     }\n\n     void foo() {\n       findX();\n       ...\n       print(x);\n     }\n   }\n  ```\n\n  首先，他使用`findX()`，把一个值写入成员`x`。然后，使用`x`的值。这样，`x`就变成了`findX`和`print`之间的数据通道。由于`x`属于`class A`，这样程序就失去了模块化的结构。由于这两个函数依赖于成员 x，它们不再有明确的输入和输出，而是依赖全局的数据。`findX`和`foo`不再能够离开`class A`而存在，而且由于类成员还有可能被其他代码改变，代码变得难以理解，难以确保正确性。\n\n  如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个 class，而且更加容易理解，不易出错：\n\n  ```plain\n   String findX() {\n      ...\n      x = ...;\n      return x;\n   }\n   void foo() {\n     String x = findX();\n     print(x);\n   }\n  ```\n\n### 写可读的代码\n\n有些人以为写很多注释就可以让代码更加可读，然而却发现事与愿违。注释不但没能让代码变得可读，反而由于大量的注释充斥在代码中间，让程序变得障眼难读。而且代码的逻辑一旦修改，就会有很多的注释变得过时，需要更新。修改注释是相当大的负担，所以大量的注释，反而成为了妨碍改进代码的绊脚石。\n\n实际上，真正优雅可读的代码，是几乎不需要注释的。如果你发现需要写很多注释，那么你的代码肯定是含混晦涩，逻辑不清晰的。其实，程序语言相比自然语言，是更加强大而严谨的，它其实具有自然语言最主要的元素：主语，谓语，宾语，名词，动词，如果，那么，否则，是，不是，…… 所以如果你充分利用了程序语言的表达能力，你完全可以用程序本身来表达它到底在干什么，而不需要自然语言的辅助。\n\n有少数的时候，你也许会为了绕过其他一些代码的设计问题，采用一些违反直觉的作法。这时候你可以使用很短注释，说明为什么要写成那奇怪的样子。这样的情况应该少出现，否则这意味着整个代码的设计都有问题。\n\n如果没能合理利用程序语言提供的优势，你会发现程序还是很难懂，以至于需要写注释。所以我现在告诉你一些要点，也许可以帮助你大大减少写注释的必要：\n\n1. 使用有意义的函数和变量名字。如果你的函数和变量的名字，能够切实的描述它们的逻辑，那么你就不需要写注释来解释它在干什么。比如：\n\n   ```plain\n   // put elephant1 into fridge2\n   put(elephant1, fridge2);\n   ```\n\n   由于我的函数名`put`，加上两个有意义的变量名`elephant1`和`fridge2`，已经说明了这是在干什么（把大象放进冰箱），所以上面那句注释完全没有必要。\n\n2. 局部变量应该尽量接近使用它的地方。有些人喜欢在函数最开头定义很多局部变量，然后在下面很远的地方使用它，就像这个样子：\n\n   ```plain\n   void foo() {\n     int index = ...;\n     ...\n     ...\n     bar(index);\n     ...\n   }\n   ```\n\n   由于这中间都没有使用过`index`，也没有改变过它所依赖的数据，所以这个变量定义，其实可以挪到接近使用它的地方：\n\n   ```plain\n   void foo() {\n     ...\n     ...\n     int index = ...;\n     bar(index);\n     ...\n   }\n   ```\n\n   这样读者看到`bar(index)`，不需要向上看很远就能发现`index`是如何算出来的。而且这种短距离，可以加强读者对于这里的“计算顺序”的理解。否则如果 index 在顶上，读者可能会怀疑，它其实保存了某种会变化的数据，或者它后来又被修改过。如果 index 放在下面，读者就清楚的知道，index 并不是保存了什么可变的值，而且它算出来之后就没变过。\n\n   如果你看透了局部变量的本质——它们就是电路里的导线，那你就能更好的理解近距离的好处。变量定义离用的地方越近，导线的长度就越短。你不需要摸着一根导线，绕来绕去找很远，就能发现接收它的端口，这样的电路就更容易理解。\n\n3. 局部变量名字应该简短。这貌似跟第一点相冲突，简短的变量名怎么可能有意义呢？注意我这里说的是局部变量，因为它们处于局部，再加上第 2 点已经把它放到离使用位置尽量近的地方，所以根据上下文你就会容易知道它的意思：\n\n   比如，你有一个局部变量，表示一个操作是否成功：\n\n   ```plain\n   boolean successInDeleteFile = deleteFile(\"foo.txt\");\n   if (successInDeleteFile) {\n     ...\n   } else {\n     ...\n   }\n   ```\n\n   这个局部变量`successInDeleteFile`大可不必这么啰嗦。因为它只用过一次，而且用它的地方就在下面一行，所以读者可以轻松发现它是`deleteFile`返回的结果。如果你把它改名为`success`，其实读者根据一点上下文，也知道它表示”success in deleteFile”。所以你可以把它改成这样：\n\n   ```plain\n   boolean success = deleteFile(\"foo.txt\");\n   if (success) {\n     ...\n   } else {\n     ...\n   }\n   ```\n\n   这样的写法不但没漏掉任何有用的语义信息，而且更加易读。`successInDeleteFile`这种“[camelCase](https://en.wikipedia.org/wiki/CamelCase)”，如果超过了三个单词连在一起，其实是很碍眼的东西。所以如果你能用一个单词表示同样的意义，那当然更好。\n\n4. 不要重用局部变量。很多人写代码不喜欢定义新的局部变量，而喜欢“重用”同一个局部变量，通过反复对它们进行赋值，来表示完全不同意思。比如这样写：\n\n   ```plain\n   String msg;\n   if (...) {\n     msg = \"succeed\";\n     log.info(msg);\n   } else {\n     msg = \"failed\";\n     log.info(msg);\n   }\n   ```\n\n   虽然这样在逻辑上是没有问题的，然而却不易理解，容易混淆。变量`msg`两次被赋值，表示完全不同的两个值。它们立即被`log.info`使用，没有传递到其它地方去。这种赋值的做法，把局部变量的作用域不必要的增大，让人以为它可能在将来改变，也许会在其它地方被使用。更好的做法，其实是定义两个变量：\n\n   ```plain\n   if (...) {\n     String msg = \"succeed\";\n     log.info(msg);\n   } else {\n     String msg = \"failed\";\n     log.info(msg);\n   }\n   ```\n\n   由于这两个`msg`变量的作用域仅限于它们所处的 if 语句分支，你可以很清楚的看到这两个`msg`被使用的范围，而且知道它们之间没有任何关系。\n\n5. 把复杂的逻辑提取出去，做成“帮助函数”。有些人写的函数很长，以至于看不清楚里面的语句在干什么，所以他们误以为需要写注释。如果你仔细观察这些代码，就会发现不清晰的那片代码，往往可以被提取出去，做成一个函数，然后在原来的地方调用。由于函数有一个名字，这样你就可以使用有意义的函数名来代替注释。举一个例子：\n\n   ```plain\n   ...\n   // put elephant1 into fridge2\n   openDoor(fridge2);\n   if (\belephant1.\balive()) {\n     ...\n   } else {\n      ...\n   }\n   closeDoor(fridge2);\n   ...\n   ```\n\n   如果你把这片代码提出去定义成一个函数：\n\n   ```plain\n   void put(Elephant elephant, Fridge fridge) {\n     openDoor(fridge);\n     if (\belephant.alive()) {\n       ...\n     } else {\n        ...\n     }\n     closeDoor(fridge);\n   }\n   ```\n\n   这样原来的代码就可以改成：\n\n   ```plain\n   ...\n   put(elephant1, fridge2);\n   ...\n   ```\n\n   更加清晰，而且注释也没必要了。\n\n6. 把复杂的表达式提取出去，做成中间变量。有些人听说“函数式编程”是个好东西，也不理解它的真正含义，就在代码里大量使用嵌套的函数。像这样：\n\n   ```plain\n   Pizza pizza = makePizza(crust(salt(), butter()),\n      topping(onion(), tomato(), sausage()));\n   ```\n\n   这样的代码一行太长，而且嵌套太多，不容易看清楚。其实训练有素的函数式程序员，都知道中间变量的好处，不会盲目的使用嵌套的函数。他们会把这代码变成这样：\n\n   ```plain\n   Crust crust = crust(salt(), butter());\n   Topping topping = topping(onion(), tomato(), sausage());\n   Pizza pizza = makePizza(crust, topping);\n   ```\n\n   这样写，不但有效地控制了单行代码的长度，而且由于引入的中间变量具有“意义”，步骤清晰，变得很容易理解。\n\n7. 在合理的地方换行。对于绝大部分的程序语言，代码的逻辑是和空白字符无关的，所以你可以在几乎任何地方换行，你也可以不换行。这样的语言设计是个好东西，因为它给了程序员自由控制自己代码格式的能力。然而，它也引起了一些问题，因为很多人不知道如何合理的换行。\n\n有些人喜欢利用 IDE 的自动换行机制，编辑之后用一个热键把整个代码重新格式化一遍，IDE 就会把超过行宽限制的代码自动折行。可是这种自动这行，往往没有根据代码的逻辑来进行，不能帮助理解代码。自动换行之后可能产生这样的代码：\n\n```plain\n   if (someLongCondition1() && someLongCondition2() && someLongCondition3() &&\n     someLongCondition4()) {\n     ...\n   }\n```\n\n由于`someLongCondition4()`超过了行宽限制，被编辑器自动换到了下面一行。虽然满足了行宽限制，换行的位置却是相当任意的，它并不能帮助人理解这代码的逻辑。这几个 boolean 表达式，全都用`&&`连接，所以它们其实处于平等的地位。为了表达这一点，当需要折行的时候，你应该把每一个表达式都放到新的一行，就像这个样子：\n\n```plain\n   if (someLongCondition1() &&\n       someLongCondition2() &&\n       someLongCondition3() &&\n       someLongCondition4()) {\n     ...\n   }\n```\n\n这样每一个条件都对齐，里面的逻辑就很清楚了。再举个例子：\n\n```plain\n   log.info(\"failed to find file {} for command {}, with exception {}\", file, command,\n     exception);\n```\n\n这行因为太长，被自动折行成这个样子。`file`，`command`和`exception`本来是同一类东西，却有两个留在了第一行，最后一个被折到第二行。它就不如手动换行成这个样子：\n\n```plain\n   log.info(\"failed to find file {} for command {}, with exception {}\",\n     file, command, exception);\n```\n\n把格式字符串单独放在一行，而把它的参数一并放在另外一行，这样逻辑就更加清晰。\n\n为了避免 IDE 把这些手动调整好的换行弄乱，很多 IDE（比如 IntelliJ）的自动格式化设定里都有“保留原来的换行符”的设定。如果你发现 IDE 的换行不符合逻辑，你可以修改这些设定，然后在某些地方保留你自己的手动换行。\n\n说到这里，我必须警告你，这里所说的“不需注释，让代码自己解释自己”，并不是说要让代码看起来像某种自然语言。有个叫 Chai 的 JavaScript 测试工具，可以让你这样写代码：\n\n```plain\nexpect(foo).to.be.a('string');\nexpect(foo).to.equal('bar');\nexpect(foo).to.have.length(3);\nexpect(tea).to.have.property('flavors').with.length(3);\n```\n\n这种做法是极其错误的。程序语言本来就比自然语言简单清晰，这种写法让它看起来像自然语言的样子，反而变得复杂难懂了。\n\n### 写简单的代码\n\n程序语言都喜欢标新立异，提供这样那样的“特性”，然而有些特性其实并不是什么好东西。很多特性都经不起时间的考验，最后带来的麻烦，比解决的问题还多。很多人盲目的追求“短小”和“精悍”，或者为了显示自己头脑聪明，学得快，所以喜欢利用语言里的一些特殊构造，写出过于“聪明”，难以理解的代码。\n\n并不是语言提供什么，你就一定要把它用上的。实际上你只需要其中很小的一部分功能，就能写出优秀的代码。我一向反对“充分利用”程序语言里的所有特性。实际上，我心目中有一套最好的构造。不管语言提供了多么“神奇”的，“新”的特性，我基本都只用经过千锤百炼，我觉得值得信赖的那一套。\n\n现在针对一些有问题的语言特性，我介绍一些我自己使用的代码规范，并且讲解一下为什么它们能让代码更简单。\n\n* 避免使用自增减表达式（i++，++i，i–，–i）。这种自增减操作表达式其实是历史遗留的设计失误。它们含义蹊跷，非常容易弄错。它们把读和写这两种完全不同的操作，混淆缠绕在一起，把语义搞得乌七八糟。含有它们的表达式，结果可能取决于求值顺序，所以它可能在某种编译器下能正确运行，换一个编译器就出现离奇的错误。\n\n  其实这两个表达式完全可以分解成两步，把读和写分开：一步更新 i 的值，另外一步使用 i 的值。比如，如果你想写`foo(i++)`，你完全可以把它拆成`int t = i; i += 1; foo(t);`。如果你想写`foo(++i)`，可以拆成`i += 1; foo(i);` 拆开之后的代码，含义完全一致，却清晰很多。到底更新是在取值之前还是之后，一目了然。\n\n  有人也许以为 i++或者++i 的效率比拆开之后要高，这只是一种错觉。这些代码经过基本的编译器优化之后，生成的机器代码是完全没有区别的。自增减表达式只有在两种情况下才可以安全的使用。一种是在 for 循环的 update 部分，比如`for(int i = 0; i < 5; i++)`。另一种情况是写成单独的一行，比如`i++;`。这两种情况是完全没有歧义的。你需要避免其它的情况，比如用在复杂的表达式里面，比如`foo(i++)`，`foo(++i) + foo(i)`，…… 没有人应该知道，或者去追究这些是什么意思。\n\n* 永远不要省略花括号。很多语言允许你在某种情况下省略掉花括号，比如 C，Java 都允许你在 if 语句里面只有一句话的时候省略掉花括号：\n\n  咋一看少打了两个字，多好。可是这其实经常引起奇怪的问题。比如，你后来想要加一句话`action2()`到这个 if 里面，于是你就把代码改成：\n\n  ```plain\n  if (...)\n    action1();\n    action2();\n  ```\n\n  为了美观，你很小心的使用了`action1()`的缩进。咋一看它们是在一起的，所以你下意识里以为它们只会在 if 的条件为真的时候执行，然而`action2()`却其实在 if 外面，它会被无条件的执行。我把这种现象叫做“光学幻觉”（optical illusion），理论上每个程序员都应该发现这个错误，然而实际上却容易被忽视。\n\n  那么你问，谁会这么傻，我在加入`action2()`的时候加上花括号不就行了？可是从设计的角度来看，这样其实并不是合理的作法。首先，也许你以后又想把`action2()`去掉，这样你为了样式一致，又得把花括号拿掉，烦不烦啊？其次，这使得代码样式不一致，有的 if 有花括号，有的又没有。况且，你为什么需要记住这个规则？如果你不问三七二十一，只要是 if-else 语句，把花括号全都打上，就可以想都不用想了，就当 C 和 Java 没提供给你这个特殊写法。这样就可以保持完全的一致性，减少不必要的思考。\n\n  有人可能会说，全都打上花括号，只有一句话也打上，多碍眼啊？然而经过实行这种编码规范几年之后，我并没有发现这种写法更加碍眼，反而由于花括号的存在，使得代码界限明确，让我的眼睛负担更小了。\n\n* 合理使用括号，不要盲目依赖操作符优先级。利用操作符的优先级来减少括号，对于`1 + 2 * 3`这样常见的算数表达式，是没问题的。然而有些人如此的仇恨括号，以至于他们会写出`2 << 7 - 2 * 3`这样的表达式，而完全不用括号。\n\n  这里的问题，在于移位操作`<<`的优先级，是很多人不熟悉，而且是违反常理的。由于`x << 1`相当于把`x`乘以 2，很多人误以为这个表达式相当于`(2 << 7) - (2 * 3)`，所以等于 250。然而实际上`<<`的优先级比加法`+`还要低，所以这表达式其实相当于`2 << (7 - 2 * 3)`，所以等于 4！\n\n  解决这个问题的办法，不是要每个人去把操作符优先级表给硬背下来，而是合理的加入括号。比如上面的例子，最好直接加上括号写成`2 << (7 - 2 * 3)`。虽然没有括号也表示同样的意思，但是加上括号就更加清晰，读者不再需要死记`<<`的优先级就能理解代码。\n\n* 避免使用 continue 和 break。循环语句（for，while）里面出现 return 是没问题的，然而如果你使用了 continue 或者 break，就会让循环的逻辑和终止条件变得复杂，难以确保正确。\n\n  出现 continue 或者 break 的原因，往往是对循环的逻辑没有想清楚。如果你考虑周全了，应该是几乎不需要 continue 或者 break 的。如果你的循环里出现了 continue 或者 break，你就应该考虑改写这个循环。改写循环的办法有多种：\n\n  1. 如果出现了 continue，你往往只需要把 continue 的条件反向，就可以消除 continue。\n  2. 如果出现了 break，你往往可以把 break 的条件，合并到循环头部的终止条件里，从而去掉 break。\n  3. 有时候你可以把 break 替换成 return，从而去掉 break。\n  4. 如果以上都失败了，你也许可以把循环里面复杂的部分提取出来，做成函数调用，之后 continue 或者 break 就可以去掉了。\n\n  下面我对这些情况举一些例子。\n\n  情况 1：下面这段代码里面有一个 continue：\n\n  ```plain\n  List<String> goodNames = new ArrayList<>();\n  for (String name: names) {\n    if (name.contains(\"bad\")) {\n      continue;\n    }\n    goodNames.add(name);\n    ...\n  }  \n  ```\n\n  它说：“如果 name 含有’bad’这个词，跳过后面的循环代码……” 注意，这是一种“负面”的描述，它不是在告诉你什么时候“做”一件事，而是在告诉你什么时候“不做”一件事。为了知道它到底在干什么，你必须搞清楚 continue 会导致哪些语句被跳过了，然后脑子里把逻辑反个向，你才能知道它到底想做什么。这就是为什么含有 continue 和 break 的循环不容易理解，它们依靠“控制流”来描述“不做什么”，“跳过什么”，结果到最后你也没搞清楚它到底“要做什么”。\n\n  其实，我们只需要把 continue 的条件反向，这段代码就可以很容易的被转换成等价的，不含 continue 的代码：\n\n  ```plain\n  List<String> goodNames = new ArrayList<>();\n  for (String name: names) {\n    if (!name.contains(\"bad\")) {\n      goodNames.add(name);\n      ...\n    }\n  }  \n  ```\n\n  `goodNames.add(name);`和它之后的代码全部被放到了 if 里面，多了一层缩进，然而 continue 却没有了。你再读这段代码，就会发现更加清晰。因为它是一种更加“正面”地描述。它说：“在 name 不含有’bad’这个词的时候，把它加到 goodNames 的链表里面……”\n\n  情况 2：for 和 while 头部都有一个循环的“终止条件”，那本来应该是这个循环唯一的退出条件。如果你在循环中间有 break，它其实给这个循环增加了一个退出条件。你往往只需要把这个条件合并到循环头部，就可以去掉 break。\n\n  比如下面这段代码：\n\n  ```plain\n  while (condition1) {\n    ...\n    if (condition2) {\n      break;\n    }\n  }\n  ```\n\n  当 condition 成立的时候，break 会退出循环。其实你只需要把 condition2 反转之后，放到 while 头部的终止条件，就可以去掉这种 break 语句。改写后的代码如下：\n\n  ```plain\n  while (condition1 && !condition2) {\n    ...\n  }\n  ```\n\n  这种情况表面上貌似只适用于 break 出现在循环开头或者末尾的时候，然而其实大部分时候，break 都可以通过某种方式，移动到循环的开头或者末尾。具体的例子我暂时没有，等出现的时候再加进来。\n\n  情况 3：很多 break 退出循环之后，其实接下来就是一个 return。这种 break 往往可以直接换成 return。比如下面这个例子：\n\n  ```plain\n  public boolean hasBadName(List<String> names) {\n      boolean result = false;\n\n      for (String name: names) {\n          if (name.contains(\"bad\")) {\n              result = true;\n              break;\n          }\n      }\n      return result;\n  }\n  ```\n\n  这个函数检查 names 链表里是否存在一个名字，包含“bad”这个词。它的循环里包含一个 break 语句。这个函数可以被改写成：\n\n  ```plain\n  public boolean hasBadName(List<String> names) {\n      for (String name: names) {\n          if (name.contains(\"bad\")) {\n              return true;\n          }\n      }\n      return false;\n  }\n  ```\n\n  改进后的代码，在 name 里面含有“bad”的时候，直接用`return true`返回，而不是对 result 变量赋值，break 出去，最后才返回。如果循环结束了还没有 return，那就返回 false，表示没有找到这样的名字。使用 return 来代替 break，这样 break 语句和 result 这个变量，都一并被消除掉了。\n\n  我曾经见过很多其他使用 continue 和 break 的例子，几乎无一例外的可以被消除掉，变换后的代码变得清晰很多。我的经验是，99%的 break 和 continue，都可以通过替换成 return 语句，或者翻转 if 条件的方式来消除掉。剩下的 1%含有复杂的逻辑，但也可以通过提取一个帮助函数来消除掉。修改之后的代码变得容易理解，容易确保正确。\n\n### 写直观的代码\n\n我写代码有一条重要的原则：如果有更加直接，更加清晰的写法，就选择它，即使它看起来更长，更笨，也一样选择它。比如，Unix 命令行有一种“巧妙”的写法是这样：\n\n```plain\ncommand1 && command2 && command3\n```\n\n由于 Shell 语言的逻辑操作`a && b`具有“短路”的特性，如果`a`等于 false，那么`b`就没必要执行了。这就是为什么当 command1 成功，才会执行 command2，当 command2 成功，才会执行 command3。同样，\n\n```plain\ncommand1 || command2 || command3\n```\n\n操作符`||`也有类似的特性。上面这个命令行，如果 command1 成功，那么 command2 和 command3 都不会被执行。如果 command1 失败，command2 成功，那么 command3 就不会被执行。\n\n这比起用 if 语句来判断失败，似乎更加巧妙和简洁，所以有人就借鉴了这种方式，在程序的代码里也使用这种方式。比如他们可能会写这样的代码：\n\n```plain\nif (action1() || action2() && action3()) {\n  ...\n}\n```\n\n你看得出来这代码是想干什么吗？action2 和 action3 什么条件下执行，什么条件下不执行？也许稍微想一下，你知道它在干什么：“如果 action1 失败了，执行 action2，如果 action2 成功了，执行 action3”。然而那种语义，并不是直接的“映射”在这代码上面的。比如“失败”这个词，对应了代码里的哪一个字呢？你找不出来，因为它包含在了`||`的语义里面，你需要知道`||`的短路特性，以及逻辑或的语义才能知道这里面在说“如果 action1 失败……”。每一次看到这行代码，你都需要思考一下，这样积累起来的负荷，就会让人很累。\n\n其实，这种写法是滥用了逻辑操作`&&`和`||`的短路特性。这两个操作符可能不执行右边的表达式，原因是为了机器的执行效率，而不是为了给人提供这种“巧妙”的用法。这两个操作符的本意，只是作为逻辑操作，它们并不是拿来给你代替 if 语句的。也就是说，它们只是碰巧可以达到某些 if 语句的效果，但你不应该因此就用它来代替 if 语句。如果你这样做了，就会让代码晦涩难懂。\n\n上面的代码写成笨一点的办法，就会清晰很多：\n\n```plain\nif (!action1()) {\n  if (action2()) {\n    action3();\n  }\n}\n```\n\n这里我很明显的看出这代码在说什么，想都不用想：如果 action1()失败了，那么执行 action2()，如果 action2()成功了，执行 action3()。你发现这里面的一一对应关系吗？`if`=如果，`!`=失败，…… 你不需要利用逻辑学知识，就知道它在说什么。\n\n### 写无懈可击的代码\n\n在之前一节里，我提到了自己写的代码里面很少出现只有一个分支的 if 语句。我写出的 if 语句，大部分都有两个分支，所以我的代码很多看起来是这个样子：\n\n```plain\nif (...) {\n  if (...) {\n    ...\n    return false;\n  } else {\n    return true;\n  }\n} else if (...) {\n  ...\n  return false;\n} else {\n  return true;\n}\n```\n\n使用这种方式，其实是为了无懈可击的处理所有可能出现的情况，避免漏掉 corner case。每个 if 语句都有两个分支的理由是：如果 if 的条件成立，你做某件事情；但是如果 if 的条件不成立，你应该知道要做什么另外的事情。不管你的 if 有没有 else，你终究是逃不掉，必须得思考这个问题的。\n\n很多人写 if 语句喜欢省略 else 的分支，因为他们觉得有些 else 分支的代码重复了。比如我的代码里，两个 else 分支都是`return true`。为了避免重复，他们省略掉那两个 else 分支，只在最后使用一个`return true`。这样，缺了 else 分支的 if 语句，控制流自动“掉下去”，到达最后的`return true`。他们的代码看起来像这个样子：\n\n```plain\nif (...) {\n  if (...) {\n    ...\n    return false;\n  }\n} else if (...) {\n  ...\n  return false;\n}\nreturn true;\n```\n\n这种写法看似更加简洁，避免了重复，然而却很容易出现疏忽和漏洞。嵌套的 if 语句省略了一些 else，依靠语句的“控制流”来处理 else 的情况，是很难正确的分析和推理的。如果你的 if 条件里使用了`&&`和`||`之类的逻辑运算，就更难看出是否涵盖了所有的情况。\n\n由于疏忽而漏掉的分支，全都会自动“掉下去”，最后返回意想不到的结果。即使你看一遍之后确信是正确的，每次读这段代码，你都不能确信它照顾了所有的情况，又得重新推理一遍。这简洁的写法，带来的是反复的，沉重的头脑开销。这就是所谓“面条代码”，因为程序的逻辑分支，不是像一棵枝叶分明的树，而是像面条一样绕来绕去。\n\n另外一种省略 else 分支的情况是这样：\n\n```plain\nString s = \"\";\nif (x < 5) {\n  s = \"ok\";\n}\n```\n\n写这段代码的人，脑子里喜欢使用一种“缺省值”的做法。`s`缺省为 null，如果 x<5，那么把它改变（mutate）成“ok”。这种写法的缺点是，当`x<5`不成立的时候，你需要往上面看，才能知道 s 的值是什么。这还是你运气好的时候，因为 s 就在上面不远。很多人写这种代码的时候，s 的初始值离判断语句有一定的距离，中间还有可能插入一些其它的逻辑和赋值操作。这样的代码，把变量改来改去的，看得人眼花，就容易出错。\n\n现在比较一下我的写法：\n\n```plain\nString s;\nif (x < 5) {\n  s = \"ok\";\n} else {\n  s = \"\";\n}\n```\n\n这种写法貌似多打了一两个字，然而它却更加清晰。这是因为我们明确的指出了`x<5`不成立的时候，s 的值是什么。它就摆在那里，它是`\"\"`（空字符串）。注意，虽然我也使用了赋值操作，然而我并没有“改变”s 的值。s 一开始的时候没有值，被赋值之后就再也没有变过。我的这种写法，通常被叫做更加“函数式”，因为我只赋值一次。\n\n如果我漏写了 else 分支，Java 编译器是不会放过我的。它会抱怨：“在某个分支，s 没有被初始化。”这就强迫我清清楚楚的设定各种条件下 s 的值，不漏掉任何一种情况。\n\n当然，由于这个情况比较简单，你还可以把它写成这样：\n\n```plain\nString s = x < 5 ? \"ok\" : \"\";\n```\n\n对于更加复杂的情况，我建议还是写成 if 语句为好。\n\n### 正确处理错误\n\n使用有两个分支的 if 语句，只是我的代码可以达到无懈可击的其中一个原因。这样写 if 语句的思路，其实包含了使代码可靠的一种通用思想：穷举所有的情况，不漏掉任何一个。\n\n程序的绝大部分功能，是进行信息处理。从一堆纷繁复杂，模棱两可的信息中，排除掉绝大部分“干扰信息”，找到自己需要的那一个。正确地对所有的“可能性”进行推理，就是写出无懈可击代码的核心思想。这一节我来讲一讲，如何把这种思想用在错误处理上。\n\n错误处理是一个古老的问题，可是经过了几十年，还是很多人没搞明白。Unix 的系统 API 手册，一般都会告诉你可能出现的返回值和错误信息。比如，Linux 的[read](http://man7.org/linux/man-pages/man2/read.2.html)系统调用手册里面有如下内容：\n\n```plain\nRETURN VALUE \nOn success, the number of bytes read is returned...\n\nOn error, -1 is returned, and errno is set appropriately.\n\nERRORS\n\nEAGAIN, EBADF, EFAULT, EINTR, EINVAL, ...\n```\n\n很多初学者，都会忘记检查`read`的返回值是否为-1，觉得每次调用`read`都得检查返回值真繁琐，不检查貌似也相安无事。这种想法其实是很危险的。如果函数的返回值告诉你，要么返回一个正数，表示读到的数据长度，要么返回-1，那么你就必须要对这个-1 作出相应的，有意义的处理。千万不要以为你可以忽视这个特殊的返回值，因为它是一种“可能性”。代码漏掉任何一种可能出现的情况，都可能产生意想不到的灾难性结果。\n\n对于 Java 来说，这相对方便一些。Java 的函数如果出现问题，一般通过异常（exception）来表示。你可以把异常加上函数本来的返回值，看成是一个“union 类型”。比如：\n\n```plain\nString foo() throws MyException {\n  ...\n}\n```\n\n这里 MyException 是一个错误返回。你可以认为这个函数返回一个 union 类型：`{String, MyException}`。任何调用`foo`的代码，必须对 MyException 作出合理的处理，才有可能确保程序的正确运行。Union 类型是一种相当先进的类型，目前只有极少数语言（比如 Typed Racket）具有这种类型，我在这里提到它，只是为了方便解释概念。掌握了概念之后，你其实可以在头脑里实现一个 union 类型系统，这样使用普通的语言也能写出可靠的代码。\n\n由于 Java 的类型系统强制要求函数在类型里面声明可能出现的异常，而且强制调用者处理可能出现的异常，所以基本上不可能出现由于疏忽而漏掉的情况。但有些 Java 程序员有一种恶习，使得这种安全机制几乎完全失效。每当编译器报错，说“你没有 catch 这个 foo 函数可能出现的异常”时，有些人想都不想，直接把代码改成这样：\n\n```plain\ntry {\n  foo();\n} catch (Exception e) {}\n```\n\n或者最多在里面放个 log，或者干脆把自己的函数类型上加上`throws Exception`，这样编译器就不再抱怨。这些做法貌似很省事，然而都是错误的，你终究会为此付出代价。\n\n如果你把异常 catch 了，忽略掉，那么你就不知道 foo 其实失败了。这就像开车时看到路口写着“前方施工，道路关闭”，还继续往前开。这当然迟早会出问题，因为你根本不知道自己在干什么。\n\ncatch 异常的时候，你不应该使用 Exception 这么宽泛的类型。你应该正好 catch 可能发生的那种异常 A。使用宽泛的异常类型有很大的问题，因为它会不经意的 catch 住另外的异常（比如 B）。你的代码逻辑是基于判断 A 是否出现，可你却 catch 所有的异常（Exception 类），所以当其它的异常 B 出现的时候，你的代码就会出现莫名其妙的问题，因为你以为 A 出现了，而其实它没有。这种 bug，有时候甚至使用 debugger 都难以发现。\n\n如果你在自己函数的类型加上`throws Exception`，那么你就不可避免的需要在调用它的地方处理这个异常，如果调用它的函数也写着`throws Exception`，这毛病就传得更远。我的经验是，尽量在异常出现的当时就作出处理。否则如果你把它返回给你的调用者，它也许根本不知道该怎么办了。\n\n另外，try { …… } catch 里面，应该包含尽量少的代码。比如，如果`foo`和`bar`都可能产生异常 A，你的代码应该尽可能写成：\n\n```plain\ntry {\n  foo();\n} catch (A e) {...}\n\ntry {\n  bar();\n} catch (A e) {...}\n```\n\n而不是\n\n```plain\ntry {\n  foo();\n  bar();\n} catch (A e) {...}\n```\n\n第一种写法能明确的分辨是哪一个函数出了问题，而第二种写法全都混在一起。明确的分辨是哪一个函数出了问题，有很多的好处。比如，如果你的 catch 代码里面包含 log，它可以提供给你更加精确的错误信息，这样会大大地加速你的调试过程。\n\n### 正确处理 null 指针\n\n穷举的思想是如此的有用，依据这个原理，我们可以推出一些基本原则，它们可以让你无懈可击的处理 null 指针。\n\n首先你应该知道，许多语言（C，C++，Java，C#，……）的类型系统对于 null 的处理，其实是完全错误的。这个错误源自于[Tony Hoare](https://en.wikipedia.org/wiki/Tony_Hoare)最早的设计，Hoare 把这个错误称为自己的“[billion dollar mistake](http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)”，因为由于它所产生的财产和人力损失，远远超过十亿美元。\n\n这些语言的类型系统允许 null 出现在任何对象（指针）类型可以出现的地方，然而 null 其实根本不是一个合法的对象。它不是一个 String，不是一个 Integer，也不是一个自定义的类。null 的类型本来应该是 NULL，也就是 null 自己。根据这个基本观点，我们推导出以下原则：\n\n* 尽量不要产生 null 指针。尽量不要用 null 来初始化变量，函数尽量不要返回 null。如果你的函数要返回“没有”，“出错了”之类的结果，尽量使用 Java 的异常机制。虽然写法上有点别扭，然而 Java 的异常，和函数的返回值合并在一起，基本上可以当成 union 类型来用。比如，如果你有一个函数 find，可以帮你找到一个 String，也有可能什么也找不到，你可以这样写：\n\n  ```plain\n  public String find() throws NotFoundException {\n    if (...) {\n      return ...;\n    } else {\n      throw new NotFoundException();\n    }\n  }\n  ```\n\n  Java 的类型系统会强制你 catch 这个 NotFoundException，所以你不可能像漏掉检查 null 一样，漏掉这种情况。Java 的异常也是一个比较容易滥用的东西，不过我已经在上一节告诉你如何正确的使用异常。\n\n  Java 的 try……catch 语法相当的繁琐和蹩脚，所以如果你足够小心的话，像`find`这类函数，也可以返回 null 来表示“没找到”。这样稍微好看一些，因为你调用的时候不必用 try……catch。很多人写的函数，返回 null 来表示“出错了”，这其实是对 null 的误用。“出错了”和“没有”，其实完全是两码事。“没有”是一种很常见，正常的情况，比如查哈希表没找到，很正常。“出错了”则表示罕见的情况，本来正常情况下都应该存在有意义的值，偶然出了问题。如果你的函数要表示“出错了”，应该使用异常，而不是 null。\n\n* 不要 catch NullPointerException。有些人写代码很 nice，他们喜欢“容错”。首先他们写一些函数，这些函数里面不大小心，没检查 null 指针：\n\n  ```plain\n  void foo() {\n    String found = find();\n    int len = found.length();\n    ...\n  }\n  ```\n\n  当 foo 调用产生了异常，他们不管三七二十一，就把调用的地方改成这样：\n\n  ```plain\n  try {\n    foo();\n  } catch (Exception e) {\n    ...\n  }\n  ```\n\n  这样当 found 是 null 的时候，NullPointerException 就会被捕获并且得到处理。这其实是很错误的作法。首先，上一节已经提到了，`catch (Exception e)`这种写法是要绝对避免的，因为它捕获所有的异常，包括 NullPointerException。这会让你意外地捕获 try 语句里面出现的 NullPointerException，从而把代码的逻辑搅得一塌糊涂。\n\n  另外就算你写成`catch (NullPointerException e)`也是不可以的。由于 foo 的内部缺少了 null 检查，才出现了 NullPointerException。现在你不对症下药，倒把每个调用它的地方加上 catch，以后你的生活就会越来越苦。正确的做法应该是改动 foo，而不改调用它的代码。foo 应该被改成这样：\n\n  ```plain\n  void foo() {\n    String found = find();\n    if (found != null) {\n      int len = found.length();\n      ...\n    } else {\n      ...\n    }\n  }\n  ```\n\n  在 null 可能出现的当时就检查它是否是 null，然后进行相应的处理。\n\n* 不要把 null 放进“容器数据结构”里面。所谓容器（collection），是指一些对象以某种方式集合在一起，所以 null 不应该被放进 Array，List，Set 等结构，不应该出现在 Map 的 key 或者 value 里面。把 null 放进容器里面，是一些莫名其妙错误的来源。因为对象在容器里的位置一般是动态决定的，所以一旦 null 从某个入口跑进去了，你就很难再搞明白它去了哪里，你就得被迫在所有从这个容器里取值的位置检查 null。你也很难知道到底是谁把它放进去的，代码多了就导致调试极其困难。\n\n  解决方案是：如果你真要表示“没有”，那你就干脆不要把它放进去（Array，List，Set 没有元素，Map 根本没那个 entry），或者你可以指定一个特殊的，真正合法的对象，用来表示“没有”。\n\n  需要指出的是，类对象并不属于容器。所以 null 在必要的时候，可以作为对象成员的值，表示它不存在。比如：\n\n  ```plain\n  class A {\n    String name = null;\n    ...\n  }\n  ```\n\n  之所以可以这样，是因为 null 只可能在 A 对象的 name 成员里出现，你不用怀疑其它的成员因此成为 null。所以你每次访问 name 成员时，检查它是否是 null 就可以了，不需要对其他成员也做同样的检查。\n\n* 函数调用者：明确理解 null 所表示的意义，尽早检查和处理 null 返回值，减少它的传播。null 很讨厌的一个地方，在于它在不同的地方可能表示不同的意义。有时候它表示“没有”，“没找到”。有时候它表示“出错了”，“失败了”。有时候它甚至可以表示“成功了”，…… 这其中有很多误用之处，不过无论如何，你必须理解每一个 null 的意义，不能给混淆起来。\n\n  如果你调用的函数有可能返回 null，那么你应该在第一时间对 null 做出“有意义”的处理。比如，上述的函数`find`，返回 null 表示“没找到”，那么调用`find`的代码就应该在它返回的第一时间，检查返回值是否是 null，并且对“没找到”这种情况，作出有意义的处理。\n\n  “有意义”是什么意思呢？我的意思是，使用这函数的人，应该明确的知道在拿到 null 的情况下该怎么做，承担起责任来。他不应该只是“向上级汇报”，把责任踢给自己的调用者。如果你违反了这一点，就有可能采用一种不负责任，危险的写法：\n\n  ```plain\n  public String foo() {\n    String found = find();\n    if (found == null) {\n      return null;\n    }\n  }\n  ```\n\n  当看到 find()返回了 null，foo 自己也返回 null。这样 null 就从一个地方，游走到了另一个地方，而且它表示另外一个意思。如果你不假思索就写出这样的代码，最后的结果就是代码里面随时随地都可能出现 null。到后来为了保护自己，你的每个函数都会写成这样：\n\n  ```plain\n  public void foo(A a, B b, C c) {\n    if (a == null) { ... }\n    if (b == null) { ... }\n    if (c == null) { ... }\n    ...\n  }\n  ```\n\n* 函数作者：明确声明不接受 null 参数，当参数是 null 时立即崩溃。不要试图对 null 进行“容错”，不要让程序继续往下执行。如果调用者使用了 null 作为参数，那么调用者（而不是函数作者）应该对程序的崩溃负全责。\n\n  上面的例子之所以成为问题，就在于人们对于 null 的“容忍态度”。这种“保护式”的写法，试图“容错”，试图“优雅的处理 null”，其结果是让调用者更加肆无忌惮的传递 null 给你的函数。到后来，你的代码里出现一堆堆 nonsense 的情况，null 可以在任何地方出现，都不知道到底是哪里产生出来的。谁也不知道出现了 null 是什么意思，该做什么，所有人都把 null 踢给其他人。最后这 null 像瘟疫一样蔓延开来，到处都是，成为一场噩梦。\n\n  正确的做法，其实是强硬的态度。你要告诉函数的使用者，我的参数全都不能是 null，如果你给我 null，程序崩溃了该你自己负责。至于调用者代码里有 null 怎么办，他自己该知道怎么处理（参考以上几条），不应该由函数作者来操心。\n\n  采用强硬态度一个很简单的做法是使用`Objects.requireNonNull()`。它的定义很简单：\n\n  ```plain\n  public static <T> T requireNonNull(T obj) {\n    if (obj == null) {\n      throw new NullPointerException();\n    } else {\n      return obj;\n    }\n  }\n  ```\n\n  你可以用这个函数来检查不想接受 null 的每一个参数，只要传进来的参数是 null，就会立即触发`NullPointerException`崩溃掉，这样你就可以有效地防止 null 指针不知不觉传递到其它地方去。\n\n* 使用@NotNull 和@Nullable 标记。IntelliJ 提供了@NotNull 和@Nullable 两种标记，加在类型前面，这样可以比较简洁可靠地防止 null 指针的出现。IntelliJ 本身会对含有这种标记的代码进行静态分析，指出运行时可能出现`NullPointerException`的地方。在运行时，会在 null 指针不该出现的地方产生`IllegalArgumentException`，即使那个 null 指针你从来没有 deference。这样你可以在尽量早期发现并且防止 null 指针的出现。\n\n* 使用 Optional 类型。Java 8 和 Swift 之类的语言，提供了一种叫 Optional 的类型。正确的使用这种类型，可以在很大程度上避免 null 的问题。null 指针的问题之所以存在，是因为你可以在没有“检查”null 的情况下，“访问”对象的成员。\n\n  Optional 类型的设计原理，就是把“检查”和“访问”这两个操作合二为一，成为一个“原子操作”。这样你没法只访问，而不进行检查。这种做法其实是 ML，Haskell 等语言里的模式匹配（pattern matching）的一个特例。模式匹配使得类型判断和访问成员这两种操作合二为一，所以你没法犯错。\n\n  比如，在 Swift 里面，你可以这样写：\n\n  ```plain\n  let found = find()\n  if let content = found {\n    print(\"found: \" + content)\n  }\n  ```\n\n  你从`find()`函数得到一个 Optional 类型的值`found`。假设它的类型是`String?`，那个问号表示它可能包含一个 String，也可能是 nil。然后你就可以用一种特殊的 if 语句，同时进行 null 检查和访问其中的内容。这个 if 语句跟普通的 if 语句不一样，它的条件不是一个 Bool，而是一个变量绑定`let content = found`。\n\n  我不是很喜欢这语法，不过这整个语句的含义是：如果 found 是 nil，那么整个 if 语句被略过。如果它不是 nil，那么变量 content 被绑定到 found 里面的值（unwrap 操作），然后执行`print(\"found: \" + content)`。由于这种写法把检查和访问合并在了一起，你没法只进行访问而不检查。\n\n  Java 8 的做法比较蹩脚一些。如果你得到一个 `Optional<String>`类型的值 found，你必须使用“函数式编程”的方式，来写这之后的代码：\n\n  ```plain\n  Optional<String> found = find();\n  found.ifPresent(content -> System.out.println(\"found: \" + content));\n  ```\n\n  这段 Java 代码跟上面的 Swift 代码等价，它包含一个“判断”和一个“取值”操作。ifPresent 先判断 found 是否有值（相当于判断是不是 null）。如果有，那么将其内容“绑定”到 lambda 表达式的 content 参数（unwrap 操作），然后执行 lambda 里面的内容，否则如果 found 没有内容，那么 ifPresent 里面的 lambda 不执行。\n\n  Java 的这种设计有个问题。判断 null 之后分支里的内容，全都得写在 lambda 里面。在函数式编程里，这个 lambda 叫做“[continuation](https://en.wikipedia.org/wiki/Continuation)”，Java 把它叫做 “[Consumer](https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html)”，它表示“如果 found 不是 null，拿到它的值，然后应该做什么”。由于 lambda 是个函数，你不能在里面写`return`语句返回出外层的函数。比如，如果你要改写下面这个函数（含有 null）：\n\n  ```plain\n  public static String foo() {\n    String found = find();\n    if (found != null) {\n      return found;\n    } else {\n      return \"\";\n    }\n  }\n  ```\n\n  就会比较麻烦。因为如果你写成这样：\n\n  ```plain\n  public static String foo() {\n    Optional<String> found = find();\n    found.ifPresent(content -> {\n      return content;    // can't return from foo here\n    });\n    return \"\";\n  }\n  ```\n\n  里面的`return a`，并不能从函数`foo`返回出去。它只会从 lambda 返回，而且由于那个 lambda（[Consumer.accept](https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html#accept-T-)）的返回类型必须是`void`，编译器会报错，说你返回了 String。由于 Java 里 closure 的自由变量是只读的，你没法对 lambda 外面的变量进行赋值，所以你也不能采用这种写法：\n\n  ```plain\n  public static String foo() {\n    Optional<String> found = find();\n    String result = \"\";\n    found.ifPresent(content -> {\n      result = content;    // can't assign to result\n    });\n    return result;\n  }\n  ```\n\n  所以，虽然你在 lambda 里面得到了 found 的内容，如何使用这个值，如何返回一个值，却让人摸不着头脑。你平时的那些 Java 编程手法，在这里几乎完全废掉了。实际上，判断 null 之后，你必须使用 Java 8 提供的一系列古怪的[函数式编程操作](http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html)：`map`, `flatMap`, `orElse`之类，想法把它们组合起来，才能表达出原来代码的意思。比如之前的代码，只能改写成这样：\n\n  ```plain\n  public static String foo() {\n    Optional<String> found = find();\n    return found.orElse(\"\");\n  }\n  ```\n\n  这简单的情况还好。复杂一点的代码，我还真不知道怎么表达，我怀疑 Java 8 的 Optional 类型的方法，到底有没有提供足够的表达力。那里面少数几个东西表达能力不咋的，论工作原理，却可以扯到 functor，continuation，甚至 monad 等高深的理论…… 仿佛用了 Optional 之后，这语言就不再是 Java 了一样。\n\n  所以 Java 虽然提供了 Optional，但我觉得可用性其实比较低，难以被人接受。相比之下，Swift 的设计更加简单直观，接近普通的过程式编程。你只需要记住一个特殊的语法`if let content = found {...}`，里面的代码写法，跟普通的过程式语言没有任何差别。\n\n  总之你只要记住，使用 Optional 类型，要点在于“原子操作”，使得 null 检查与取值合二为一。这要求你必须使用我刚才介绍的特殊写法。如果你违反了这一原则，把检查和取值分成两步做，还是有可能犯错误。比如在 Java 8 里面，你可以使用`found.get()`这样的方式直接访问 found 里面的内容。在 Swift 里你也可以使用`found!`来直接访问而不进行检查。\n\n  你可以写这样的 Java 代码来使用 Optional 类型：\n\n  ```plain\n  Option<String> found = find();\n  if (found.isPresent()) {\n    System.out.println(\"found: \" + found.get());\n  }\n  ```\n\n  如果你使用这种方式，把检查和取值分成两步做，就可能会出现运行时错误。`if (found.isPresent())`本质上跟普通的 null 检查，其实没什么两样。如果你忘记判断`found.isPresent()`，直接进行`found.get()`，就会出现`NoSuchElementException`。这跟`NullPointerException`本质上是一回事。所以这种写法，比起普通的 null 的用法，其实换汤不换药。如果你要用 Optional 类型而得到它的益处，请务必遵循我之前介绍的“原子操作”写法。\n\n### 防止过度工程\n\n人的脑子真是奇妙的东西。虽然大家都知道过度工程（over-engineering）不好，在实际的工程中却经常不由自主的出现过度工程。我自己也犯过好多次这种错误，所以觉得有必要分析一下，过度工程出现的信号和兆头，这样可以在初期的时候就及时发现并且避免。\n\n过度工程即将出现的一个重要信号，就是当你过度的思考“将来”，考虑一些还没有发生的事情，还没有出现的需求。比如，“如果我们将来有了上百万行代码，有了几千号人，这样的工具就支持不了了”，“将来我可能需要这个功能，所以我现在就把代码写来放在那里”，“将来很多人要扩充这片代码，所以现在我们就让它变得可重用”……\n\n这就是为什么很多软件项目如此复杂。实际上没做多少事情，却为了所谓的“将来”，加入了很多不必要的复杂性。眼前的问题还没解决呢，就被“将来”给拖垮了。人们都不喜欢目光短浅的人，然而在现实的工程中，有时候你就是得看近一点，把手头的问题先搞定了，再谈以后扩展的问题。\n\n另外一种过度工程的来源，是过度的关心“代码重用”。很多人“可用”的代码还没写出来呢，就在关心“重用”。为了让代码可以重用，最后被自己搞出来的各种框架捆住手脚，最后连可用的代码就没写好。如果可用的代码都写不好，又何谈重用呢？很多一开头就考虑太多重用的工程，到后来被人完全抛弃，没人用了，因为别人发现这些代码太难懂了，自己从头开始写一个，反而省好多事。\n\n过度地关心“测试”，也会引起过度工程。有些人为了测试，把本来很简单的代码改成“方便测试”的形式，结果引入很多复杂性，以至于本来一下就能写对的代码，最后复杂不堪，出现很多 bug。\n\n世界上有两种“没有 bug”的代码。一种是“没有明显的 bug 的代码”，另一种是“明显没有 bug 的代码”。第一种情况，由于代码复杂不堪，加上很多测试，各种 coverage，貌似测试都通过了，所以就认为代码是正确的。第二种情况，由于代码简单直接，就算没写很多测试，你一眼看去就知道它不可能有 bug。你喜欢哪一种“没有 bug”的代码呢？\n\n根据这些，我总结出来的防止过度工程的原则如下：\n\n1. 先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。\n2. 先写出可用的代码，反复推敲，再考虑是否需要重用的问题。\n3. 先写出可用，简单，明显没有 bug 的代码，再考虑测试的问题。\n\n**完。**\n\n***\n\n（这不是一篇免费的文章，如果你想把这些信息留在脑子里，请去这里[付费](http://www.yinwang.org/blog-cn/2016/04/13/pay-blog)。不然就请看这里：\n\n![](https://www.yinwang.org/images/memory-eraser.jpg)\n","type":"text/markdown","created":"20231030052606836","creator":"太微搜藏","modified":"20231030052606836","modifier":"太微搜藏","tags":"剪藏","url":"https://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy"},{"title":"老人与海","text":"## 版权信息\r\n\r\n老人与海（译文经典）作者：〔美〕海明威\r\n\r\n## 插图\r\n\r\n因为它……表现了一个历经生活磨难而战无不胜的巨人。”\r\n\r\n## 《老人与海》的多层次涵义\r\n\r\n原来在海明威上一部小说《过河入林》发表后，评论家们评价不高，有的甚至很苛刻，认为他的文才已经枯竭了。\r\n\r\n本书终于使海明威获得了一九五三年度的普利策奖金，并且主要由于它的成就而荣获一九五四年度的诺贝尔文学奖。\r\n\r\n“没有什么象征主义的东西。大海就是大海，老人就是老人。男孩就是男孩，鱼就是鱼。鲨鱼就是鲨鱼……人们说什么象征主义，全是胡说。”但他又说过：“我试图描写一个真实的老人，一个真实的男孩，真实的大海，一条真实的鱼和许多真实的鲨鱼。然而，如果我能写得足够逼真的话，他们也能代表许多其他的事物。”\r\n\r\n然而人不是为失败而生的，一个人可以被毁灭，但不能给打败。\r\n\r\n亚里士多德认为：悲剧主人公“之所以陷于厄运，不是由于他为非作恶，而是由于他犯了错误”(9)。\r\n\r\n所有物质的东西，包括人在内，都是注定要毁灭的，只有人的行动，和对行动的记忆才是永存的。所以全书的末一句是：“老人正梦见狮子。”他保持着完好的对美好事物的记忆。\r\n\r\n这个朴素的故事里充满了并非故意卖弄的寓意……作为一篇干净利落的‘陈述性’散文，它在海明威的全部作品中都是无与伦比的。每一个词都有它的作用，没有一个词是多余的。\r\n\r\n为什么一个几乎什么都有的人，在获奖后不久选择了死亡，而一个几乎一无所有的渔夫，却悠然地颐养天年？这是值得引人深思的。\r\n\r\n## 老人与海\r\n\r\n他身上的一切都显得古老，除了那双眼睛，它们像海水一般蓝，显得喜洋洋而不服输。\r\n\r\n不少渔夫拿老人开玩笑，老人并不生气。另外一些上了些年纪的渔夫望着他，感到难受。\r\n\r\n“哦，”老人说。他正握着酒杯，思量好多年前的事儿。\r\n\r\n“我记得鱼尾巴砰砰地拍打着，船上的座板给打断了，还有棍子打鱼的声音。我记得你把我朝船头猛推，那儿搁着湿漉漉的钓索卷儿，我感到整条船在颤抖，听到你啪啪地用棍子打鱼的声音，像在砍倒一棵树，还记得我浑身上下都是甜丝丝的血腥味儿。”\r\n\r\n老人用他那双常遭日晒而目光坚定的眼睛爱怜地望着他。\r\n\r\n他心地单纯，不去捉摸自己什么时候达到了这样谦卑的地步。可是他知道这时正达到了这地步，知道这并不丢脸，所以也无损于真正的自尊心。\r\n\r\n“驶到远方，等转了风才回来。我想不等天亮就出发。”\r\n\r\n“我是个不同寻常的老头儿。”\r\n\r\n尽管老人深信当地不会有人来偷他的东西，但他认为，把一把鱼钩和一支鱼叉留在船上实在是不必要的引诱。\r\n\r\n在用这纤维结实的被展平的棕叶叠盖而成的褐色墙壁上，有一幅彩色的耶稣圣心图(5)和另一幅科夫莱圣母图(6)。这是他妻子的遗物。墙上一度挂着一幅他妻子的着色照，但他把它取下了，因为看了使他觉得太孤单，它如今在屋角搁板上他那件干净衬衫下面。\r\n\r\n“有什么吃的东西？”男孩问。“有锅鱼煮黄米饭。你想吃点吗？”“不。我回家去吃。要我给你生火吗？”“不用。等会儿我自己来生。也许就吃冷饭算了。”\r\n\r\n### 1\r\n\r\n实在并没有撒网，男孩还记得他们是什么时候把它卖掉的。然而他们每天都要扯一套这种谎话。也没有一锅鱼煮黄米饭，这一点男孩也知道。\r\n\r\n“相信扬基队吧，好孩子。别忘了那了不起的迪马吉奥(8)。”\r\n\r\n我看没准儿我也借得到。不过我不想借钱。第一步是借钱。下一步就要讨饭啰。”\r\n\r\n这两个肩膀挺怪，人非常老迈了，肩膀却依然很强健，脖子也依然很壮实，而且当老人睡着了、脑袋向前耷拉着的时候，皱纹也不大明显了。他的衬衫上不知打了多少次补丁，弄得像他那张帆一样，而这些补丁被阳光晒得褪成了许多深浅不同的颜色。\r\n\r\n这样的话，我该在鱼肚子肉以外，再送他一些东西。他对我们真关心\r\n\r\n不等你准备好，我是不愿打开饭匣子的。”\r\n\r\n我该为他把水带到这儿来，男孩想，还带块肥皂和一条干净毛巾。我为什么这样粗心大意？我该再给他弄件衬衫，一件过冬的茄克衫，还弄双什么鞋子，再来条毯子。\r\n\r\n“他们今儿个输了，”男孩告诉他。“这算不上什么。那了不起的迪马吉奥恢复他的本色了。”\r\n\r\n那了不起的西斯勒的爸爸(14)从没过过穷日子，而他，他爸爸，像我这个年纪就在大联赛里打球了。”\r\n\r\n我见过狮子在傍晚到海滩上来。\r\n\r\n“我们来谈非洲还是谈棒球？”\r\n\r\n“在过去的日子里，他有时候也常到露台饭店来。可是他一喝了酒，就态度粗暴，出口伤人，性子别扭。\r\n\r\n“年纪是我的闹钟，”老人说。“为什么老头儿醒得那么早？难道是要让白天长些吗？”\r\n\r\n他不再梦见风暴，不再梦见妇女们，不再梦见发生过的大事，不再梦见大鱼，不再梦见打架，不再梦见角力，不再梦见他的妻子。他如今只梦见某些地方和海滩上的狮子。它们在暮色中像小猫一般嬉耍着，他爱它们，如同爱这男孩一样。他从没梦见过这男孩。\r\n\r\n一路上，有些光着脚的男人在黑暗中走动，扛着他们船上的桅杆。\r\n\r\n喝着盛在炼乳听里的咖啡。\r\n\r\n他如今清醒过来了，尽管要他完全摆脱睡魔还不大容易。\r\n\r\n我们可不同，”老人说。“你还只五岁时我就让你帮忙拿东西来着。”\r\n\r\n好久以来，吃饭使他感到厌烦，因此从来不带午饭。他在小帆船的船头上放着一瓶水，一整天只需要这个就够了。\r\n\r\n既然海洋这样残暴，为什么像这些海燕那样的鸟儿生来就如此柔弱和纤巧？海洋是仁慈并十分美丽的。然而她能变得这样残暴，又是来得这样突然，而这些飞翔的鸟儿，从空中落下觅食，发出细微的哀鸣，却生来就柔弱得不适宜在海上生活。\r\n\r\n### 2\r\n\r\n他发现自己已经划到比预期此刻能达到的地方更远了。\r\n\r\n每条沙丁鱼都用钓钩穿过双眼，这样鱼的身子在突出的钢钩上构成了半个环形。钓钩上就没有哪一部分不会叫一条大鱼觉得喷香而美味的。\r\n\r\n[插图]鱼\r\n\r\n天相当亮了，太阳随时会升起来。\r\n\r\n每一天都是一个新的日子。走运当然更好。不过我情愿做到分毫不差。这样，运气来的时候，你就有所准备了。\r\n\r\n我这一辈子，初升的太阳老是刺痛我的眼睛\r\n\r\n就在这时，他看见一只黑色的长翅膀军舰鸟在他前方的天空中盘旋飞翔。它倏地斜着后掠的双翅俯冲，然后又盘旋起来。\r\n\r\n他并不着急，让那些钓索保持着上下笔直的位置。不过他还是挨近了一点儿海流，这样，他依然在用正确的方式捕鱼，尽管他的速度要比他不打算利用鸟儿来指路时来得快。\r\n\r\n我的大鱼总该在某处地方啊。\r\n\r\n老人喜欢观看海龟把它们吃掉，喜欢在风暴过后在海滩上遇上它们，喜欢听到自己用长着老茧的硬脚掌踩在上面时它们啪地爆裂的声音。\r\n\r\n人们大都对海龟残酷无情，因为一只海龟给剖开、杀死之后，它的心脏还要跳动好几个钟点。然而老人想，我也有这样一颗心脏，我的手脚也跟它们的一样。他吃白色的海龟蛋，为了使身子长力气。他在五月份连吃了整整一个月，使自己到九、十月份能身强力壮，去逮确实大的鱼。\r\n\r\n个转身，头朝下掉进水里。这条金枪鱼在阳光中闪出银白色的光，等它回到了水里，又有一条条金枪鱼跃出水面，它们是朝四面八方跳的，跳得很远，捕食小鱼，搅得海水翻腾起来。它们正绕着小鱼转，驱赶着小鱼。\r\n\r\n鱼躺在船梢的阳光里，身子结实，形状像颗子弹，一双痴呆的大眼睛直瞪着，动作干净利落的尾巴敏捷、发抖地拍打着船板，砰砰有声，逐渐耗尽了力气。老人出于好意，猛击了一下它的头，一脚把它那还在抖动的身子踢到船梢背阴的地方。\r\n\r\n他记不起自己什么时候开始在独自待着的当儿自言自语了。往年他独自待着时曾唱歌来着，有时候在夜里唱，那是在小渔船或捕海龟的小艇上值班掌舵时的事。他大概是在那男孩走了，才在独自待着时开始自言自语的。\r\n\r\n现在只应该思量一桩事。那就是我生来要干的事。\r\n\r\n他眼下已看不见海岸的那一道绿色了，只看得见那些青山的仿佛积着白雪的山峰，以及山峰上空像是高耸的雪山般的云块。海水颜色深极了，阳光在海水中幻成彩虹七色。\r\n\r\n我大可随波逐流，他想，管自睡去，预先把钓索在脚趾上绕上一圈，有动静时可以把我弄醒。不过今天是第八十五天，我该一整天好好钓鱼。\r\n\r\n老人轻巧地攥着钓索，用左手把它从竿子上轻轻解下。他这时可以让它穿过他手指间滑动，不会让鱼感到一点儿牵引力。\r\n\r\n吃鱼饵吧，鱼啊。吃吧。请你吃吧。这些鱼饵多新鲜，而你哪，待在这六百英尺的深处，在这漆黑的冷水里。在黑暗里再绕个弯子，拐回来把它们吃了吧。\r\n\r\n“再绕个弯子吧。闻闻这些鱼饵。它们不是挺鲜美吗？趁新鲜把它们吃了，回头还有那条金枪鱼呢。又结实，又凉快，又鲜美。别怕难为情，鱼儿。把它们吃了吧。”\r\n\r\n天知道它是不可能游走的。它正在绕弯子呐。也许它以前上过钩，还有点儿记得。”\r\n\r\n一桩好事如果说破了，也许就不会发生了\r\n\r\n吃了吧，这样可以让钓钩的尖端扎进你的心脏，把你弄死，他想。轻松愉快地浮上来吧，让我把鱼叉刺进你的身子。得了。你准备好了？你进餐的时间够长了吧？\r\n\r\n我不知道如果它决意朝下沉，我该怎么办。我不知道如果它潜入海底，死在那儿，我该怎么办。可是我必须干些什么。我能做的事情多着呢。\r\n\r\n然后他说出声来，“但愿男孩在就好了。可以帮帮我，让他见识见识这种光景。”\r\n\r\n不知道它有没有什么打算，还是跟我一样，不顾死活？\r\n\r\n它选择的是待在黑暗的深水里，远远地避开一切圈套、罗网和诡计。我选择的是赶到谁也没到过的地方去找它。到世界上没人去过的地方。如今我跟它给拴在一起了，从中午起就是如此。而且我和它都没有人来帮忙。\r\n\r\n他说出声来，“但愿那男孩在就好了。”\r\n\r\n他就这样做了。摸黑干很困难，有一回，那条大鱼掀动了一下，把他拖倒在地，脸朝下，眼睛下给划了一道口子。鲜血从他脸颊上淌下来。但还没流到下巴上就凝固、干掉，于是他挪动身子回到船头，靠在木船舷上歇息。\r\n\r\n“鱼啊，”他轻轻地说出声来，“我要跟你奉陪到死。”\r\n\r\n但愿它会随着海流拐弯。这样可以说明它越来越疲乏了。\r\n\r\n既然是白天了，就让它跳跃吧，这样它会把沿着背脊的那些液囊装满了空气，就没法沉到海底去死了。\r\n\r\n“鱼啊，”他说，“我爱你，非常尊敬你。不过今天我得把你杀死。”\r\n\r\n“但愿男孩在这儿，我手边有点儿盐，”他说出声来。\r\n\r\n只不过被钓索勒了一下，割破了皮肉而已。然而这正是手上最得用的地方。他知道需要这双手来把这桩事干到底，不喜欢还没动手就让手给割破。\r\n\r\n### 3\r\n\r\n我该吃小金枪鱼了。我可以用鱼钩把它钩过来，在这儿舒舒服服地吃。\r\n\r\n他把一膝压在鱼身上，从它的脖颈竖割到尾部，割下一条条深红色的鱼肉。这些肉条的断面是楔形的，他从脊骨边开始割，直割到肚子边。他割下了六条，把它们摊在船头的木板上，在裤子上擦擦刀子，拎起鱼尾巴，把鱼骨扔在海里。\r\n\r\n“感觉怎么样，手啊？”他问那只抽筋的手，它僵直得几乎跟死尸一般。“我要为了你再吃一点儿。”\r\n\r\n我还不知道太阳会不会把剩下的鱼肉给晒坏或者晒干，所以最好把它们都吃了，尽管我并不饿。\r\n\r\n我巴望也能喂那条大鱼，他想。它是我的兄弟。可是我不得不把它弄死，而且得保持精力来这样做。\r\n\r\n你可以放掉钓索了，手啊，我要单单用右臂来对付它，直到你不再胡闹。\r\n\r\n“天主帮帮我，让这抽筋快好吧，”\r\n\r\n我必须随机应变，拿我的计划来对付它的，因为它个儿这么大。如果它跳出水来，我就能弄死它。但是它始终待在下面不上来。那我也就要跟它奉陪到底。\r\n\r\n如果我非靠这只手不可，我要不惜任何代价把它张开。但是我眼下不愿硬把它张开。让它自行张开，自动恢复过来吧。我昨夜毕竟把它使用得过度了，那时候不得不把各条钓索解开，系在一起。\r\n\r\n他眺望着海面，发觉他此刻是多么孤单。但是他可以看见深色的海水深处的彩虹七色、面前伸展着的钓索和那平静的海面上奇妙的波动。由于贸易风的吹刮，这时云块正在积聚起来，他朝前望去，见到一群野鸭在水面上飞，在天空的衬托下，身影刻画得很清楚，然后模糊起来，然后又清楚地刻画出来，于是他明白，一个人在海上是永远不会孤单的。\r\n\r\n我恨抽筋，他想。这是对自己身体的背叛行为。由于食物中毒而腹泻或者呕吐，是在别人面前丢脸。但是抽筋，他想，在西班牙语中叫 calambre，是丢自己的脸，尤其是一个人独自待着的时候。\r\n\r\n“它上来啦，”他说。“手啊，快点。请快点张开。”\r\n\r\n它是条大鱼，我一定要制服它，他想。我一定不能让它明白它有多大的力气，明白它如果飞逃的话，能干出什么来。我要是它，眼下就要使出浑身的力气，一直飞逃到什么东西绷断为止。但是感谢天主，它们没有我们这些要杀害它们的人聪明；尽管它们比我们高尚，更有能耐。\r\n\r\n但愿我就是这条鱼，他想，它正使出所有的力量，而要对付的仅仅是我的意志和我的智力。\r\n\r\n万福童贞圣母，祈求你叫这鱼死去。尽管它多了不起。”\r\n\r\n念完了祈祷文，他觉得舒坦多了，但依旧像刚才一样地痛，也许更厉害一点儿，于是他背靠在船头的木舷上，机械地活动起左手的手指。\r\n\r\n此刻阳光很热了，尽管微风正在柔和地吹起。\r\n\r\n然而这是不公平的，他想。不过我要让它知道人有多少能耐，人能忍受多少磨难。\r\n\r\n它的眼睛真大，马的眼睛要小得多，但在黑暗里看得见东西。从前我在黑暗里能看得很清楚。可不是在乌漆墨黑的地方。不过简直能像猫一样看东西。\r\n\r\n。人跟伟大的鸟兽相比真算不上什么。我还是情愿做那只待在黑暗的深水里的动物。\r\n\r\n你以为那了不起的迪马吉奥能守着一条鱼，像我守着这一条一样长久吗？他想。我相信他能，而且更长久，因为他年轻力壮。加上他父亲当过渔夫。不过骨刺会不会使他痛得太厉害呢？\r\n\r\n太阳落下去的时候，为了给自己增强信心，他回想起那回在卡萨布兰卡(25)一家酒店里，跟那个码头上力气最大的人，从西恩富戈斯(26)来的大个子黑人比手劲的光景。\r\n\r\n他认为如果一心想要做到的话，他能够打败任何人，\r\n\r\n就在断黑之前，老人和船经过好大一片马尾藻，它在风浪很小的海面上动荡着，仿佛海洋正同什么东西在一条黄色的毯子下做爱，\r\n\r\n“那鱼还是老样子，一点也没变，”他说。\r\n\r\n“它能熬夜，我也能。”\r\n\r\n对所有的鱼来说，太阳落下去的时分都是难熬的。\r\n\r\n不过话得说回来，干什么都不容易。\r\n\r\n于是他替这条没东西吃的大鱼感到伤心，但是要杀死它的决心绝对没有因为替它伤心而减弱。它能供多少人吃啊，他想。可是他们配吃它吗？不配，当然不配。凭它的举止风度和它的高度尊严来看，谁也不配吃它。\r\n\r\n保持船身轻，会延长我们双方的痛苦，但这是我的安全所在，因为这鱼能游得很快，这本领至今尚未使出过。不管出什么事，我必须把这鲯鳅开膛剖肚，免得坏掉，并且吃一点长长力气。\r\n\r\n饥饿的折磨，加上还得对付它这不了解的对手，才是天大的麻烦。休息吧，老家伙，让它去干它的事，等轮到该你干的时候再说。\r\n\r\n他肩上依旧承受着鱼的拉力，不过他把左手按在船头的舷上，把对抗鱼的拉力的任务越来越让小帆船本身来承担了。\r\n\r\n可是只消鱼稍微歪一歪，就能把钓索绷断。我必须用自己的身子来缓冲这钓索的拉力，随时准备用双手放出钓索。\r\n\r\n我脑筋够清醒的，他想。太清醒啦。我跟星星一样清醒，它们是我的兄弟。不过我还是必须睡觉。它们睡觉，月亮和太阳都睡觉，连海洋有时候也睡觉，那是在某些没有激浪、平静无波的日子里。\r\n\r\n它也许正是半睡半醒的，他想。可是我不想让它休息。必须要它拖曳着一直到死去。\r\n\r\n鲯鳅是冰冷的，这时在星光里显得像麻风病患者般灰白，老人用右脚踩住鱼头，剥下鱼身上一边的皮。然后他把鱼翻转过来，剥掉另一边的皮，把鱼身两边的肉从头到尾割下。\r\n\r\n水流并不那么有力了，当他把手的侧面在小帆船船板上擦着的时候，星星点点的磷质漂浮开去，慢慢朝船梢漂去。\r\n\r\n“鲯鳅煮熟了吃味道才鲜美啊，”他说。“生吃可难吃死了。以后不带盐或酸橙，我绝对不再乘船了。”\r\n\r\n东方天空中布满了云，他认识的星星一颗颗地不见了。他眼下仿佛正驶进一个云彩的大峡谷，风已经停了。\r\n\r\n这对右手是很吃重的。但是它是吃惯了苦的。\r\n\r\n如果那男孩在这儿，他会用水打湿这些钓索卷儿，他想。是啊。如果男孩在这儿。如果男孩在这儿。\r\n\r\n不过它是一条那样沉着、健壮的鱼，似乎是毫无畏惧而信心十足的。这可怪了。\r\n\r\n这表明它疲乏了，正随着潮流走。它马上就得打转了。那时我们才真正开始干啦。\r\n\r\n疼痛对一条汉子来说，算不上什么。”\r\n\r\n为什么我不生下来就有两只好手呢？他想。也许是我自己的过错，没有好好儿训练这只手。可是天知道它曾有过够多的学习机会。然而它今天夜里干得还不错，仅仅抽了一回筋。要是它再抽筋，就让这钓索把它勒断吧。\r\n\r\n自从他出海以来，这是第三次出太阳，这时鱼打起转来了。\r\n\r\n他把钓索从肩膀和头上卸下，动手平稳而和缓地回收钓索。他用双手一摇一摆地拉着，尽量使出全身和双腿的力气来拉。他一摇一摆地拉着，两条老迈的腿儿和肩膀跟着转动。\r\n\r\n我眼下一定要稳住它，过后我一定要弄死它。\r\n\r\n两小时后，老人浑身汗湿，疲乏得入骨了。\r\n\r\n我不能让自己垮下去，就这样死在一条鱼的手里，\r\n\r\n它正用它的长嘴撞击着铁丝导线，他想。这是免不了的。它不能不这样干。然而这一来也许会使它跳起来，可我情愿它眼下继续打转。它必须跳出水面来呼吸空气。但是每跳一次，钓钩划出的伤口就会裂得大一些，它就能把钓钩甩掉。\r\n\r\n我的疼痛不要紧。我能控制。但是它的疼痛能使它发疯。\r\n\r\n老人就站起身来，开始那种左右转动、交替拉曳的动作，原来他的钓索全是这样收回来的。\r\n\r\n### 4\r\n\r\n你现在忙你的吧，鱼啊，他想。你转身时我要来收服你。\r\n\r\n老人看见它的尾巴出了水。它比一把大镰刀的刀刃更高，呈极淡的浅紫色，竖在深蓝色的海面上。它朝后倾斜着，鱼在水面下游的时候，老人看得见它庞大的身躯和周身的紫色条纹。它的脊鳍朝下耷拉着，巨大的胸鳍大张着。\r\n\r\n“要沉着，要有力，老头儿，”他说。\r\n\r\n这时鱼正兜了一个圈子回来，既沉着又美丽，只有它的大尾巴在动。\r\n\r\n你要把我害死啦，鱼啊，老人想。不过你有权利这样做。我从没见过比你更庞大、更美丽、更沉着或更崇高的东西，老弟。来，把我害死吧。我不在乎谁害死谁。\r\n\r\n我想看看它，他想，碰碰它，摸摸它。它是我的财产，他想。然而我想摸摸它倒不是为了这个。我以为刚才触及过它的心脏，他想。\r\n\r\n“战斗既然结束了，就有好多苦活得干啦。”\r\n\r\n这些条纹比一个人张开五指的手更宽，它的眼睛看上去冷漠得像潜望镜中的反射镜，又像宗教游行队伍中圣徒塑像的眼睛。\r\n\r\n看样子它不止一千五百磅重，他想。也许还要重得多。如果去掉了头尾和下脚，肉有三分之二的重量，照三角钱一磅计算，该是多少？\r\n\r\n不知道骨刺是什么玩意儿，他想。也许我们都长着骨刺，自己不知道。\r\n\r\n他把鱼紧系在船头、船梢和中央的座板上。它真大，简直像在船边绑上了另一条大得多的帆船。\r\n\r\n他不需要罗盘来告诉他西南方在哪里。他只消凭贸易风吹在身上的感觉和帆的动向就能知道。\r\n\r\n鱼闭着嘴，尾巴直上直下地竖着，我们像亲兄弟一样航行着。接着他的头脑有点儿不清楚了，他竟然想起，是它在带我回家，还是我在带它回家呢？\r\n\r\n老人此刻头脑清醒正常，充满了决心，但并不抱着多少希望。光景太好了，不可能持久的，他想。\r\n\r\n“然而人不是为失败而生的，”他说。“一个人可以被毁灭，但不能给打败。”\r\n\r\n可是没有办法让它的气味不散布到水里去，老人知道糟糕透顶的时刻就快来到。\r\n\r\n老人朝前方望去，不见一丝帆影，也看不见任何一只船的船身或冒出的烟。只有从他船头下跃起的飞鱼，向两边逃去，还有一摊摊黄色的马尾藻。他连一只鸟也看不见。\r\n\r\n“Ay，”他说出声来。这个词儿是没法翻译的，也许不过是一个响声，就像一个人觉得钉子穿过他的双手、钉进木头时不由自主地发出的声音。\r\n\r\n加拉诺鲨\r\n\r\n它们是恶毒的鲨鱼，气味难闻，既杀害其他的鱼，也吃腐烂的死鱼，饥饿的时候，它们会咬船上的桨或者舵。正是这些鲨鱼，会趁海龟在水面上睡觉的时候咬掉它们的脚和鳍状肢，如果碰到饥饿的时候，也会在水里袭击人，即使这人身上并没有鱼血或黏液的腥味。\r\n\r\n鲨鱼放开了咬住的鱼，身子朝下溜，临死时还把咬下的肉吞了下去。\r\n\r\n老人趁它的鼻子伸出水面挨上那条鱼的时候，对准它扁平的脑袋正中扎去。老人拔出刀刃，朝同一地方又扎了那鲨鱼一下。它依旧紧锁着上下颚，咬住了鱼不放，老人一刀戳进它的左眼。鲨鱼还是吊在那里。\r\n\r\n走吧，加拉诺鲨。溜到一英里深的水里去吧。去找你的朋友，也许那是你的妈妈吧。”\r\n\r\n“我原不该出海这么远的，鱼啊，”他说。“对你对我都不好。我感到抱歉，鱼啊。”\r\n\r\n眼下可不是想你缺乏什么东西的时候。想想你用手头现有的东西能做什么事儿吧。\r\n\r\n但愿这真是一场梦，他想。不过谁说得准呢？也许结果会是圆满的。\r\n\r\n它们如今可把我打垮了，他想。我太老了，不能用棍子打死鲨鱼了。但是只要我有桨和短棍和舵把，我还要试试。\r\n\r\n“你累乏了，老家伙，”他说。“你骨子里累乏了。”\r\n\r\n“来吧，加拉诺鲨，”老人说。“再过来吧。”\r\n\r\n他不愿朝那条鱼看。他知道它的半个身子已经被咬掉了。\r\n\r\n当然啦，只有那男孩会担心。但我相信他一定会有信心。\r\n\r\n“跟它们斗，”他说。“我要跟它们斗到死。”\r\n\r\n这时航行得很轻松，他什么念头都没有，什么感觉也没有。他此刻超脱了这一切，只顾尽可能出色而明智地把小帆船驶回他家乡的港口。\r\n\r\n### 5\r\n\r\n“什么也没有，”他说出声来。“只怪我出海太远了。”\r\n\r\n男孩看见老人在喘气，跟着看见老人的那双手，就哭起来了。他悄没声儿地走出来，去拿点咖啡，一路上边走边哭。\r\n\r\n“它们把我打垮了，马诺林，”他说。“它们确实把我打垮了。”“它没有把你打垮。那条鱼可没有。”\r\n\r\n在大路另一头的窝棚里，老人又睡着了。他依旧脸朝下躺着，男孩坐在他身边，守着他。老人正梦见狮子。","type":"text/markdown","created":"20230614012821279","creator":"oeyoews","modified":"20230929060134663","modifier":"oeyoews","page-cover":"https://img9.doubanio.com/view/subject/m/public/s29961556.jpg","publish":"publish","tags":"books"},{"title":"联想电脑管家","text":"联想电脑管家所谓的开启浏览器保护, 自己可以指定浏览器主页的行为本身就是一种流氓行为(这是默认开启的), 只有点击快捷方式或者 exe 是生效,通过 hotkey 启动的不会被指定\n\n[img[https://i.imgur.com/ZOCsR2I.png]]","type":"text/markdown","created":"20231012025601012","creator":"Lenovo","modified":"20231012030856679","modifier":"Lenovo","tags":"windows"},{"title":"苹果ID提示_您的账号已经在App_Store及iTunes上停用_解决方法___Tokyo_Blog","text":"App Store 停用英文提示是：Your account has been disabled in the App Store and iTunes.\\\n出现这个提示说明有一个账号被封了，但是得分情况，有可能被封的不是你自己的账号！\n\n## 第一种情况\n\n登陆账号没有后没有任何操作，直接弹出“您的账号已经在 App Store 及 iTunes 上停用”的提示\n\n## [苹果 ID 代解封服务——点击购买](http://shop.hellokvm.com/)\n\n如果是这种情况，确保是登录后没有点击任何按钮就直接弹出这个提示，说明你刚登陆的这个账号被禁用 App Store 了，要么联系苹果客服解封，要么只能换号\\\nPs：如果是使用本站共享账户（不论免费还是付费）出现第一种情况，请反馈给站长！\n\n## 第二种情况\n\n1）登陆账号没有任何提示，点击更新 App 才提示，划重点，是点更新 App\n\n再次强调，是点【更新】App 才弹出的这个提示，包括：英语【UPDATE】、日语【アップデート】都是更新的意思；如果是点更新才弹出此提示，去 App Store 搜索一个不是【更新】的 App 又可以正常下载，那就不是你刚登陆的这个账号被封号了，是原来下载此 App 的账号被封了，这里科普下苹果 App 更新原理：\\\n举例：你用 A 账户下载了微信，那你后面每次更新微信也必须用 A 账户，哪怕你手机现在登录的 B 账号，其实也是用 A 账户再更新；如果哪天 A 账号被封号了，你手机上的微信就无法更新，点击更新就会出现“您的账号已经在 App Store 及 iTunes 上停用”或者其他错误提示，这个时候如果还想用最新版，只能去解封 A 账号或者删除手机上用 A 账户下载的微信，用其他账号从新下载\\\n2）登陆账号没有任何提示，也不是点击更新，下载不是更新的 App 也弹出这个提示\n\n如果是这种情况，那还是你现在登录的这个账号被封号了，只是由于网络等原因没有第一时间弹出提示，这种属于第一种情况","type":"text/markdown","created":"20231028024407162","creator":"太微搜藏","modified":"20231028024437997","modifier":"Lenovo","tags":"剪藏","url":"http://www.hellokvm.com/?p=1633&amp=1"},{"title":"蓝屏日志位置","text":"https://jingyan.baidu.com/article/1974b28944f078f4b0f77474.html\nhttps://blog.csdn.net/wangshuping18/article/details/114670499","type":"text/markdown","created":"20231028020740127","creator":"Lenovo","modified":"20231028021518868","modifier":"Lenovo","tags":"","url":"https://zhuanlan.zhihu.com/p/572819653#:~:text=dmp%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E6%89%93%E5%BC%80%201%201.%E5%85%88%E8%A6%81%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85Debugging%20Tools%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%B7%A5%E5%85%B7%2F%E5%8E%9F%E6%96%99%E5%A4%84%E6%9C%89%E3%80%82%202%202.%E8%A7%A3%E5%8E%8B%EF%BC%8CInstaller%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%EF%BC%8C%E6%89%BE%E5%88%B0%E4%B8%8B%E9%9D%A2%E7%BA%A2%E8%89%B2%E6%A1%86%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%EF%BC%8CX64%E6%98%AF64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%EF%BC%8CX86%E6%98%AF32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E3%80%82%203%203.%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E6%89%BE%E5%88%B0,5.%E5%9C%A8%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E6%8F%90%E7%A4%BA%E4%BC%9A%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F%E6%98%AF%E5%90%A6%E5%9C%A8%E5%BC%80%E5%90%AF%E3%80%82%20%E7%82%B9%E5%87%BB%E3%80%90Yes%E3%80%91%206%206.%E6%89%93%E5%BC%80%E4%BA%86.DMP%E6%96%87%E4%BB%B6%E4%BB%A5%E5%90%8E%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A%207%207.%E7%82%B9%E5%87%BB%EF%BC%81%20analyze%20-v%EF%BC%8C%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90"},{"title":"解构01","text":"```js\r\n// const widget = require('widget').widget\r\n// const { widget } = require(\"widget\");\r\n\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: 3,\r\n};\r\n\r\n// const { a } = obj;\r\nconst a = obj.a;\r\n```","type":"text/markdown","created":"20230613042644173","creator":"oeyoews","modified":"20230726045248307","modifier":"oeyoews","tags":"JavaScript"},{"title":"解构对象","text":"在 JavaScript 中，如果你想解构类的实例方法，通常并不能直接解构到方法级别，因为类的方法是挂载在类的原型上的。你可以通过以下方式来调用实例的方法：\r\n\r\n```js\r\nconst mySortInstance = new Sort([4, 2, 8, 1, 5]);\r\nmySortInstance.bubbleSort();  // 调用 bubbleSort 方法进行排序\r\n```\r\n\r\n解构语法通常用于解构对象的属性或数组的元素，而不适用于类的实例方法。如果你希望能够更方便地调用实例方法，可以将方法从类中解构到一个变量中：\r\n\r\n```js\r\nconst mySortInstance = new Sort([4, 2, 8, 1, 5]);\r\nconst bubbleSortMethod = mySortInstance.bubbleSort.bind(mySortInstance);\r\nbubbleSortMethod();  // 调用解构后的方法进行排序\r\n```\r\n\r\n注意，上述的代码中使用了 bind 方法，将方法绑定到了实例上，以确保在方法内部能够访问到实例的属性和方法。","type":"text/markdown","created":"20230827134056933","creator":"oeyoews","modified":"20230827142423240","modifier":"oeyoews","tags":"TypeScript"},{"title":"解构语法","text":"解构语法是一种方便的 JavaScript 语法，用于从对象或数组中提取数据，然后将提取的数据赋值给变量。解构语法通常使用花括号 `{}` 或方括号 `[]` 来表示要提取的数据的结构。\r\n\r\n以下是一个从对象中提取数据的示例：\r\n\r\n```javascript\r\nconst person = { name: \"Alice\", age: 30, gender: \"female\" };\r\n\r\n// 使用解构语法从 person 对象中提取 name 和 age 属性\r\n// const name = person.name;\r\n// const age = person.age;\r\nconst { name, age } = person;\r\n\r\nconsole.log(name); // 输出 \"Alice\"\r\nconsole.log(age);  // 输出 30\r\n```\r\n\r\n在这个示例中，我们使用解构语法从 `person` 对象中提取 `name` 和 `age` 属性，并将它们分别赋值给变量 `name` 和 `age`。因此，在调用 `console.log(name)` 和 `console.log(age)` 时，分别输出了 \"Alice\" 和 30。\r\n\r\n解构语法也可以用于从数组中提取数据。以下是一个从数组中提取数据的示例：\r\n\r\n```javascript\r\nconst numbers = [1, 2, 3, 4, 5];\r\n\r\n// 使用解构语法从 numbers 数组中提取第一个和第二个元素\r\nconst [first, second] = numbers;\r\n\r\nconsole.log(first);  // 输出 1\r\nconsole.log(second); // 输出 2\r\n```\r\n\r\n在这个示例中，我们使用解构语法从 `numbers` 数组中提取第一个和第二个元素，并将它们分别赋值给变量 `first` 和 `second`。因此，在调用 `console.log(first)` 和 `console.log(second)` 时，分别输出了 1 和 2。","type":"text/markdown","created":"20230607031640950","creator":"oeyoews","modified":"20230726045248307","modifier":"oeyoews","tags":"JavaScript"},{"title":"谈_Linux，Windows_和_Mac","text":"> https://i.linuxtoy.org/docs/guide/ch06.html\n\n这段时间受到很多人的来信。他们看了我很早以前写的推崇 Linux 的文章，想知道如何“抛弃 Windows，学习 Linux”。天知道他们在哪里找到那么老的文章，真是好事不出门…… 我觉得我有责任消除我以前的文章对人的误导，洗清我这个“Linux 狂热分子”的恶名。我觉得我已经写过一些澄清的文章了，可是怎么还是有人来信问 Linux 的问题。也许因为感觉到“舆论压力”，我把文章都删了。\n\n简言之，我想对那些觉得 Linux 永远也学不会的“菜鸟”们说：\n\n1. Linux 和 Unix 里面包含了一些非常糟糕的设计。不要被 Unix 的教条主义者吓倒。学不会有些东西很多时候不是你的错，而是 Linux 的错，是“Unix 思想” 的错。不要浪费时间去学习太多工具的用法，钻研稀奇古怪的命令行。那些貌似难的，复杂的东西，特别要小心分析。\n\n2. Windows 避免了 Unix，Linux 和 Mac OS X 的很多问题。微软是值得尊敬的公司，是真正在乎程序开发工具的公司。我收回曾经对微软的鄙视态度。请菜鸟们吸收 Windows 设计里面好的东西。另外 Visual Studio 是非常好的工具，会带来编程效率的大幅度提升。请不要歧视 IDE。要正视 Emacs，VIM 等文本编辑器的局限性。当然，这些正面评价不等于说你应该为微软工作。就像我喜欢 iPhone，但是却不一定想给 Apple 工作一样。\n\n3. 学习操作系统最好的办法是学会（真正的）程序设计思想，而不是去“学习”各种古怪的工具。所有操作系统，数据库，Internet，以至于 WEB 的设计思想（和缺陷），几乎都能用程序语言的思想简单的解释。\n\n先说说我现在对 Linux 和相关工具（比如 TeX）的看法吧。我每天上班都用 Linux，可是回家才不想用它呢。上班的时候，我基本上只是尽我所能的改善它，让它不要给我惹麻烦。Unix 有许许多多的设计错误，却被当成了教条，传给了一代又一代的程序员，恶性循环。Unix 的 shell，命令，配置方式，图形界面，都是相当糟糕的。每一个新版本的 Ubuntu 都会在图形界面的设计上出现新的错误，让你感觉历史怎么会倒退。其实这只是表面现象。Linux 所用的图形界面（X Window）在本质上几乎是没救的。我不想在这里细说 Unix 的缺点，在它出现的早期，已经有人写了一本书，名叫 Unix Hater’s Handbook，里面专门有一章叫做 The X-Windows Disaster。它分析后指出，X Window 貌似高明的 client-server 设计，其实并不像说的那么好。\n\n这本书汇集了 Unix 出现的年代，很多人对它的咒骂。有趣的是，这本书有一个“反序言”，是 Unix 的创造者之一 Dennis Ritchie 写的。我曾经以为这些骂 Unix 的人都是一些菜鸟。他们肯定是智商太低，或者被 Windows 洗脑了，不能理解 Unix 的高明设计才在那里骂街。现在理解了程序语言的设计原理之后，才发现他们说的那些话里面居然大部分是实话！其实他们里面有些人在当年就是世界顶尖的编程高手，自己写过操作系统和编译器，功底不亚于 Unix 的创造者。在当年他们就已经使用过设计更加合理的系统，比如 Multics，Lisp Machine 等。\n\n可惜的是，在现在的操作系统书籍里面，Multics 往往只是被用来衬托 Unix 的“简单”和伟大。Unix 的书籍喜欢在第一章讲述这样的历史：“Multics 由于设计过于复杂，试图包罗万象，而且价格昂贵，最后失败了。” 可是 Multics 失败了吗？Multics，Oberon，IBM System/38， Lisp Machine，…… 在几十年前就拥有了 Linux 现在都还没有的好东西。Unix 里面的东西，什么虚拟内存，文件系统，…… 基本上都是从 Multics 学来的。Multics 的机器，一直到 2000 年都还在运行。Unix 不但“窜改”了历史教科书，而且似乎永远不吸取教训，到现在还没有实现那些早期系统早就有的好东西。Unix 的设计几乎完全没有一致性和原则。各种工具程序功能重复，冗余，没法有效地交换数据。可是最后 Unix 靠着自己的“廉价”，“宗教”和“哲学”，战胜了别的系统在设计上的先进，统治了程序员的世界。\n\n如果你想知道这些“失败的”操作系统里面有哪些我们现在都还没有的先进技术，可以参考这篇文章：Oberon - The Overlooked Jewel。它介绍的是 Niklaus Wirth（也就是 Pascal 语言的设计者）的 Oberon 操作系统。\n\n胜者为王，可是 Unix 其实是一个暴君，它不允许你批评它的错误。它利用其它程序员的舆论压力，让每一个系统设计上的错误，都被说成是用户自己的失误。你不敢说一个工具设计有毛病，因为如果别人听到了，就会以为你自己不够聪明，说你“人笨怪刀钝”。这就像是“皇帝的新装”里的人们，明明知道皇帝没穿衣服，还要说“这衣服这漂亮”！总而言之，“对用户友好”这个概念，在 Unix 的世界里是被歧视，被曲解的。Unix 的狂热分子很多都带有一种变态的“精英主义”。他们以用难用的工具为豪，鄙视那些使用“对用户友好”的工具的人。\n\n我曾经强烈的推崇 FVWM，TeX 等工具，可是现在擦亮眼睛看来，它们给用户的界面，其实也是非常糟糕的设计，跟 Unix 一脉相承。他们把程序设计的许多没必要的细节和自己的设计失误，无情的暴露给用户。让用户感觉有那么多东西要记，仿佛永远也没法掌握它。实话说吧，当年我把 TeXbook 看了两遍，做完了所有的习题（包括最难的“double bend”习题）。几个月之后，几乎全部忘记干净。为什么呢？因为 TeX 的语言是非常糟糕的设计，它没有遵循程序语言设计的基本原则。\n\n这里有一个鲜为人知的小故事。TeX 之所以有一个“扩展语言”，是 Scheme 的发明者 Guy Steele 的建议。那年夏天，Steele 在 Stanford 实习。他听说 Knuth 在设计一个排版系统，就强烈建议他使用一种扩展语言。后来 Knuth 采纳了他的建议。不幸的是 Steele 几个月后就离开了，没能帮助 Knuth 完成语言的设计。Knuth 老爹显然有我所说的那种“精英主义”，他咋总是设计一些难用的东西，写一些难懂的书？\n\n一个好的工具，应该只有少数几条需要记忆的规则，就像象棋一样。而这些源于 Unix 的工具却像是“魔鬼棋”或者“三国杀”，有太多的，无聊的，人造的规则。有些人鄙视图形界面，鄙视 IDE，鄙视含有垃圾回收的语言（比如 Java），鄙视一切“容易”的东西。他们却不知道，把自己沉浸在别人设计的繁复的规则中，是始终无法成为大师的。就像一个人，他有能力学会各种“魔鬼棋”的规则，却始终无法达到象棋大师的高度。所以，容易的东西不一定是坏的，而困难的东西也不一定是好的。学习计算机（或者任何其它工具），应该“只选对的，不选难的”。记忆一堆的命令，乌七八糟的工具用法，最后脑子里什么也不会留下。学习“原理性”的东西，才是永远不会过时的。\n\nWindows 技术设计上的很多细节，也许在早期是同样糟糕的。但是它却向着更加结构化，更加简单的方向发展。Windows 的技术从 OLE，COM，发展到 .NET，再加上 Visual Studio 这样高效的编程工具，这些带来了程序员和用户效率的大幅度提高，避免了 Unix 和 C 语言的很多不必存在的问题。Windows 程序从很早的时候就能比较方便的交换数据。比如，OLE 让你可以把 Excel 表格嵌入到 Word 文档里面。不得不指出，这些是非常好的想法，是超越“Unix 哲学”的。相反，由于受到“Unix 哲学”的误导，Unix 的程序间交换数据一直以来都是用字符串，而且格式得不到统一，以至于很多程序连拷贝粘贴都没法正确进行。Windows 的“配置”，全都记录在一个中央数据库（注册表）里面，这样程序的配置得到大大的简化。虽然在 Win95 的年代，注册表貌似老是惹麻烦，但现在基本上没有什么问题了。相反，Unix 的配置，全都记录在各种稀奇古怪的配置文件里面，分布在系统的各个地方。你搞不清楚哪个配置文件记录了你想要的信息。每个配置文件连语法都不一样！这就是为什么用 Unix 的公司总是需要一个“系统管理员”，因为软件工程师们才懒得记这些麻烦的东西。\n\n再来比较一下 Windows 和 Mac 吧。我认识一个 Adobe 的高级设计师。他告诉我说，当年他们把 Photoshop 移植到 Intel 构架的 Mac，花了两年时间。只不过换了个处理器，移植个应用程序就花了两年时间，为什么呢？因为 Xcode 比起 Visual Studio 真是差太多了。而 Mac OS X 的一些设计原因，让他们的移植很痛苦。不过他很自豪的说，当年很多人等了两年也没有买 Intel 构架的 Mac，就是因为他们在等待 Photoshop。最后他直言不讳的说，微软其实才是真正在乎程序员工具的公司。相比之下，Apple 虽然对用户显得友好，但是对程序员的界面却差很多。Apple 尚且如此，Linux 对程序员就更差了。可是有啥办法呢，有些人就是受虐狂。自己痛过之后，还想让别人也痛苦。就像当年的我。\n\n我当然不是人云亦云。微软在程序语言上的造诣和投入，我看得很清楚。我只是通过别人的经历，来验证我已经早已存在的看法。所以一再宣扬别的系统都是向自己学习的 Apple 受到这样的评价，我也一点不惊讶。Mac OS X 毕竟是从 Unix 改造而来的，还没有到脱胎换骨的地步。我有一个 Macbook Air，一个 iPhone 5，和一个退役的，装着 Windows 7 的 T60。我不得不承认，虽然我很喜欢 Macbook 和 iPhone 的硬件，但我发现 Windows 在软件上的很多设计其实更加合理。\n\n我为什么当年会鄙视微软？这很简单。我就是跟着一群人瞎起哄而已！他们说 Linux 能拯救我们，给我们自由。他们说微软是邪恶的公司…… 到现在我身边还有人无缘无故的鄙视微软，却不知道理由。可是 Unix 是谁制造的呢？是 AT\\&T。微软和 AT\\&T 哪个更邪恶呢？我不知道。但是你应该了解一下 Unix 的历史。AT\\&T 当年发现 Unix 有利可图，找多少人打了多少年官司？说微软搞垄断，其实 AT\\&T 早就搞过垄断了，还被拆散成了好几个公司。想想世界上还有哪一家公司，独立自主的设计出这从底至上全套家什：程序语言，编译器，IDE，操作系统，数据库，办公软件，游戏机，手机…… 我不得不承认，微软是值得尊敬的公司。\n\n公司还不都一样，都是以利益为本的。我们程序员就不要被他们利用，作为利益斗争的炮灰啦。见到什么好就用什么，就学什么。自己学到的东西，又不属于那些垄断企业。我们都有自由的头脑。\n\n当然我不是在这里打击 Linux 和 Mac 而鼓吹 Windows。这些系统的纷争基本上已经不关我什么事。我只是想告诉新人们，去除头脑里的宗教，偏激，仇恨和鄙视。每次仇恨一个东西，你就失去了向它学习的机会。\n\n后记：“对用户友好”是一个值得研究，却又研究得非常不够的东西。很多 UI 的设计者，把东西设计的很漂亮，但是却不方便，不顺手。如果你想了解我认为怎样的设计才是“对用户友好的”，可以参考这篇博客《[什么是“对用户友好](http://www.yinwang.org/blog-cn/2012/05/18/user-friendliness)”》\n","type":"text/markdown","created":"20231030053342299","creator":"太微搜藏","modified":"20231030053911822","modifier":"Lenovo","tags":"剪藏","url":"https://www.yinwang.org/blog-cn/2013/03/07/linux-windows-mac"},{"title":"象牙塔","text":"\"象牙塔\"是一个形象化的说法，通常用来指代与现实世界隔离、远离实际问题、缺乏实际经验或与日常生活脱节的学术或知识领域。这个词语最初是指教堂的尖塔，后来引申为学术、艺术或知识界的象征。\r\n\r\n在学术领域中，有时候人们会将研究者或学者视为生活在象牙塔中的人，因为他们主要关注理论和抽象的概念，而对于实际的应用和社会问题了解较少。这种观点认为，他们过于专注于学术圈内的事物，而与现实世界脱节。\r\n\r\n然而，需要注意的是，并非所有的学者或研究者都符合这种象牙塔的形象。许多学者致力于解决实际问题，积极参与社会和实践活动，以及与其他学科交叉合作。此外，一些学者还积极推动知识的普及和社会责任。\r\n\r\n所以，\"象牙塔\"这个词可以具有贬义和批评的意味，但我们也应该理解到学术界的多样性和包容性。许多学者和研究者都在努力将他们的研究与社会实际问题相结合，以促进实际的影响和变革。","type":"text/markdown","created":"20230628130557196","creator":"oeyoews","modified":"20230726045248407","modifier":"oeyoews"},{"title":"重新npm_publish发布包报错","text":"* 24 小时 限制","type":"text/markdown","created":"20231031082131428","creator":"太微搜藏","modified":"20231101010106072","modifier":"Lenovo","tags":"剪藏"},{"title":"重装系统安装的一些软件","text":"> 装系统确实挺耗费时间精力的\r\n\r\n1. tree\r\n2. ripgrep\r\n3. docker docker-compose\r\n4. node npm pnpm\r\n5. neovim python-neovim xclip\r\n6. ranger\r\n7. trash-cli\r\n8. fcitx5 etc\r\n9. google-chrome\r\n10. visual-studio-code\r\n11. flameshot\r\n12. gpaste\r\n13. v2ray v2raya\r\n14. yay\r\n15. archlinuxcn etc\r\n16. base-devel\r\n17. btop\r\n18. duf\r\n19. dust\r\n20. tig\r\n21. zathura\r\n22. chezmoi\r\n23. pngquant\r\n24. github-desktop\r\n25. noto emoji cjk\r\n26. maple \r\n27. gnome-shell-extension-tray-icons-reloaded\r\n28. fzf cloc fd\r\n29. gnome-shell-extension-color-picker\r\n30. tlp\r\n31. python-pygments\r\n32. musicbox\r\n\r\n\r\n\r\n","type":"text/markdown","created":"20231001125153963","creator":"oeyoews","modified":"20231003014646658","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random/1920x1080?fm=blurhash&重装系统安装的一些软件","tags":""},{"title":"键盘轴","text":"茶轴太软了，用了这么久还是没有青轴舒服","type":"text/markdown","created":"20231009125409860","creator":"Lenovo","modified":"20231009125430323","modifier":"Lenovo","tags":""},{"title":"闭包注意事项","text":"闭包是指在一个函数内部创建的函数，并且这个内部函数可以访问外部函数的变量和作用域。闭包可以在许多情况下非常有用，但如果不正确地使用闭包，可能会导致内存泄漏的问题。\r\n\r\n当一个函数形成闭包时，它会创建一个引用外部函数作用域的闭包环境。这意味着在闭包中引用的外部函数的变量和对象将被保存在内存中，而不会被垃圾回收机制清理掉。如果闭包持有大量的数据或者引用了很多对象，但不再使用它们，就会导致内存泄漏。\r\n\r\n以下是一些可能导致闭包内存问题的情况：\r\n\r\n1. 未正确释放闭包：如果闭包被长时间持有，而不被释放或不再需要，它会一直引用外部函数的作用域，导致相关的变量和对象无法被垃圾回收。\r\n\r\n2. 循环引用：如果闭包引用了外部函数中的对象，而这些对象又引用了闭包，就会形成循环引用，导致这些对象无法被垃圾回收。\r\n\r\n为避免闭包内存问题，可以采取以下措施：\r\n\r\n1. 避免不必要的闭包：仔细考虑是否真正需要闭包。如果没有必要访问外部函数的作用域，可以避免创建闭包。\r\n\r\n2. 及时释放闭包：当不再需要闭包时，确保及时解除对闭包的引用，以便让垃圾回收机制回收相关的内存。\r\n\r\n3. 减少闭包中的引用数量：尽量减少闭包中引用的变量和对象的数量，特别是大型对象或数据结构。在闭包中引用的对象如果不再使用，应该主动释放对它们的引用。\r\n\r\n4. 注意循环引用：避免形成循环引用的情况，确保对象之间的引用关系能够被垃圾回收。\r\n\r\n正确使用闭包并合理处理闭包的引用可以帮助避免内存泄漏问题。注意在编写代码时考虑内存管理，并且进行适当的测试和性能分析，以确保不会出现潜在的内存泄漏情况。","type":"text/markdown","created":"20230625043330584","creator":"oeyoews","modified":"20230726045248269","modifier":"oeyoews","tags":"JavaScript"},{"title":"问心","text":"<$spotlight src={{!!url}} classname=\"h-24\" />\n\n:::abstract 感受\n感觉是在拖时长\n:::","type":"text/markdown","created":"20231015090243012","creator":"Lenovo","modified":"20231023060045616","modifier":"Lenovo","tags":"电视剧","url":"https://img9.doubanio.com/view/photo/s_ratio_poster/public/p2893493794.webp"},{"title":"静态方法-实例方法-原型方法","text":"## 静态方法\r\n\r\n静态方法是属于类的方法，不需要实例化类就可以使用，可以直接通过类名调用。静态方法通常用于与类本身相关的操作，例如创建工具函数等。\r\n\r\n## 实例方法\r\n\r\n实例方法是属于类的实例的方法，需要实例化类后才能使用。实例方法通常用于处理类实例的属性和状态，例如对实例属性的修改、获取等操作。\r\n\r\n## 原型方法\r\n\r\n原型方法是属于类的原型的方法，需要实例化类后才能使用。原型方法通过类的原型对象来定义和访问。原型方法通常用于处理类实例的属性和状态，例如对实例属性的修改、获取等操作。\r\n\r\n总之，静态方法、实例方法和原型方法都是类中定义的方法，主要区别在于访问方式和用途。其中静态方法是属于类本身的方法，实例方法和原型方法是属于类的实例的方法，且原型方法的效率通常比实例方法高。\r\n\r\n好的，以下是举例说明静态方法、实例方法和原型方法的区别：\r\n\r\n1. 静态方法\r\n\r\n静态方法通常用于创建工具函数或者实现一些通用的操作。例如，假设我们需要实现一个计算两个数之和的函数，可以使用静态方法来实现：\r\n\r\n```js\r\n// es6\r\nclass MathUtils {\r\n  static add(a, b) {\r\n    return a + b;\r\n  }\r\n}\r\n\r\n// es5\r\nfunction MathUtils() {}\r\n\r\n// static method\r\nMathUtils.add = function () {\r\n  return a + b;\r\n};\r\n\r\n// test\r\nconst sum = MathUtils.add(1, 2);\r\nconsole.log(sum); // 3\r\n```\r\n\r\n在上面的代码中，`add`是一个静态方法，可以直接通过类名调用。\r\n\r\n2. 实例方法\r\n\r\n实例方法通常用于处理类实例的属性和状态。例如，假设我们需要实现一个表示人的类，并实现一个方法来输出人的名字：\r\n\r\n```js\r\n// es6\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n\r\n  sayHello() {\r\n    console.log(`Hello, my name is ${this.name}`);\r\n  }\r\n}\r\n\r\n// es5\r\nfunction Person {\r\n\tthis.sayHello = function() {\r\n\t\tconsole.log('xxx')\r\n\t}\r\n}\r\n\r\n// 构造函数中定义的方法会在每个实例中复制一份\r\nconst john = new Person('John');\r\n// instance method\r\njohn.sayHello = function() {\r\n\tconsole.log('xxx')\r\n}\r\njohn.sayHello(); // Hello, my name is John\r\n```\r\n\r\n在上面的代码中，`sayHello`是一个实例方法，只能通过类的实例来调用。\r\n\r\n3. 原型方法\r\n\r\n原型方法通常用于处理类实例的属性和状态，与实例方法类似。例如，假设我们需要实现一个表示人的类，并实现一个方法来输出人的名字：\r\n\r\n```js\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n}\r\n\r\nPerson.prototype.sayHello = function () {\r\n  console.log(`Hello, my name is ${this.name}`);\r\n};\r\n\r\nconst john = new Person('John');\r\njohn.sayHello(); // Hello, my name is John\r\n```\r\n\r\n在上面的代码中，`sayHello`是一个原型方法，可以通过类的实例来调用，与实例方法类似。区别是原型方法通过类的原型对象来定义和访问。\r\n\r\n## 静态属性\r\n\r\n静态属性是属于类本身的属性，不需要实例化类就可以使用，可以直接通过类名调用。静态属性通常用于存储类的元信息或者与类本身相关的数据。\r\n\r\n## 原型属性\r\n\r\n原型属性是属于类的原型的属性，需要实例化类后才能使用。原型属性通过类的原型对象来定义和访问。原型属性通常用于存储类的共享数据或者与类实例相关的数据。\r\n\r\n## 实例属性\r\n\r\n实例属性是属于类实例的属性，需要实例化类后才能使用。实例属性通常用于存储类实例的数据和状态。\r\n\r\n以下是一个使用 ES6 语法定义静态属性、原型属性和实例属性的例子：\r\n\r\n```js\r\nclass Person {\r\n  // 静态属性\r\n  static COUNT = 0;\r\n\r\n  // 原型属性\r\n  logging = {\r\n    name: 'name',\r\n    age: 20,\r\n  };\r\n\r\n  constructor(name, age) {\r\n    // 实例属性\r\n    this.name = name;\r\n    this.age = age;\r\n    Person.COUNT++; // 计数器自增\r\n  }\r\n}\r\n\r\nconst p1 = new Person('demo', 20);\r\nconst p2 = new Person('demo1', 21);\r\nconsole.log(Person.COUNT); // 输出2\r\nconsole.log(p1.logging); // 输出 { name: 'name', age: 20 }\r\nconsole.log(p2.logging); // 输出 { name: 'name', age: 20 }\r\n```\r\n\r\n在上面的代码中，我们使用 ES6 语法定义了一个`Person`类，包含了静态属性、原型属性和实例属性。静态属性通过`static`关键字来定义，原型属性和实例属性则直接在类的构造函数中定义。我们创建了两个`Person`类的实例，每创建一个实例，静态属性`COUNT`都会自增 1。我们还输出了每个实例的`logging`属性，可以看到它是原型属性，可以被所有实例共享。\r\n","type":"text/markdown","created":"20230607142246917","creator":"oeyoews","modified":"20230726045248310","modifier":"oeyoews","tags":"JavaScript"},{"title":"静态方法-实例方法-原型方法01","text":"<$tid2png preview />\r\n\r\n> https://es6.ruanyifeng.com/#docs/class\r\n\r\n1. 静态属性\r\n\r\nES5 中通常使用类的构造函数来定义静态属性：\r\n\r\n```js\r\nfunction Person(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\n\r\nPerson.COUNT = 0;\r\n```\r\n\r\nES6 中使用`static`关键字来定义静态属性：\r\n\r\n```js\r\nclass Person {\r\n  static COUNT = 0;\r\n\r\n  constructor(name, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n    Person.COUNT++;\r\n  }\r\n}\r\n```\r\n\r\n2. 原型属性\r\n\r\nES5 中通常使用类的原型对象来定义原型属性：\r\n\r\n```js\r\nfunction Person(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\n\r\nPerson.prototype.logging = {\r\n  name: 'name',\r\n  age: 20,\r\n};\r\n```\r\n\r\nES6 中可以直接在类的构造函数中定义原型属性：\r\n\r\n```js\r\nclass Person {\r\n  logging = {\r\n    name: 'name',\r\n    age: 20,\r\n  };\r\n\r\n  constructor(name, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n  }\r\n}\r\n```\r\n\r\n3. 实例属性\r\n\r\nES5 中通常在类的构造函数中使用`this`关键字来定义实例属性：\r\n\r\n```js\r\nfunction Person(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\n```\r\n\r\nES6 中也是在类的构造函数中定义实例属性：\r\n\r\n```js\r\nclass Person {\r\n  constructor(name, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n  }\r\n}\r\n```\r\n\r\n4. 静态方法\r\n\r\nES5 中可以使用类的构造函数来定义静态方法：\r\n\r\n```js\r\nfunction Person(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\n\r\nPerson.hello = function() {\r\n  console.log('hello method');\r\n};\r\n```\r\n\r\nES6 中使用`static`关键字来定义静态方法：\r\n\r\n```js\r\nclass Person {\r\n  static hello() {\r\n    console.log('hello method');\r\n  }\r\n\r\n  constructor(name, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n  }\r\n}\r\n```\r\n\r\n5. 原型方法\r\n\r\nES5 中可以使用类的原型对象来定义原型方法：\r\n\r\n```js\r\nfunction Person(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\n\r\nPerson.prototype.log = function() {\r\n  console.log('log method');\r\n};\r\n```\r\n\r\nES6 中可以直接在类的原型对象上定义原型方法：\r\n\r\n```js\r\nclass Person {\r\n  constructor(name, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n  }\r\n\r\n  log() {\r\n    console.log('log method');\r\n  }\r\n}\r\n```\r\n\r\n6. 实例方法\r\n\r\nES5 中可以在类的构造函数中使用`this`关键字来定义实例方法：\r\n\r\n```js\r\nfunction Person(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n\r\n  this.sayHello = function() {\r\n    console.log(`Hello, my name is ${this.name}`);\r\n  };\r\n}\r\n```\r\n\r\nES6 中也是在类的构造函数中定义实例方法：\r\n\r\n```js\r\nclass Person {\r\n  constructor(name, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n  }\r\n\r\n  sayHello() {\r\n    console.log(`Hello, my name is ${this.name}`);\r\n  }\r\n}\r\n```\r\n\r\n以上是 ES5 和 ES6 中定义静态属性、原型属性、实例属性、静态方法、原型方法和实例方法的对比。总的来说，ES6 语法更加简洁明了，同时也提供了更多的语法糖和特性。","type":"text/markdown","created":"20230607150354831","creator":"oeyoews","modified":"20230726045248313","modifier":"oeyoews","tags":"JavaScript"},{"title":"频繁开关机","text":"频繁开关机真的会变砖","type":"text/markdown","created":"20231009113335725","creator":"Lenovo","modified":"20231009113410996","modifier":"Lenovo","tags":"windows"},{"title":"黄金比例","text":"黄金比例是指一种特定的比例关系，通常表示为 1：1.618 或约等于 1.6180339887。它也被称为黄金分割、黄金比率、黄金比例或黄金数。这个数值被称为黄金数或黄金分割常数，用希腊字母φ（phi）表示。\r\n\r\n黄金比例在数学、艺术、建筑、自然科学等领域中被广泛应用。它被认为具有美学上的吸引力和和谐感，因此在艺术和设计中常被用于构图和比例的确定。许多著名的艺术品、建筑物和自然现象都展现了黄金比例的特征。\r\n\r\n黄金比例也在自然界中广泛存在。例如，人体的某些比例关系，如手指的长度比例、头部与身体的比例，以及许多植物的生长模式，都呈现出黄金比例的特征。\r\n\r\n需要注意的是，黄金比例并非绝对规律，它并不适用于所有情况。在艺术和设计中，有时候根据具体需求和审美选择其他比例关系也是常见的。然而，黄金比例作为一种美学和数学的概念，依然具有广泛的影响力和应用。","type":"text/markdown","created":"20230621024622356","creator":"oeyoews","modified":"20230726045248306","modifier":"oeyoews"}]